\hypertarget{class_scalar_functional}{}\doxysection{Scalar\+Functional$<$ dim, spacedim $>$ Class Template Reference}
\label{class_scalar_functional}\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}


{\ttfamily \#include $<$scalar\+\_\+functional.\+h$>$}



Inheritance diagram for Scalar\+Functional$<$ dim, spacedim $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=258pt]{class_scalar_functional__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Scalar\+Functional$<$ dim, spacedim $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=326pt]{class_scalar_functional__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_scalar_functional_ac0618ada3b80400784ee8553a66aade9}{Scalar\+Functional}} (const std\+::vector$<$ \mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$ dim, spacedim $>$$>$ \mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{e\+\_\+sigma}}, const std\+::set$<$ \textbf{ types\+::material\+\_\+id} $>$ \mbox{\hyperlink{class_scalar_functional_ae3b6dd6934e1cd55fcc55cf344179407}{domain\+\_\+of\+\_\+integration}}, const \textbf{ Quadrature}$<$ dim $>$ \mbox{\hyperlink{class_scalar_functional_adea9ff214aeb2a1d8c3712a9d2433883}{quadrature}}, const std\+::string \mbox{\hyperlink{class_scalar_functional_a4d184688053b3443d10e228e4a8eba60}{name}}, const unsigned int \mbox{\hyperlink{class_scalar_functional_a7e12423f4b29e9e0aaa0f7f9c2d1c0eb}{n\+\_\+ref\+\_\+sets}}=0, const unsigned int \mbox{\hyperlink{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}{n\+\_\+hidden}}=0, const \textbf{ Function}$<$ spacedim $>$ $\ast$const \mbox{\hyperlink{class_scalar_functional_a602d0bc2c945822c6b756fc63183ae2b}{initial\+\_\+vals\+\_\+hidden}}=nullptr)
\item 
virtual bool \mbox{\hyperlink{class_scalar_functional_adb295fb739a743d5a1273025eb8dae72}{get\+\_\+h\+\_\+sigma}} (\textbf{ Vector}$<$ double $>$ \&\mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{e\+\_\+sigma}}, const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&e\+\_\+sigma\+\_\+ref\+\_\+sets, \textbf{ Vector}$<$ double $>$ \&hidden\+\_\+vars, const \textbf{ Point}$<$ spacedim $>$ \&x, const \textbf{ Tensor}$<$ 1, spacedim $>$ \&n, double \&h\+\_\+sigma, \textbf{ Vector}$<$ double $>$ \&h\+\_\+sigma\+\_\+1, \textbf{ Full\+Matrix}$<$ double $>$ \&h\+\_\+sigma\+\_\+2, const std\+::tuple$<$ bool, bool, bool $>$ requested\+\_\+quantities) const =0
\item 
bool \mbox{\hyperlink{class_scalar_functional_a0f5c776b9084f350e1c0defa69c81047}{get\+\_\+h\+\_\+omega}} (\textbf{ Vector}$<$ double $>$ \&\mbox{\hyperlink{class_scalar_functional_aff467b5588c5a8a28b805ae886205f9c}{e\+\_\+omega}}, const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&e\+\_\+omega\+\_\+ref\+\_\+sets, \textbf{ Vector}$<$ double $>$ \&hidden\+\_\+vars, const \textbf{ Point}$<$ spacedim $>$ \&x, double \&h\+\_\+omega, \textbf{ Vector}$<$ double $>$ \&h\+\_\+omega\+\_\+1, \textbf{ Full\+Matrix}$<$ double $>$ \&h\+\_\+omega\+\_\+2, const std\+::tuple$<$ bool, bool, bool $>$ requested\+\_\+quantities) const
\item 
virtual double \mbox{\hyperlink{class_scalar_functional_ae4f5fbd69cabfda73cc2b30ae0263ca5}{get\+\_\+maximum\+\_\+step}} (const \textbf{ Vector}$<$ double $>$ \&\mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{e\+\_\+sigma}}, const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&e\+\_\+sigma\+\_\+ref\+\_\+sets, const \textbf{ Vector}$<$ double $>$ \&delta\+\_\+e\+\_\+sigma, const \textbf{ Vector}$<$ double $>$ \&hidden\+\_\+vars, const \textbf{ Point}$<$ spacedim $>$ \&x, const \textbf{ Tensor}$<$ 1, spacedim $>$ \&n) const
\item 
double \mbox{\hyperlink{class_scalar_functional_a71310146c6cc3180e25d90f7b7329c44}{get\+\_\+maximum\+\_\+step}} (const \textbf{ Vector}$<$ double $>$ \&\mbox{\hyperlink{class_scalar_functional_aff467b5588c5a8a28b805ae886205f9c}{e\+\_\+omega}}, const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&e\+\_\+omega\+\_\+ref\+\_\+sets, const \textbf{ Vector}$<$ double $>$ \&delta\+\_\+e\+\_\+omega, const \textbf{ Vector}$<$ double $>$ \&hidden\+\_\+vars, const \textbf{ Point}$<$ spacedim $>$ \&x) const
\item 
void \mbox{\hyperlink{class_scalar_functional_a0c0a2095a33e657a7a984e706ed7f968}{compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives}} (\textbf{ Vector}$<$ double $>$ \&\mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{e\+\_\+sigma}}, const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&e\+\_\+sigma\+\_\+ref\+\_\+sets, \textbf{ Vector}$<$ double $>$ \&hidden\+\_\+vars, const \textbf{ Point}$<$ spacedim $>$ \&x, const \textbf{ Tensor}$<$ 1, spacedim $>$ \&n, const std\+::string detailed\+\_\+printout\+\_\+file=\char`\"{}\char`\"{}, const double \textbf{ epsilon}=1\textbf{ e}-\/8) const
\item 
virtual \mbox{\hyperlink{class_scalar_functional_aed36f35e6d2c9f9a93ee2749d01f2a51}{$\sim$\+Scalar\+Functional}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
const std\+::set$<$ \textbf{ types\+::material\+\_\+id} $>$ \mbox{\hyperlink{class_scalar_functional_ae3b6dd6934e1cd55fcc55cf344179407}{domain\+\_\+of\+\_\+integration}}
\item 
const \textbf{ Smart\+Pointer}$<$ const \textbf{ Function}$<$ spacedim $>$ $>$ \mbox{\hyperlink{class_scalar_functional_a602d0bc2c945822c6b756fc63183ae2b}{initial\+\_\+vals\+\_\+hidden}}
\item 
const std\+::vector$<$ \mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$ dim, spacedim $>$ $>$ \mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{e\+\_\+sigma}}
\item 
const std\+::vector$<$ \mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$ dim, spacedim $>$ $>$ \mbox{\hyperlink{class_scalar_functional_aff467b5588c5a8a28b805ae886205f9c}{e\+\_\+omega}} = std\+::vector$<$\mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$dim, spacedim$>$$>$()
\item 
const \textbf{ Quadrature}$<$ dim $>$ \mbox{\hyperlink{class_scalar_functional_adea9ff214aeb2a1d8c3712a9d2433883}{quadrature}}
\item 
const unsigned int \mbox{\hyperlink{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}{n\+\_\+hidden}}
\item 
const std\+::string \mbox{\hyperlink{class_scalar_functional_a4d184688053b3443d10e228e4a8eba60}{name}}
\item 
const unsigned int \mbox{\hyperlink{class_scalar_functional_a7e12423f4b29e9e0aaa0f7f9c2d1c0eb}{n\+\_\+ref\+\_\+sets}}
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$unsigned int dim, unsigned int spacedim$>$\newline
class Scalar\+Functional$<$ dim, spacedim $>$}

Class defining an interface related scalar functional $H^\Sigma_\tau = \int_\Sigma h^\Sigma_\tau(e^\Sigma_\nu, \boldsymbol{X}) \mathrm{d}S$, where $\tau \in T=\left\{1 \hdots N^\mathrm{H,\Sigma}\right\}$.

\char`\"{}\+Hidden\char`\"{} variables involved in the definition of the functions $h^\Sigma_\tau$ are allowed for (in order to allow for incorporation of e.\+g. classical plasticity formulations).

The integrand $h^\Sigma_\tau$ may, besides the current values of $e^\Sigma_\nu$, also depend on an arbitrary number of sets of \char`\"{}reference values\char`\"{} of $e^\Sigma_\nu$. These reference values can e.\+g. be the values of the $e^\Sigma_\nu$ at previous instants of time. When derivatives of $h^\Sigma_\tau$ w.\+r.\+t. the dependent variables are calculated, these reference values are generally regarded as fixed.

In principle, it is often sufficient that the first and second derivatives of $h^\Sigma_\tau$ are known, as the values themselves do not factor into the finite element system. However, this depends on the exact problem.

The \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}} class inherits from \textbf{ Subscriptor} in order to be able to check that \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}} objects are only destroyed when they are not needed anymore by other objects.


\begin{DoxyTemplParams}{Template Parameters}
{\em dim} & The dimension of the object on which the \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}} is defined. Currently, only {\ttfamily dim} = {\ttfamily spacedim-\/1} is considered, although this class would in principle also work for scalar functionals on lower dimensional objects.\\
\hline
{\em spacedim} & The spatial dimension of the problem \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_scalar_functional_ac0618ada3b80400784ee8553a66aade9}\label{class_scalar_functional_ac0618ada3b80400784ee8553a66aade9}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!ScalarFunctional@{ScalarFunctional}}
\index{ScalarFunctional@{ScalarFunctional}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{ScalarFunctional()}{ScalarFunctional()}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
\mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::\mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}} (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$ dim, spacedim $>$$>$}]{e\+\_\+sigma,  }\item[{const std\+::set$<$ \textbf{ types\+::material\+\_\+id} $>$}]{domain\+\_\+of\+\_\+integration,  }\item[{const \textbf{ Quadrature}$<$ dim $>$}]{quadrature,  }\item[{const std\+::string}]{name,  }\item[{const unsigned int}]{n\+\_\+ref\+\_\+sets = {\ttfamily 0},  }\item[{const unsigned int}]{n\+\_\+hidden = {\ttfamily 0},  }\item[{const \textbf{ Function}$<$ spacedim $>$ $\ast$const}]{initial\+\_\+vals\+\_\+hidden = {\ttfamily nullptr} }\end{DoxyParamCaption})}

The constructor of the class


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e\+\_\+sigma} & \mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{Scalar\+Functional\+::e\+\_\+sigma}}\\
\hline
\mbox{\texttt{ in}}  & {\em domain\+\_\+of\+\_\+integration} & \mbox{\hyperlink{class_scalar_functional_ae3b6dd6934e1cd55fcc55cf344179407}{Scalar\+Functional\+::domain\+\_\+of\+\_\+integration}}\\
\hline
\mbox{\texttt{ in}}  & {\em quadrature} & \mbox{\hyperlink{class_scalar_functional_adea9ff214aeb2a1d8c3712a9d2433883}{Scalar\+Functional\+::quadrature}}\\
\hline
\mbox{\texttt{ in}}  & {\em name} & \mbox{\hyperlink{class_scalar_functional_a4d184688053b3443d10e228e4a8eba60}{Scalar\+Functional\+::name}}\\
\hline
\mbox{\texttt{ in}}  & {\em n\+\_\+ref\+\_\+sets} & \mbox{\hyperlink{class_scalar_functional_a7e12423f4b29e9e0aaa0f7f9c2d1c0eb}{Scalar\+Functional\+::n\+\_\+ref\+\_\+sets}}\\
\hline
\mbox{\texttt{ in}}  & {\em n\+\_\+hidden} & \mbox{\hyperlink{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}{Scalar\+Functional\+::n\+\_\+hidden}}\\
\hline
\mbox{\texttt{ in}}  & {\em initial\+\_\+vals\+\_\+hidden} & \mbox{\hyperlink{class_scalar_functional_a602d0bc2c945822c6b756fc63183ae2b}{Scalar\+Functional\+::initial\+\_\+vals\+\_\+hidden}} (if {\ttfamily n\+\_\+hidden$>$0} and this argument is omitted, the initial values will be set to zero) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_scalar_functional_aed36f35e6d2c9f9a93ee2749d01f2a51}\label{class_scalar_functional_aed36f35e6d2c9f9a93ee2749d01f2a51}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!````~ScalarFunctional@{$\sim$ScalarFunctional}}
\index{````~ScalarFunctional@{$\sim$ScalarFunctional}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$ScalarFunctional()}{~ScalarFunctional()}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
virtual \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::$\sim$\mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

The destructor of \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}} essentially checks before destruction that the \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}} object is not used by other objects. If this is the case, the program will be aborted. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_scalar_functional_a0c0a2095a33e657a7a984e706ed7f968}\label{class_scalar_functional_a0c0a2095a33e657a7a984e706ed7f968}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!compare\_derivatives\_with\_numerical\_derivatives@{compare\_derivatives\_with\_numerical\_derivatives}}
\index{compare\_derivatives\_with\_numerical\_derivatives@{compare\_derivatives\_with\_numerical\_derivatives}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{compare\_derivatives\_with\_numerical\_derivatives()}{compare\_derivatives\_with\_numerical\_derivatives()}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
void \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives (\begin{DoxyParamCaption}\item[{\textbf{ Vector}$<$ double $>$ \&}]{e\+\_\+sigma,  }\item[{const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&}]{e\+\_\+sigma\+\_\+ref\+\_\+sets,  }\item[{\textbf{ Vector}$<$ double $>$ \&}]{hidden\+\_\+vars,  }\item[{const \textbf{ Point}$<$ spacedim $>$ \&}]{x,  }\item[{const \textbf{ Tensor}$<$ 1, spacedim $>$ \&}]{n,  }\item[{const std\+::string}]{detailed\+\_\+printout\+\_\+file = {\ttfamily \char`\"{}\char`\"{}},  }\item[{const double}]{epsilon = {\ttfamily 1\textbf{ e}-\/8} }\end{DoxyParamCaption}) const}

Function comparing the computed derivatives of the integrand $h^\Sigma_\tau$ provided by \mbox{\hyperlink{class_scalar_functional_adb295fb739a743d5a1273025eb8dae72}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()}} with corresponding numerically computed finite difference based derivatives.

In the case of the first derivative, the numerical derivatives are obtained based on the values for $h^\Sigma_\tau$ provided by \mbox{\hyperlink{class_scalar_functional_adb295fb739a743d5a1273025eb8dae72}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()}}; and in the case of the second derivatives, the numerical derivatives are obtained based on the values for the first derivatives of $h^\Sigma_\tau$ provided by \mbox{\hyperlink{class_scalar_functional_adb295fb739a743d5a1273025eb8dae72}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()}} ). In both cases, a simple forward finite difference approach is used. Generally, the first numerical derivative can only be \char`\"{}correct\char`\"{} if the computation of the value of $h^\Sigma_\tau$ is correctly implemented in the function \mbox{\hyperlink{class_scalar_functional_adb295fb739a743d5a1273025eb8dae72}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()}}; and likewise the second numerical derivative can only be \char`\"{}correct\char`\"{} if the computation of the first derivative of $h^\Sigma_\tau$ is correctly implemented in the function \mbox{\hyperlink{class_scalar_functional_adb295fb739a743d5a1273025eb8dae72}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()}}.

This function is essentially meant for testing of user defined functions \mbox{\hyperlink{class_scalar_functional_adb295fb739a743d5a1273025eb8dae72}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()}}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e\+\_\+sigma} & Values of $e^\Sigma_\nu$ (the ordering is defined by the ordering of the dependent fields in \mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{Scalar\+Functional\+::e\+\_\+sigma}})\\
\hline
\mbox{\texttt{ in}}  & {\em e\+\_\+sigma\+\_\+ref\+\_\+sets} & Sets of reference values of $e^\Sigma_\nu$ (as required according to \mbox{\hyperlink{class_scalar_functional_a7e12423f4b29e9e0aaa0f7f9c2d1c0eb}{Scalar\+Functional\+::n\+\_\+ref\+\_\+sets}})\\
\hline
\mbox{\texttt{ in,out}}  & {\em hidden\+\_\+vars} & Values of \char`\"{}hidden\char`\"{} variables associated with the integrand $h^\Sigma_\tau$. This vector has the size \mbox{\hyperlink{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}{Scalar\+Functional\+::n\+\_\+hidden}}.\\
\hline
\mbox{\texttt{ in}}  & {\em x} & Location of material point at which integrand $h^\Sigma_\tau$ and derivatives thereof are evaluated\\
\hline
\mbox{\texttt{ in}}  & {\em n} & Normal vector pointing from -\/ to + side of the interface $\Sigma$ at {\ttfamily x} \\
\hline
\mbox{\texttt{ in}}  & {\em detailed\+\_\+printout\+\_\+file} & A file to which detailed printout is written if requested\\
\hline
\mbox{\texttt{ in}}  & {\em epsilon} & Step width for finite difference computation \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_scalar_functional_a0f5c776b9084f350e1c0defa69c81047}\label{class_scalar_functional_a0f5c776b9084f350e1c0defa69c81047}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!get\_h\_omega@{get\_h\_omega}}
\index{get\_h\_omega@{get\_h\_omega}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{get\_h\_omega()}{get\_h\_omega()}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
bool \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::get\+\_\+h\+\_\+omega (\begin{DoxyParamCaption}\item[{\textbf{ Vector}$<$ double $>$ \&}]{e\+\_\+omega,  }\item[{const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&}]{e\+\_\+omega\+\_\+ref\+\_\+sets,  }\item[{\textbf{ Vector}$<$ double $>$ \&}]{hidden\+\_\+vars,  }\item[{const \textbf{ Point}$<$ spacedim $>$ \&}]{x,  }\item[{double \&}]{h\+\_\+omega,  }\item[{\textbf{ Vector}$<$ double $>$ \&}]{h\+\_\+omega\+\_\+1,  }\item[{\textbf{ Full\+Matrix}$<$ double $>$ \&}]{h\+\_\+omega\+\_\+2,  }\item[{const std\+::tuple$<$ bool, bool, bool $>$}]{requested\+\_\+quantities }\end{DoxyParamCaption}) const}

This function (\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a8665cb5b5a57ad22217e4c112845d43b}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega}}) exists only to allow for using the same code for domain and interface related scalar functionals. It should never be called and therefore throws an exception. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_scalar_functional_adb295fb739a743d5a1273025eb8dae72}\label{class_scalar_functional_adb295fb739a743d5a1273025eb8dae72}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!get\_h\_sigma@{get\_h\_sigma}}
\index{get\_h\_sigma@{get\_h\_sigma}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{get\_h\_sigma()}{get\_h\_sigma()}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
virtual bool \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::get\+\_\+h\+\_\+sigma (\begin{DoxyParamCaption}\item[{\textbf{ Vector}$<$ double $>$ \&}]{e\+\_\+sigma,  }\item[{const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&}]{e\+\_\+sigma\+\_\+ref\+\_\+sets,  }\item[{\textbf{ Vector}$<$ double $>$ \&}]{hidden\+\_\+vars,  }\item[{const \textbf{ Point}$<$ spacedim $>$ \&}]{x,  }\item[{const \textbf{ Tensor}$<$ 1, spacedim $>$ \&}]{n,  }\item[{double \&}]{h\+\_\+sigma,  }\item[{\textbf{ Vector}$<$ double $>$ \&}]{h\+\_\+sigma\+\_\+1,  }\item[{\textbf{ Full\+Matrix}$<$ double $>$ \&}]{h\+\_\+sigma\+\_\+2,  }\item[{const std\+::tuple$<$ bool, bool, bool $>$}]{requested\+\_\+quantities }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

Function for evaluation of integrand $h^\Sigma_\tau$ and computation of first and second derivatives w.\+r.\+t. the dependent fields $e^\Sigma_\nu$.

Derived user defined scalar functionals implement this function or it\textquotesingle{}s other version in case local dependent fields are involved.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em e\+\_\+sigma} & Values of $e^\Sigma_\nu$ (the ordering is defined by the ordering of the dependent fields in \mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{Scalar\+Functional\+::e\+\_\+sigma}}). Note that this vector is non-\/const, as in the case of local dependent fields updated values of these may be returned.\\
\hline
\mbox{\texttt{ in}}  & {\em e\+\_\+sigma\+\_\+ref\+\_\+sets} & Sets of reference values of $e^\Sigma_\nu$ (as required according to \mbox{\hyperlink{class_scalar_functional_a7e12423f4b29e9e0aaa0f7f9c2d1c0eb}{Scalar\+Functional\+::n\+\_\+ref\+\_\+sets}})\\
\hline
\mbox{\texttt{ in,out}}  & {\em hidden\+\_\+vars} & Values of \char`\"{}hidden\char`\"{} variables associated with the integrand $h^\Sigma_\tau$. This vector has the size \mbox{\hyperlink{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}{Scalar\+Functional\+::n\+\_\+hidden}}. The inputs are the previously known values of the hidden variables, which may be overwritten by the function (the user can decide during assembly of the finite element system whether the returned updated values of the hidden variables are really used to update the stored values of the hidden variables or whether they are discarded)\\
\hline
\mbox{\texttt{ in}}  & {\em x} & Location of material point at which integrand $h^\Sigma_\tau$ and derivatives thereof are evaluated\\
\hline
\mbox{\texttt{ in}}  & {\em n} & Normal vector pointing from -\/ to + side of the interface $\Sigma$ at {\ttfamily x} \\
\hline
\mbox{\texttt{ out}}  & {\em h\+\_\+sigma} & Current value of $h^\Sigma_\tau$.\\
\hline
\mbox{\texttt{ out}}  & {\em h\+\_\+sigma\+\_\+1} & First derivatives of $h^\Sigma_\tau$ w.\+r.\+t. $e^\Sigma_\nu$ (the ordering is defined by the ordering of the dependent fields in \mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{Scalar\+Functional\+::e\+\_\+sigma}}, and {\ttfamily h\+\_\+sigma\+\_\+1} will already be initialized to the correct size if it is called by \mbox{\hyperlink{class_assembly_helper}{Assembly\+Helper}} objects)\\
\hline
\mbox{\texttt{ out}}  & {\em h\+\_\+sigma\+\_\+2} & Second derivatives of $h^\Sigma_\tau$ w.\+r.\+t. $e^\Sigma_\nu$ (the ordering is defined by the ordering of the dependent fields in \mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{Scalar\+Functional\+::e\+\_\+sigma}}, and {\ttfamily h\+\_\+sigma\+\_\+2} will already be initialized to the correct size if it is called by \mbox{\hyperlink{class_assembly_helper}{Assembly\+Helper}} objects). If $h^\Sigma_\tau$ exists, this matrix will generally be symmetric. However, in principle the routines do also work for cases where $h^\Sigma_\tau$ does not exist and {\ttfamily h\+\_\+sigma\+\_\+2} is not symmetric.\\
\hline
\mbox{\texttt{ in}}  & {\em requested\+\_\+quantities} & A tuple indicating which quantities are actually to be computed (e.\+g. ({\ttfamily true}, {\ttfamily false}, {\ttfamily true}) indicates that {\ttfamily h\+\_\+sigma} and {\ttfamily h\+\_\+sigma\+\_\+2} are to be computed)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily false} if the evaluation of the integrand $h^\Sigma_\tau$ and its derivatives was successful, and {\ttfamily true} if an error prevented the proper calculation of these quantities (e.\+g. because a dependent field, which should be non-\/negative, was actually negative) 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{class_scalar_functional_local_elimination_a458ebe9d4709117e66fc1e03e220fbf7}{Scalar\+Functional\+Local\+Elimination$<$ dim, spacedim $>$}}.

\mbox{\Hypertarget{class_scalar_functional_a71310146c6cc3180e25d90f7b7329c44}\label{class_scalar_functional_a71310146c6cc3180e25d90f7b7329c44}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!get\_maximum\_step@{get\_maximum\_step}}
\index{get\_maximum\_step@{get\_maximum\_step}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{get\_maximum\_step()}{get\_maximum\_step()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
double \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::get\+\_\+maximum\+\_\+step (\begin{DoxyParamCaption}\item[{const \textbf{ Vector}$<$ double $>$ \&}]{e\+\_\+omega,  }\item[{const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&}]{e\+\_\+omega\+\_\+ref\+\_\+sets,  }\item[{const \textbf{ Vector}$<$ double $>$ \&}]{delta\+\_\+e\+\_\+omega,  }\item[{const \textbf{ Vector}$<$ double $>$ \&}]{hidden\+\_\+vars,  }\item[{const \textbf{ Point}$<$ spacedim $>$ \&}]{x }\end{DoxyParamCaption}) const}

This function (\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_add1852ebe7ad8b1178063ff725748856}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+maximum\+\_\+step}}) exists only to allow for using the same code for domain and interface related scalar functionals. It should never be called and therefore throws an exception. 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_scalar_functional_ae4f5fbd69cabfda73cc2b30ae0263ca5}\label{class_scalar_functional_ae4f5fbd69cabfda73cc2b30ae0263ca5}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!get\_maximum\_step@{get\_maximum\_step}}
\index{get\_maximum\_step@{get\_maximum\_step}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{get\_maximum\_step()}{get\_maximum\_step()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
virtual double \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::get\+\_\+maximum\+\_\+step (\begin{DoxyParamCaption}\item[{const \textbf{ Vector}$<$ double $>$ \&}]{e\+\_\+sigma,  }\item[{const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&}]{e\+\_\+sigma\+\_\+ref\+\_\+sets,  }\item[{const \textbf{ Vector}$<$ double $>$ \&}]{delta\+\_\+e\+\_\+sigma,  }\item[{const \textbf{ Vector}$<$ double $>$ \&}]{hidden\+\_\+vars,  }\item[{const \textbf{ Point}$<$ spacedim $>$ \&}]{x,  }\item[{const \textbf{ Tensor}$<$ 1, spacedim $>$ \&}]{n }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

Function for evaluation of the maximum permissible step length


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e\+\_\+sigma} & Values of $e^\Sigma_\nu$ (the ordering is defined by the ordering of the dependent fields in \mbox{\hyperlink{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}{Scalar\+Functional\+::e\+\_\+sigma}})\\
\hline
\mbox{\texttt{ in}}  & {\em e\+\_\+sigma\+\_\+ref\+\_\+sets} & Sets of reference values of $e^\Sigma_\nu$ (as required according to \mbox{\hyperlink{class_scalar_functional_a7e12423f4b29e9e0aaa0f7f9c2d1c0eb}{Scalar\+Functional\+::n\+\_\+ref\+\_\+sets}})\\
\hline
\mbox{\texttt{ in}}  & {\em delta\+\_\+e\+\_\+sigma} & Values of $\Delta e^\Sigma_\nu$\\
\hline
\mbox{\texttt{ in}}  & {\em hidden\+\_\+vars} & Values of \char`\"{}hidden\char`\"{} variables associated with the integrand $h^\Sigma_\tau$. This vector has the size \mbox{\hyperlink{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}{Scalar\+Functional\+::n\+\_\+hidden}}.\\
\hline
\mbox{\texttt{ in}}  & {\em x} & Location of material point\\
\hline
\mbox{\texttt{ in}}  & {\em n} & Normal vector pointing from -\/ to + side of the interface $\Sigma$ at {\ttfamily x} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The maximum $\alpha$ such that $e^\Sigma_\nu + \alpha \Delta e^\Sigma_\nu$ is a permissible state; the standard implementation returns D\+B\+L\+\_\+\+M\+AX 
\end{DoxyReturn}


Reimplemented in \mbox{\hyperlink{class_scalar_functional_local_elimination_abd08e15318c711bd4fdb2a66d378460f}{Scalar\+Functional\+Local\+Elimination$<$ dim, spacedim $>$}}.



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_scalar_functional_ae3b6dd6934e1cd55fcc55cf344179407}\label{class_scalar_functional_ae3b6dd6934e1cd55fcc55cf344179407}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!domain\_of\_integration@{domain\_of\_integration}}
\index{domain\_of\_integration@{domain\_of\_integration}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{domain\_of\_integration}{domain\_of\_integration}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
const std\+::set$<$\textbf{ types\+::material\+\_\+id}$>$ \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::domain\+\_\+of\+\_\+integration}

Set of \textbf{ types\+::material\+\_\+id}s determining the interfacial domain of integration (i.\+e. those regions of the total interface $\Sigma$, where the integrand $h^\Sigma_\tau$ is non-\/zero). \mbox{\Hypertarget{class_scalar_functional_aff467b5588c5a8a28b805ae886205f9c}\label{class_scalar_functional_aff467b5588c5a8a28b805ae886205f9c}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!e\_omega@{e\_omega}}
\index{e\_omega@{e\_omega}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{e\_omega}{e\_omega}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
const std\+::vector$<$\mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$dim, spacedim$>$ $>$ \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::e\+\_\+omega = std\+::vector$<$\mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$dim, spacedim$>$$>$()}

This member exists only to allow for using the same code for domain and interface related scalar functionals.. \mbox{\Hypertarget{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}\label{class_scalar_functional_a86662b03a63219227993a2c6c07aefc1}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!e\_sigma@{e\_sigma}}
\index{e\_sigma@{e\_sigma}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{e\_sigma}{e\_sigma}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
const std\+::vector$<$\mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$dim, spacedim$>$ $>$ \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::e\+\_\+sigma}

Vector containing the dependent fields $e^\Sigma_\nu$ whereupon the integrand $h^\Sigma_\tau$ depends. The ordering in this vector defines the ordering in vectors and matrices related to derivatives of $h^\Sigma_\tau$ w.\+r.\+t. the dependent fields $e^\Sigma_\nu$. \mbox{\Hypertarget{class_scalar_functional_a602d0bc2c945822c6b756fc63183ae2b}\label{class_scalar_functional_a602d0bc2c945822c6b756fc63183ae2b}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!initial\_vals\_hidden@{initial\_vals\_hidden}}
\index{initial\_vals\_hidden@{initial\_vals\_hidden}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{initial\_vals\_hidden}{initial\_vals\_hidden}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
const \textbf{ Smart\+Pointer}$<$const \textbf{ Function}$<$spacedim$>$ $>$ \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::initial\+\_\+vals\+\_\+hidden}

A {\ttfamily \textbf{ Function}}, which must be supplied by the user for determination of non-\/zero initial values of the hidden variables (applies only if \mbox{\hyperlink{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}{Scalar\+Functional\+::n\+\_\+hidden}} $>$ 0).

The number of components of \mbox{\hyperlink{class_scalar_functional_a602d0bc2c945822c6b756fc63183ae2b}{Scalar\+Functional\+::initial\+\_\+vals\+\_\+hidden}} must be equal to \mbox{\hyperlink{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}{Scalar\+Functional\+::n\+\_\+hidden}}

As a minimum requirement, \mbox{\hyperlink{class_scalar_functional_a602d0bc2c945822c6b756fc63183ae2b}{Scalar\+Functional\+::initial\+\_\+vals\+\_\+hidden}} must implement the method \textbf{ Function\+::value()}. \mbox{\Hypertarget{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}\label{class_scalar_functional_a8b1617930242870f22eef5e306cb717f}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!n\_hidden@{n\_hidden}}
\index{n\_hidden@{n\_hidden}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{n\_hidden}{n\_hidden}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
const unsigned int \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::n\+\_\+hidden}

Number of \char`\"{}hidden\char`\"{} variables associated with the integrand $h^\Sigma_\tau$ of the scalar functional \mbox{\Hypertarget{class_scalar_functional_a7e12423f4b29e9e0aaa0f7f9c2d1c0eb}\label{class_scalar_functional_a7e12423f4b29e9e0aaa0f7f9c2d1c0eb}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!n\_ref\_sets@{n\_ref\_sets}}
\index{n\_ref\_sets@{n\_ref\_sets}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{n\_ref\_sets}{n\_ref\_sets}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
const unsigned int \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::n\+\_\+ref\+\_\+sets}

The number of sets of reference values of the dependent fields $e^\Sigma_\nu$ involved in the definition of the integrand $h^\Sigma_\tau$ \mbox{\Hypertarget{class_scalar_functional_a4d184688053b3443d10e228e4a8eba60}\label{class_scalar_functional_a4d184688053b3443d10e228e4a8eba60}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!name@{name}}
\index{name@{name}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{name}{name}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
const std\+::string \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::name}

A name for the scalar functional \mbox{\Hypertarget{class_scalar_functional_adea9ff214aeb2a1d8c3712a9d2433883}\label{class_scalar_functional_adea9ff214aeb2a1d8c3712a9d2433883}} 
\index{ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}!quadrature@{quadrature}}
\index{quadrature@{quadrature}!ScalarFunctional$<$ dim, spacedim $>$@{ScalarFunctional$<$ dim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{quadrature}{quadrature}}
{\footnotesize\ttfamily template$<$unsigned int dim, unsigned int spacedim$>$ \\
const \textbf{ Quadrature}$<$dim$>$ \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ dim, spacedim $>$\+::quadrature}

\textbf{ Quadrature} rule when integrating over the domain determined by \mbox{\hyperlink{class_scalar_functional_ae3b6dd6934e1cd55fcc55cf344179407}{Scalar\+Functional\+::domain\+\_\+of\+\_\+integration}} 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/sst/code/\+Galerkin\+Tools/\+Galerkin\+Tools/include/galerkin\+\_\+tools/\mbox{\hyperlink{scalar__functional_8h}{scalar\+\_\+functional.\+h}}\end{DoxyCompactItemize}
