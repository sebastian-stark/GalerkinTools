\hypertarget{class_assembly_helper}{}\section{Assembly\+Helper$<$ spacedim $>$ Class Template Reference}
\label{class_assembly_helper}\index{Assembly\+Helper$<$ spacedim $>$@{Assembly\+Helper$<$ spacedim $>$}}


{\ttfamily \#include $<$assembly\+\_\+helper.\+h$>$}



Collaboration diagram for Assembly\+Helper$<$ spacedim $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_assembly_helper__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_assembly_helper_ae164448dcc5e9e8d2849c354212d6df5}{Assembly\+Helper} (const \hyperlink{class_total_potential}{Total\+Potential}$<$ spacedim $>$ \&\hyperlink{class_assembly_helper_a748eed9d73b7437a4bf2dcd73108790b}{total\+\_\+potential}, \hyperlink{class_triangulation_system}{Triangulation\+System}$<$ spacedim $>$ \&\hyperlink{class_assembly_helper_add08a8a7bb9c9325fcc7d92bfce525d4}{tria\+\_\+system}, const {\bf Mapping}$<$ spacedim, spacedim $>$ \&\hyperlink{class_assembly_helper_a3fbb49461000dea8f64266f830709fad}{mapping\+\_\+domain}, const {\bf Mapping}$<$ spacedim-\/1, spacedim $>$ \&\hyperlink{class_assembly_helper_a055fde6217c18e62cd80188d0130c201}{mapping\+\_\+interface}, const std\+::set$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ 0, spacedim $>$ $\ast$ $>$ \&independent\+\_\+scalars=std\+::set$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ 0, spacedim $>$ $\ast$ $>$())
\item 
\hyperlink{class_assembly_helper_ac82eca7b04aedf772028c6ff77245e9b}{$\sim$\+Assembly\+Helper} ()
\end{DoxyCompactItemize}
\begin{Indent}{\bf Methods for assembly of the finite element system}\par
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Vector\+Type $>$ }\\void \hyperlink{class_assembly_helper_ade14ba73257f862f4e9cde8d0d6df12e}{get\+\_\+initial\+\_\+fields\+\_\+vector} ({\bf Vector\+Type} \&initial\+\_\+fields, const Affine\+Constraints$<$ double $>$ $\ast$constraints=nullptr) const 
\item 
void \hyperlink{class_assembly_helper_ab9602b90beefa27eba50d9d837c1bf7b}{make\+\_\+dirichlet\+\_\+constraints} (Affine\+Constraints$<$ double $>$ \&constraint\+\_\+matrix, const std\+::vector$<$ const \hyperlink{class_dirichlet_constraint}{Dirichlet\+Constraint}$<$ spacedim $>$ $\ast$ $>$ \&dirichlet\+\_\+constraints, const Affine\+Constraints$<$ double $>$ \&constraints\+\_\+ignore=Affine\+Constraints$<$ double $>$()) const 
\item 
{\footnotesize template$<$class Sparsity\+Pattern\+Type $>$ }\\void \hyperlink{class_assembly_helper_af45c789076262ceb24613c04427b654e}{generate\+\_\+sparsity\+\_\+pattern\+\_\+by\+\_\+simulation} (Sparsity\+Pattern\+Type \&dsp\+\_\+K, const Affine\+Constraints$<$ double $>$ \&constraints) const 
\item 
{\footnotesize template$<$class Solution\+Vector\+Type , class R\+H\+S\+Vector\+Type , class Matrix\+Type $>$ }\\bool \hyperlink{class_assembly_helper_a9d2f3d1152046e639acfa6f6ac317b37}{assemble\+\_\+system} (const Solution\+Vector\+Type \&solution, const std\+::vector$<$ const Solution\+Vector\+Type $\ast$ $>$ solution\+\_\+ref\+\_\+sets, const Affine\+Constraints$<$ double $>$ \&constraints, double \&potential\+\_\+value, R\+H\+S\+Vector\+Type \&f, Matrix\+Type \&K, const std\+::tuple$<$ bool, bool, bool $>$ requested\+\_\+quantities=std\+::make\+\_\+tuple(true, true, true)) const 
\item 
{\footnotesize template$<$class Vector\+Type $>$ }\\bool \hyperlink{class_assembly_helper_a43bac43f3aecf18e08bfd1741cf30af6}{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values} (const {\bf Vector\+Type} \&solution, const std\+::vector$<$ const {\bf Vector\+Type} $\ast$ $>$ solution\+\_\+ref\+\_\+sets, std\+::map$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim, spacedim $>$ $\ast$, double $>$ \&nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values\+\_\+domain, std\+::map$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim-\/1, spacedim $>$ $\ast$, double $>$ \&nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values\+\_\+interface) const 
\item 
{\footnotesize template$<$class Vector\+Type $>$ }\\double \hyperlink{class_assembly_helper_aae924a79482fed55899a59052bd9103d}{get\+\_\+maximum\+\_\+step\+\_\+length} (const {\bf Vector\+Type} \&solution, const std\+::vector$<$ const {\bf Vector\+Type} $\ast$ $>$ solution\+\_\+ref\+\_\+sets, const {\bf Vector\+Type} \&delta\+\_\+solution) const 
\item 
{\footnotesize template$<$class Vector\+Type $>$ }\\void \hyperlink{class_assembly_helper_ac87490e0d3d84b11e2f7187f8706dab6}{compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives} (const {\bf Vector\+Type} \&solution, const std\+::vector$<$ const {\bf Vector\+Type} $\ast$ $>$ solution\+\_\+ref\+\_\+sets, const std\+::string detailed\+\_\+printout\+\_\+file=\char`\"{}\char`\"{}, const double {\bf epsilon}=1e-\/8) const 
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Methods for writing output}\par
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Vector\+Type $>$ }\\std\+::pair$<$ const std\+::string, const std\+::string $>$ \hyperlink{class_assembly_helper_a74187aa98464043ea6572c3ac345640e}{write\+\_\+output\+\_\+independent\+\_\+fields} (const {\bf Vector\+Type} \&solution, const std\+::string file\+\_\+name\+\_\+domain, const std\+::string file\+\_\+name\+\_\+interface, const unsigned int file\+\_\+index=0, const std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$ \&dp\+\_\+domain=std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$(), const std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$ \&dp\+\_\+interface=std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$(), const unsigned int n\+\_\+subdivisions=1) const 
\item 
void \hyperlink{class_assembly_helper_afd598b93397e6af53f0e4e274e6f880e}{print\+\_\+assembly\+\_\+helper\+\_\+definition} (const bool detailed\+\_\+printout\+\_\+shapefuns=true) const 
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Methods for comparing solutions}\par
{\em These methods are essentially intended for studies of the convergence behavior. Two types of methods are offered. The first allows comparison with a different numerical solution obtained on a differently refined mesh; and the second allows comparison with an analytical solution. }\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$class Vector\+Type $>$ }\\std\+::pair$<$ const double, const double $>$ \hyperlink{class_assembly_helper_ac7860831588d35d05009474f2a695e14}{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution} (const {\bf Vector\+Type} \&solution, const {\bf Vector\+Type} \&other\+\_\+solution, const \hyperlink{class_assembly_helper}{Assembly\+Helper}$<$ spacedim $>$ \&other\+\_\+assembly\+\_\+helper, const {\bf Quadrature}$<$ spacedim $>$ quadrature\+\_\+domain, const {\bf Quadrature}$<$ spacedim-\/1 $>$ quadrature\+\_\+interface, const {\bf Vector\+Tools\+::\+Norm\+Type} norm\+\_\+type=Vector\+Tools\+::\+Norm\+Type\+::\+L2\+\_\+norm, const {\bf Component\+Mask} component\+\_\+mask\+\_\+domain={\bf Component\+Mask}(), const {\bf Component\+Mask} component\+\_\+mask\+\_\+interface={\bf Component\+Mask}(), const double exponent=2.\+0) const 
\item 
{\footnotesize template$<$class Vector\+Type $>$ }\\std\+::pair$<$ const double, const double $>$ \hyperlink{class_assembly_helper_aca82c19b1abbc316d0bc563e04db727c}{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution} (const {\bf Vector\+Type} \&solution, const {\bf Function}$<$ spacedim $>$ \&exact\+\_\+solution\+\_\+domain, const {\bf Function}$<$ spacedim $>$ \&exact\+\_\+solution\+\_\+interface, const {\bf Quadrature}$<$ spacedim $>$ quadrature\+\_\+domain, const {\bf Quadrature}$<$ spacedim-\/1 $>$ quadrature\+\_\+interface, const {\bf Vector\+Tools\+::\+Norm\+Type} norm\+\_\+type=Vector\+Tools\+::\+Norm\+Type\+::\+L2\+\_\+norm, const {\bf Component\+Mask} component\+\_\+mask\+\_\+domain={\bf Component\+Mask}(), const {\bf Component\+Mask} component\+\_\+mask\+\_\+interface={\bf Component\+Mask}(), const double exponent=2.\+0) const 
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Methods for querying information about the Assembly\+Helper object.}\par
\begin{DoxyCompactItemize}
\item 
const \hyperlink{class_triangulation_system}{Triangulation\+System}$<$ spacedim $>$ \& \hyperlink{class_assembly_helper_a261ecb9213338856aa88c8ae60a44c78}{get\+\_\+triangulation\+\_\+system} () const 
\item 
\hyperlink{class_triangulation_system}{Triangulation\+System}$<$ spacedim $>$ \& \hyperlink{class_assembly_helper_a16f9d21a79922d4879e37916b414f7d0}{get\+\_\+triangulation\+\_\+system} ()
\item 
const \hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System}$<$ spacedim $>$ \& \hyperlink{class_assembly_helper_ab8e95f0469f1595ab00c3fb48bcaf4fd}{get\+\_\+dof\+\_\+handler\+\_\+system} () const 
\item 
\hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System}$<$ spacedim $>$ \& \hyperlink{class_assembly_helper_a04523eef6062ced8c88d4c093b65df3d}{get\+\_\+dof\+\_\+handler\+\_\+system} ()
\item 
std\+::map$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim, spacedim $>$ $\ast$, const unsigned int $>$ \hyperlink{class_assembly_helper_a396b89981e546af6b9bc0e35634290b3}{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+indices} () const 
\item 
std\+::map$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim-\/1, spacedim $>$ $\ast$, const unsigned int $>$ \hyperlink{class_assembly_helper_aca4d34e08f177e8d075c86bb34906f2f}{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+indices} () const 
\item 
unsigned int \hyperlink{class_assembly_helper_a41bdbb21e3f77cf717c9f7465363e415}{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+index} (const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim, spacedim $>$ \&\hyperlink{class_assembly_helper_a1952a054a839a7a683ca108013e7d976}{u\+\_\+omega}) const 
\item 
unsigned int \hyperlink{class_assembly_helper_a9a8e7a9f29b275dc20811cac001bd18f}{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+index} (const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim-\/1, spacedim $>$ \&\hyperlink{class_assembly_helper_a696fe649b3503561235aa1ccbf2ddeef}{u\+\_\+sigma}) const 
\item 
unsigned int \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{system\+\_\+size} () const 
\item 
unsigned int \hyperlink{class_assembly_helper_a5cd3242e02bc5cb8b74cf808df257da0}{get\+\_\+n\+\_\+stretched\+\_\+rows} () const 
\item 
unsigned int \hyperlink{class_assembly_helper_ad6590021b351fac59dcc655e3d0da9ee}{get\+\_\+n\+\_\+C} () const 
\item 
unsigned int \hyperlink{class_assembly_helper_a035fabd9601baf9efade5393164ea370}{get\+\_\+global\+\_\+dof\+\_\+index\+\_\+C} (const \hyperlink{class_independent_field}{Independent\+Field}$<$ 0, spacedim $>$ $\ast$independent\+\_\+scalar) const 
\item 
const {\bf Index\+Set} \hyperlink{class_assembly_helper_ae6c72b5ed3b1cd419d58e081562e0ee7}{get\+\_\+locally\+\_\+relevant\+\_\+indices} () const 
\item 
const {\bf Index\+Set} \hyperlink{class_assembly_helper_a51d99905072b1e6d1aadc43e62c5af92}{get\+\_\+locally\+\_\+owned\+\_\+indices} () const 
\item 
const std\+::vector$<$ {\bf Index\+Set} $>$ \hyperlink{class_assembly_helper_ae405978288614436b0851e1d9047f084}{get\+\_\+locally\+\_\+relevant\+\_\+indices\+\_\+blocks} () const 
\item 
const std\+::vector$<$ {\bf Index\+Set} $>$ \hyperlink{class_assembly_helper_a1d0898b738b49d1ed38448d5686e19ba}{get\+\_\+locally\+\_\+owned\+\_\+indices\+\_\+blocks} () const 
\item 
unsigned int \hyperlink{class_assembly_helper_a53c369b25d3a595229a9834950200da7}{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+omega} (const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim, spacedim $>$ $\ast$\hyperlink{class_assembly_helper_a1952a054a839a7a683ca108013e7d976}{u\+\_\+omega}, const unsigned int component, const {\bf Point}$<$ spacedim $>$ p) const 
\item 
unsigned int \hyperlink{class_assembly_helper_a8c3efbac750aa236f8b116af994c07ee}{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+sigma} (const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim-\/1, spacedim $>$ $\ast$\hyperlink{class_assembly_helper_a696fe649b3503561235aa1ccbf2ddeef}{u\+\_\+sigma}, const unsigned int component, const {\bf Point}$<$ spacedim $>$ p) const 
\item 
void \hyperlink{class_assembly_helper_a532f565a8725675fcca12c1f8c669a44}{print\+\_\+dof\+\_\+information} (const unsigned int dof\+\_\+index) const 
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Private Member Functions}
\begin{Indent}{\bf Member functions used during construction of an Assembly\+Helper object}\par
{\em These functions are essentially introduced to clean up tthe constructor of the class a bit. They are only used during construction of an \hyperlink{class_assembly_helper}{Assembly\+Helper} object. }\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_assembly_helper_aad21ced11a2d90c804827854c18f7f89}{convert\+\_\+dependent\+\_\+fields\+\_\+to\+\_\+shapefunctions} ()
\item 
void \hyperlink{class_assembly_helper_a1cd5d35b136347876aa13b89749338a0}{initialize\+\_\+hidden\+\_\+variables} () const 
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Member functions related to assembly of the finite element system}\par
{\em These functions are all needed during assembly of the finite element system. }\begin{DoxyCompactItemize}
\item 
void \hyperlink{class_assembly_helper_a953859cc4cd745a1b51fdec5418be682}{distribute\+\_\+dofs} ()
\item 
void \hyperlink{class_assembly_helper_ab4c51b059d53f0086ebce3b60d4d2400}{initialize\+\_\+fe\+\_\+values\+\_\+domain} (const typename {\bf hp\+::\+Do\+F\+Handler}$<$ spacedim, spacedim $>$\+::{\bf active\+\_\+cell\+\_\+iterator} \&cell, const unsigned int internal\+\_\+index, const bool nonprimitive=false) const 
\item 
void \hyperlink{class_assembly_helper_a07b7b359ed67e0f949aa8817853ad0c2}{initialize\+\_\+fe\+\_\+values\+\_\+interface} (const \hyperlink{class_interface_cell_domain_cells_do_f}{Interface\+Cell\+Domain\+Cells\+DoF}$<$ spacedim $>$ \&interface\+\_\+cell\+\_\+domain\+\_\+cells, const unsigned int internal\+\_\+index, const bool nonprimitive=false) const 
\item 
void \hyperlink{class_assembly_helper_a78e22b83e1effe9b40d26ed150bebc7f}{compute\+\_\+e\+\_\+omega} (const unsigned int internal\+\_\+index, const unsigned int scalar\+\_\+functional\+\_\+index, const unsigned int q\+\_\+point, const {\bf Vector}$<$ double $>$ \&solution\+\_\+u\+\_\+omega, const {\bf Vector}$<$ double $>$ \&solution\+\_\+C, {\bf Vector}$<$ double $>$ \&e\+\_\+omega, {\bf Full\+Matrix}$<$ double $>$ \&de\+\_\+omega\+\_\+dsol\+\_\+T, const bool compute\+\_\+derivative=true, const bool ignore\+\_\+constants=false) const 
\item 
void \hyperlink{class_assembly_helper_a17cff5d9e32bd2ceac43d9218edd0b9b}{compute\+\_\+e\+\_\+sigma} (const unsigned int internal\+\_\+index, const unsigned int scalar\+\_\+functional\+\_\+index, const unsigned int q\+\_\+point, const {\bf Vector}$<$ double $>$ \&solution\+\_\+u\+\_\+sigma, const {\bf Vector}$<$ double $>$ \&solution\+\_\+u\+\_\+omega\+\_\+minus, const {\bf Vector}$<$ double $>$ \&solution\+\_\+u\+\_\+omega\+\_\+plus, const {\bf Vector}$<$ double $>$ \&solution\+\_\+C, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+interface\+\_\+dof\+\_\+indices\+\_\+combined, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+minus\+\_\+dof\+\_\+indices\+\_\+combined, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+plus\+\_\+dof\+\_\+indices\+\_\+combined, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+\+C\+\_\+dof\+\_\+indices\+\_\+combined, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+global\+\_\+combined, {\bf Vector}$<$ double $>$ \&e\+\_\+sigma, {\bf Full\+Matrix}$<$ double $>$ \&de\+\_\+sigma\+\_\+dsol\+\_\+T, const bool compute\+\_\+derivative=true, const bool ignore\+\_\+constants=false) const 
\item 
{\footnotesize template$<$class Vector\+Type $>$ }\\bool \hyperlink{class_assembly_helper_a5ab3659137ee74754cc27d9c18e1f9db}{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values} (const {\bf Vector\+Type} \&solution, const std\+::vector$<$ const {\bf Vector\+Type} $\ast$ $>$ solution\+\_\+ref\+\_\+sets, {\bf Vector}$<$ double $>$ \&nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values) const 
\item 
std\+::pair$<$ const int, const int $>$ \hyperlink{class_assembly_helper_aad795811df548677cb883341f6c52001}{get\+\_\+scalar\+\_\+functional\+\_\+indices} (const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim, spacedim $>$ $\ast$scalar\+\_\+functional) const 
\item 
std\+::pair$<$ const int, const int $>$ \hyperlink{class_assembly_helper_ae5791ac73405d479df790815abc06380}{get\+\_\+scalar\+\_\+functional\+\_\+indices} (const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim-\/1, spacedim $>$ $\ast$scalar\+\_\+functional) const 
\item 
void \hyperlink{class_assembly_helper_a4cc746ddb7917fa0e9f7cdda05345b94}{get\+\_\+dof\+\_\+indices\+\_\+C} (std\+::vector$<$ unsigned int $>$ \&global\+\_\+dof\+\_\+indices\+\_\+C) const 
\item 
void \hyperlink{class_assembly_helper_a5c4d81be4c30b8a40761ac5710734576}{make\+\_\+dirichlet\+\_\+constraints\+\_\+recursion} (const typename \hyperlink{class_triangulation_system}{Triangulation\+System}$<$ spacedim $>$\+::Domain\+Cell \&domain\+\_\+cell, const unsigned int face, const std\+::vector$<$ unsigned int $>$ \&shapefuns, const \hyperlink{class_dirichlet_constraint}{Dirichlet\+Constraint}$<$ spacedim $>$ \&constraint, Affine\+Constraints$<$ double $>$ \&constraint\+\_\+matrix, const Affine\+Constraints$<$ double $>$ \&constraints\+\_\+ignore) const 
\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Private Attributes}
\begin{Indent}{\bf Problem definition}\par
{\em These members define the problem to be solved. }\begin{DoxyCompactItemize}
\item 
const \hyperlink{class_total_potential}{Total\+Potential}$<$ spacedim $>$ \hyperlink{class_assembly_helper_a748eed9d73b7437a4bf2dcd73108790b}{total\+\_\+potential}
\item 
\hyperlink{class_triangulation_system}{Triangulation\+System}$<$ spacedim $>$ \& \hyperlink{class_assembly_helper_add08a8a7bb9c9325fcc7d92bfce525d4}{tria\+\_\+system}
\item 
const {\bf Smart\+Pointer}$<$ const {\bf Mapping}$<$ spacedim, spacedim $>$ $>$ \hyperlink{class_assembly_helper_a3fbb49461000dea8f64266f830709fad}{mapping\+\_\+domain}
\item 
const {\bf Smart\+Pointer}$<$ const {\bf Mapping}$<$ spacedim-\/1, spacedim $>$ $>$ \hyperlink{class_assembly_helper_a055fde6217c18e62cd80188d0130c201}{mapping\+\_\+interface}
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Domain and interface portion indexing}\par
{\em These members define consecutive indices for domain and interface portions for internal use. }\begin{DoxyCompactItemize}
\item 
std\+::map$<$ {\bf types\+::material\+\_\+id}, const unsigned int $>$ \hyperlink{class_assembly_helper_a10b3acf64bccc169ee14dc2505ce4b46}{material\+\_\+id\+\_\+to\+\_\+internal\+\_\+index\+\_\+domain}
\item 
std\+::map$<$ std\+::tuple$<$ const {\bf types\+::material\+\_\+id}, const {\bf types\+::material\+\_\+id}, const {\bf types\+::material\+\_\+id} $>$, const unsigned int $>$ \hyperlink{class_assembly_helper_a43b82de0ede96d03b9f7fd8740d81668}{material\+\_\+ids\+\_\+to\+\_\+internal\+\_\+index\+\_\+interface}
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Finite elements and dof handling}\par
{\em These members comprise the finite elements to be used on the respective domain and interface portions as well as the \hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System} (which contains all dof information). }\begin{DoxyCompactItemize}
\item 
{\bf hp\+::\+F\+E\+Collection}$<$ spacedim, spacedim $>$ \hyperlink{class_assembly_helper_af3803b0aad9853e6bf018c70be41e791}{fe\+\_\+collection\+\_\+domain}
\item 
{\bf hp\+::\+F\+E\+Collection}$<$ spacedim-\/1, spacedim $>$ \hyperlink{class_assembly_helper_a8b4d224a9ecd2e926a8860829874d2a1}{fe\+\_\+collection\+\_\+interface}
\item 
std\+::map$<$ {\bf types\+::material\+\_\+id}, unsigned int $>$ \hyperlink{class_assembly_helper_a3045f80801fc31920efd161a268aae8e}{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+domain}
\item 
std\+::map$<$ {\bf types\+::material\+\_\+id}, unsigned int $>$ \hyperlink{class_assembly_helper_a5fea54137e3c1c5a514e39c9b2ad7926}{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+interface}
\item 
\hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System}$<$ spacedim $>$ \hyperlink{class_assembly_helper_a885e660c749e91a35e3279643ebcd87f}{dof\+\_\+handler\+\_\+system}
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Members re-\/organizing Assembly\+Helper\+:\+:total\+\_\+potential}\par
{\em These members re-\/organize the information provided by \hyperlink{class_assembly_helper_a748eed9d73b7437a4bf2dcd73108790b}{Assembly\+Helper\+::total\+\_\+potential} in a way suitable for efficient assembly of the finite element system. }\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim, spacedim $>$ $>$ $>$ \hyperlink{class_assembly_helper_a1952a054a839a7a683ca108013e7d976}{u\+\_\+omega}
\item 
std\+::vector$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim-\/1, spacedim $>$ $>$ $>$ \hyperlink{class_assembly_helper_a696fe649b3503561235aa1ccbf2ddeef}{u\+\_\+sigma}
\item 
std\+::vector$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ 0, spacedim $>$ $>$ $>$ \hyperlink{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}{C}
\item 
std\+::map$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim, spacedim $>$ $>$, const unsigned int $>$ \hyperlink{class_assembly_helper_a6dae4b6ae7934eaec1ad7baff258ce6e}{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+omega}
\item 
std\+::map$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ spacedim-\/1, spacedim $>$ $>$, const unsigned int $>$ \hyperlink{class_assembly_helper_a992a53a1fcac8a393ca53fb8d504bdfe}{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+sigma}
\item 
std\+::map$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_independent_field}{Independent\+Field}$<$ 0, spacedim $>$ $>$, const unsigned int $>$ \hyperlink{class_assembly_helper_a9a8f0e8ea8c67ce9429c16a2017cafdc}{global\+\_\+indices\+\_\+C}
\item 
std\+::vector$<$ std\+::vector$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim, spacedim $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_aa6fa619e4c2582e95950e878cd06628e}{scalar\+\_\+functionals\+\_\+domain}
\item 
std\+::vector$<$ std\+::vector$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim-\/1, spacedim $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}{scalar\+\_\+functionals\+\_\+interface}
\item 
std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ \hyperlink{class_assembly_helper_a5fe78a019aec03cbeeb336d1d2874729}{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive}
\item 
std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ \hyperlink{class_assembly_helper_a833383aa6d157157545204143897ed9e}{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive}
\item 
std\+::map$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim, spacedim $>$ $>$, const unsigned int $>$ \hyperlink{class_assembly_helper_acf05fab2ddf57769a103d82a4f2d1cd3}{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices}
\item 
std\+::map$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim-\/1, spacedim $>$ $>$, const unsigned int $>$ \hyperlink{class_assembly_helper_a0d15b3ab0c7bec9fc4f40e532f8776f4}{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices}
\item 
std\+::map$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim, spacedim $>$ $>$, const unsigned int $>$ \hyperlink{class_assembly_helper_a4f08790a2235e48ce19f5d8d965a7874}{scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices}
\item 
std\+::map$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim-\/1, spacedim $>$ $>$, const unsigned int $>$ \hyperlink{class_assembly_helper_ad99c75f32cf3f18aa1d4067ad8b56ae8}{scalar\+\_\+functionals\+\_\+interface\+\_\+primitive\+\_\+indices}
\item 
std\+::map$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim, spacedim $>$ $>$, std\+::vector$<$ std\+::pair$<$ const unsigned int, const unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_aceaf7ba62dfe0fa06ecb15ee8c14da34}{contributions\+\_\+scalar\+\_\+functionals\+\_\+domain\+\_\+total\+\_\+potential}
\item 
std\+::map$<$ {\bf Smart\+Pointer}$<$ const \hyperlink{class_scalar_functional}{Scalar\+Functional}$<$ spacedim-\/1, spacedim $>$ $>$, std\+::vector$<$ std\+::pair$<$ const unsigned int, const unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_a9e76874224ab4946218fdce9bdba0e03}{contributions\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+total\+\_\+potential}
\item 
unsigned int \hyperlink{class_assembly_helper_af7bcfc1db651535a7aefc6071a81e124}{n\+\_\+scalar\+\_\+functionals\+\_\+nonprimitive}
\item 
unsigned int \hyperlink{class_assembly_helper_af5e03e8e47a85dbc96444ef61525c454}{n\+\_\+scalar\+\_\+functionals\+\_\+primitive}
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Members providing information about shape function indexing, etc.}\par
{\em These data structures are organized in a way that shape function related information needed again and again for the functionalities provided by \hyperlink{class_assembly_helper}{Assembly\+Helper} (in particular assembly of the finite element system) can be retrieved efficiently. }\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_a0bdb6e2e2f9623f3f10dfa2ebe8e234c}{components\+\_\+to\+\_\+shapefuns\+\_\+domain}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_abcad51e64347fc3141d2840a2835b46c}{components\+\_\+to\+\_\+shapefuns\+\_\+interface}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_ae92560183f1d2060265f0744a84f0349}{components\+\_\+to\+\_\+shapefuns\+\_\+domain\+\_\+facewise}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_ab346e146cf91fb7a0688076551b37355}{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_a12299d82365553a21fef8529c8fe8a17}{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+minus}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_af07bb528fdd350e9b467b08dc44a03e7}{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+plus}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_a0edd25820c92a25ae87fc240f4916804}{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ unsigned int $>$ $>$ $>$ \hyperlink{class_assembly_helper_a311e176038ee2b7ca0719abb384ca57b}{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, const unsigned int, std\+::vector$<$ unsigned int $>$ $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a13fef9096e5fc7b1e922ea78d7aa2c28}{a\+\_\+omega}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, const unsigned int, const unsigned int, std\+::vector$<$ unsigned int $>$ $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}{b\+\_\+omega}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, unsigned int $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a75e6f76c0b12b91c5feb230251f0137f}{c\+\_\+omega}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ double $>$ $>$ $>$ \hyperlink{class_assembly_helper_ad93b109608d4425d318434e01cb6246c}{d\+\_\+omega}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, const unsigned int, std\+::vector$<$ unsigned int $>$ $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_aa266cc07e9670319481da52d633d2583}{a\+\_\+sigma}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, const unsigned int, const unsigned int, std\+::vector$<$ unsigned int $>$ $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}{b\+\_\+sigma}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, const unsigned int, std\+::vector$<$ unsigned int $>$ $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a4461be378c9be0364ca23153c367d24c}{a\+\_\+minus}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, const unsigned int, const unsigned int, std\+::vector$<$ unsigned int $>$ $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}{b\+\_\+minus}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, const unsigned int, std\+::vector$<$ unsigned int $>$ $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a8eb513a6239d94cc0f1a6a01a037c572}{a\+\_\+plus}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, const unsigned int, const unsigned int, std\+::vector$<$ unsigned int $>$ $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}{b\+\_\+plus}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$ const double, unsigned int $>$ $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_ab3d4370661ba726010ee687ef0e98140}{c\+\_\+sigma}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ double $>$ $>$ $>$ \hyperlink{class_assembly_helper_a48d7d677120eb1c84b4983f470246e02}{d\+\_\+sigma}
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Members containing the F\+E\+Values, F\+E\+Face\+Values, and F\+E\+Subface\+Values objects needed during assembly}\par
{\em These data structures make sure that the {\bf F\+E\+Values}, {\bf F\+E\+Face\+Values}, and {\bf F\+E\+Subface\+Values} objects are re-\/used wherever possible and that only those objects are reinitialized for which this is really necessary when a new cell is visited. }\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::shared\+\_\+ptr$<$ {\bf F\+E\+Values}$<$ spacedim, spacedim $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a904a24f53b66e1c1ef89f1bb7989eb32}{fe\+\_\+values\+\_\+domain}
\item 
std\+::vector$<$ std\+::vector$<$ std\+::shared\+\_\+ptr$<$ \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface}$<$ spacedim $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_ae1e2643696005415d78421882ca80e8e}{fe\+\_\+values\+\_\+interface}
\item 
std\+::vector$<$ std\+::set$<$ std\+::shared\+\_\+ptr$<$ {\bf F\+E\+Values}$<$ spacedim, spacedim $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a28b58551c6afc68c7beaaa2604bc6e92}{fe\+\_\+values\+\_\+domain\+\_\+reinit}
\item 
std\+::vector$<$ std\+::set$<$ std\+::shared\+\_\+ptr$<$ \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface}$<$ spacedim $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_ac9789c5a00867744dd906b85580e3091}{fe\+\_\+values\+\_\+interface\+\_\+reinit}
\item 
std\+::vector$<$ std\+::set$<$ std\+::shared\+\_\+ptr$<$ {\bf F\+E\+Values}$<$ spacedim, spacedim $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_a3c592ef0a148753891cc3e03fd08324c}{fe\+\_\+values\+\_\+domain\+\_\+reinit\+\_\+nonprimitive}
\item 
std\+::vector$<$ std\+::set$<$ std\+::shared\+\_\+ptr$<$ \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface}$<$ spacedim $>$ $>$ $>$ $>$ \hyperlink{class_assembly_helper_afaa20027ee539ca8d9c40c317127e471}{fe\+\_\+values\+\_\+interface\+\_\+reinit\+\_\+nonprimitive}
\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Miscellaneous members}\par
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ std\+::pair$<$ std\+::string, unsigned int $>$ $>$ \hyperlink{class_assembly_helper_af5e29448f133863a1859be8bfbb300c6}{component\+\_\+names\+\_\+domain}
\item 
std\+::vector$<$ std\+::pair$<$ std\+::string, unsigned int $>$ $>$ \hyperlink{class_assembly_helper_a7ae6ae2ec356cbb7b830d968315d280c}{component\+\_\+names\+\_\+interface}
\item 
std\+::vector$<$ boost\+::signals2\+::connection $>$ \hyperlink{class_assembly_helper_a228cec028ab5126d25c3ebf0e12a17a6}{tria\+\_\+listeners}
\item 
const unsigned int \hyperlink{class_assembly_helper_a2aad83ae1bfe5338794cf9b50848469a}{this\+\_\+proc}
\item 
const unsigned int \hyperlink{class_assembly_helper_a87945d87baf37637673fd124b3803fd5}{n\+\_\+procs}
\item 
{\bf Conditional\+O\+Stream} \hyperlink{class_assembly_helper_a717eb6ebc7c62fe00063edcf264f3ecc}{pout}
\end{DoxyCompactItemize}
\end{Indent}


\subsection{Detailed Description}
\subsubsection*{template$<$unsigned int spacedim$>$\\*
class Assembly\+Helper$<$ spacedim $>$}

The \hyperlink{class_assembly_helper}{Assembly\+Helper} class puts it all together and provides with methods for assembly of the finite element system.

Essentially, an \hyperlink{class_assembly_helper}{Assembly\+Helper} object is a combination of a \hyperlink{class_triangulation_system}{Triangulation\+System} object (which includes the definition of the domain portions and interface portions), a \hyperlink{class_total_potential}{Total\+Potential} object, a corresponding \hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System} object, and mapping objects defining the mapping to be used on the domain and on the interface.

Large part of the class rearranges the data involved in the problem definition in a way which is suitable for efficient assembly.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000001}{Todo}]It might be worthwhile to allow for the usage of different mappings on different domain and interface portions.\end{DoxyRefDesc}


\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000002}{Todo}]Routines for treatment of DG terms should be implemented.\end{DoxyRefDesc}



\begin{DoxyTemplParams}{Template Parameters}
{\em spacedim} & spatial dimension \\
\hline
\end{DoxyTemplParams}


\subsection{Constructor \& Destructor Documentation}
\index{Assembly\+Helper@{Assembly\+Helper}!Assembly\+Helper@{Assembly\+Helper}}
\index{Assembly\+Helper@{Assembly\+Helper}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{Assembly\+Helper(const Total\+Potential$<$ spacedim $>$ \&total\+\_\+potential, Triangulation\+System$<$ spacedim $>$ \&tria\+\_\+system, const Mapping$<$ spacedim, spacedim $>$ \&mapping\+\_\+domain, const Mapping$<$ spacedim-\/1, spacedim $>$ \&mapping\+\_\+interface, const std\+::set$<$ const Independent\+Field$<$ 0, spacedim $>$ $\ast$ $>$ \&independent\+\_\+scalars=std\+::set$<$ const Independent\+Field$<$ 0, spacedim $>$ $\ast$ $>$())}{AssemblyHelper(const TotalPotential< spacedim > &total_potential, TriangulationSystem< spacedim > &tria_system, const Mapping< spacedim, spacedim > &mapping_domain, const Mapping< spacedim-1, spacedim > &mapping_interface, const std::set< const IndependentField< 0, spacedim > * > &independent_scalars=std::set< const IndependentField< 0, spacedim > * >())}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::{\bf Assembly\+Helper} (
\begin{DoxyParamCaption}
\item[{const {\bf Total\+Potential}$<$ spacedim $>$ \&}]{total\+\_\+potential, }
\item[{{\bf Triangulation\+System}$<$ spacedim $>$ \&}]{tria\+\_\+system, }
\item[{const {\bf Mapping}$<$ spacedim, spacedim $>$ \&}]{mapping\+\_\+domain, }
\item[{const {\bf Mapping}$<$ spacedim-\/1, spacedim $>$ \&}]{mapping\+\_\+interface, }
\item[{const std\+::set$<$ const {\bf Independent\+Field}$<$ 0, spacedim $>$ $\ast$ $>$ \&}]{independent\+\_\+scalars = {\ttfamily std\+:\+:set$<$~const~{\bf Independent\+Field}$<$~0,~spacedim~$>$~$\ast$~$>$()}}
\end{DoxyParamCaption}
)}\hypertarget{class_assembly_helper_ae164448dcc5e9e8d2849c354212d6df5}{}\label{class_assembly_helper_ae164448dcc5e9e8d2849c354212d6df5}
The constructor of the class.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em total\+\_\+potential} & \hyperlink{class_assembly_helper_a748eed9d73b7437a4bf2dcd73108790b}{Assembly\+Helper\+::total\+\_\+potential} (note\+: the total potential is copied over by the constructor; but as it contains pointers to the \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution} objects, changing the latter or the associated \hyperlink{class_scalar_functional}{Scalar\+Functional} objects will affect the total potential)\\
\hline
\mbox{\tt in}  & {\em tria\+\_\+system} & \hyperlink{class_assembly_helper_add08a8a7bb9c9325fcc7d92bfce525d4}{Assembly\+Helper\+::tria\+\_\+system}\\
\hline
\mbox{\tt in}  & {\em mapping\+\_\+domain} & \hyperlink{class_assembly_helper_a3fbb49461000dea8f64266f830709fad}{Assembly\+Helper\+::mapping\+\_\+domain}\\
\hline
\mbox{\tt in}  & {\em mapping\+\_\+interface} & \hyperlink{class_assembly_helper_a055fde6217c18e62cd80188d0130c201}{Assembly\+Helper\+::mapping\+\_\+interface}\\
\hline
\mbox{\tt in}  & {\em independent\+\_\+scalars} & Additional independent scalars to be included into the finite element system which are not appearing in the total potential (this may e.\+g. be constants appearing only in constraints) \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!````~Assembly\+Helper@{$\sim$\+Assembly\+Helper}}
\index{````~Assembly\+Helper@{$\sim$\+Assembly\+Helper}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{$\sim$\+Assembly\+Helper()}{~AssemblyHelper()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::$\sim${\bf Assembly\+Helper} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_assembly_helper_ac82eca7b04aedf772028c6ff77245e9b}{}\label{class_assembly_helper_ac82eca7b04aedf772028c6ff77245e9b}
Destructor. The main task of the destructor is to release the memory allocated for hidden variables. 

\subsection{Member Function Documentation}
\index{Assembly\+Helper@{Assembly\+Helper}!assemble\+\_\+system@{assemble\+\_\+system}}
\index{assemble\+\_\+system@{assemble\+\_\+system}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{assemble\+\_\+system(const Solution\+Vector\+Type \&solution, const std\+::vector$<$ const Solution\+Vector\+Type $\ast$ $>$ solution\+\_\+ref\+\_\+sets, const Affine\+Constraints$<$ double $>$ \&constraints, double \&potential\+\_\+value, R\+H\+S\+Vector\+Type \&f, Matrix\+Type \&\+K, const std\+::tuple$<$ bool, bool, bool $>$ requested\+\_\+quantities=std\+::make\+\_\+tuple(true, true, true)) const }{assemble_system(const SolutionVectorType &solution, const std::vector< const SolutionVectorType * > solution_ref_sets, const AffineConstraints< double > &constraints, double &potential_value, RHSVectorType &f, MatrixType &K, const std::tuple< bool, bool, bool > requested_quantities=std::make_tuple(true, true, true)) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Solution\+Vector\+Type , class R\+H\+S\+Vector\+Type , class Matrix\+Type $>$ bool {\bf Assembly\+Helper}$<$ spacedim $>$\+::assemble\+\_\+system (
\begin{DoxyParamCaption}
\item[{const Solution\+Vector\+Type \&}]{solution, }
\item[{const std\+::vector$<$ const Solution\+Vector\+Type $\ast$ $>$}]{solution\+\_\+ref\+\_\+sets, }
\item[{const Affine\+Constraints$<$ double $>$ \&}]{constraints, }
\item[{double \&}]{potential\+\_\+value, }
\item[{R\+H\+S\+Vector\+Type \&}]{f, }
\item[{Matrix\+Type \&}]{K, }
\item[{const std\+::tuple$<$ bool, bool, bool $>$}]{requested\+\_\+quantities = {\ttfamily std\+:\+:make\+\_\+tuple(true,~true,~true)}}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a9d2f3d1152046e639acfa6f6ac317b37}{}\label{class_assembly_helper_a9d2f3d1152046e639acfa6f6ac317b37}
This method performs the actual assembly of the following (stretched) finite element system\+: \begin{equation*} \boldsymbol{K}^\mathrm{s} \Delta \boldsymbol{\hat u}^\mathrm{s} = -\boldsymbol{f}^\mathrm{s} \end{equation*}

For further information about this finite element system, see the accompanying pdf file \href{../notes/galerkin_tools.pdf}{\tt galerkin\+\_\+tools.\+pdf}. Note that during assembly constraints are directly incorporated into the system.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em solution} & Point of linearization $\boldsymbol{\hat u}^\mathrm{s} = \begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$, where the values of $\boldsymbol{\hat \lambda}$ are not used during assembly and are, therefore, arbitrary. The appropriate size of {\ttfamily solution} can be obtained from \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{Assembly\+Helper\+::system\+\_\+size()}.\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+ref\+\_\+sets} & Sets of reference solution vectors, which can e.\+g. be the solution vectors of previous times steps. Make sure that you pass at least as many reference sets here as are required by the \hyperlink{class_scalar_functional}{Scalar\+Functional} objects (see \hyperlink{class_scalar_functional_a1b9874b2fd591c844ecfcd1db8212c54}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()} and \hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}) and the \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution} objects (see \hyperlink{class_total_potential_contribution_a0d281fceeb90ece5c4d2655df5eb9948}{Total\+Potential\+Contribution\+::get\+\_\+potential\+\_\+contribution()}) to complete their computations. In general, the order of the sets of reference values in \hyperlink{class_scalar_functional_a1b9874b2fd591c844ecfcd1db8212c54}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()}, \hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}, and \hyperlink{class_total_potential_contribution_a0d281fceeb90ece5c4d2655df5eb9948}{Total\+Potential\+Contribution\+::get\+\_\+potential\+\_\+contribution()} corresponds to the order in {\ttfamily solution\+\_\+ref\+\_\+sets}. If e.\+g. a function \hyperlink{class_scalar_functional_a1b9874b2fd591c844ecfcd1db8212c54}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()} requires two reference sets of dependent variable values while {\ttfamily solution\+\_\+ref\+\_\+sets} contains more than two reference sets of dof values, the first two sets from {\ttfamily solution\+\_\+ref\+\_\+sets} will be used to obtain the reference sets of dependent variable values.\\
\hline
\mbox{\tt in}  & {\em constraints} & Constraints to be applied to the finite element system. These must be the same as those used for generating the sparsity pattern for {\ttfamily system\+\_\+matrix} with \hyperlink{class_assembly_helper_af45c789076262ceb24613c04427b654e}{Assembly\+Helper\+::generate\+\_\+sparsity\+\_\+pattern\+\_\+by\+\_\+simulation()}.\\
\hline
\mbox{\tt out}  & {\em potential\+\_\+value} & Value of the total potential (the correct calculation of the total potential value of course requires that all \hyperlink{class_scalar_functional_a1b9874b2fd591c844ecfcd1db8212c54}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()}, \hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()} and \hyperlink{class_total_potential_contribution_a0d281fceeb90ece5c4d2655df5eb9948}{Total\+Potential\+Contribution\+::get\+\_\+potential\+\_\+contribution()} functions compute the respective values and not only compute the derivatives.\\
\hline
\mbox{\tt out}  & {\em f} & The right hand side of the (stretched) finite element system $-\boldsymbol{f}^\mathrm{s}$ with {\ttfamily constraints} incorporated. This vector must be passed in with the correct size, which can be obtained from \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{Assembly\+Helper\+::system\+\_\+size()}.\\
\hline
\mbox{\tt out}  & {\em K} & The (stretched) system matrix $\boldsymbol{K}^\mathrm{s}$ with {\ttfamily constraints} incorporated. The matrix must be passed in with the correct size, which can be obtained from \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{Assembly\+Helper\+::system\+\_\+size()}, and the appropriate sparsity pattern generated by \hyperlink{class_assembly_helper_af45c789076262ceb24613c04427b654e}{Assembly\+Helper\+::generate\+\_\+sparsity\+\_\+pattern\+\_\+by\+\_\+simulation()} using {\ttfamily constraints}.\\
\hline
\mbox{\tt in}  & {\em requested\+\_\+quantities} & Tuple indicating which quantities are actually to be computed (e.\+g. ({\ttfamily true}, {\ttfamily false}, {\ttfamily true}) indicates that {\ttfamily potential\+\_\+value} and {\ttfamily K} are to be computed)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily false} if the assembly process was successful, and {\ttfamily true} if an error prevented proper assembly
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Note that the finite element system returned will not ensure that the constrained dofs have the correct values after the solution of the finite element system I.\+e., after solution, the values of the constrained dofs must be computed from the unconstrained dofs using distribute\+\_\+solution().
\end{DoxyNote}

\begin{DoxyTemplParams}{Template Parameters}
{\em Solution\+Vector\+Type} & The type used for {\ttfamily solution} and {\ttfamily solution\+\_\+ref\+\_\+sets} (in parallel this vector type must permit read access to ghosted entries while write access is not required)\\
\hline
{\em R\+H\+S\+Vector\+Type} & The type used for {\ttfamily f} (in parallel this vector type must permit write access to ghosted entries while read access is not required)\\
\hline
{\em Matrix\+Type} & The type used for {\ttfamily K} \\
\hline
\end{DoxyTemplParams}
\index{Assembly\+Helper@{Assembly\+Helper}!compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives@{compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives}}
\index{compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives@{compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives(const Vector\+Type \&solution, const std\+::vector$<$ const Vector\+Type $\ast$ $>$ solution\+\_\+ref\+\_\+sets, const std\+::string detailed\+\_\+printout\+\_\+file="""", const double epsilon=1e-\/8) const }{compare_derivatives_with_numerical_derivatives(const VectorType &solution, const std::vector< const VectorType * > solution_ref_sets, const std::string detailed_printout_file="", const double epsilon=1e-8) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Vector\+Type $>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives (
\begin{DoxyParamCaption}
\item[{const {\bf Vector\+Type} \&}]{solution, }
\item[{const std\+::vector$<$ const {\bf Vector\+Type} $\ast$ $>$}]{solution\+\_\+ref\+\_\+sets, }
\item[{const std\+::string}]{detailed\+\_\+printout\+\_\+file = {\ttfamily \char`\"{}\char`\"{}}, }
\item[{const double}]{epsilon = {\ttfamily 1e-\/8}}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_ac87490e0d3d84b11e2f7187f8706dab6}{}\label{class_assembly_helper_ac87490e0d3d84b11e2f7187f8706dab6}
This method compares the finite element system obtained with \hyperlink{class_assembly_helper_a9d2f3d1152046e639acfa6f6ac317b37}{Assembly\+Helper\+::assemble\+\_\+system()} with numerically computed equivalents.

The numerically computed right hand side is based on a finite difference quotient of the total potential, and the numerically computed system matrix is based on a finite difference quotient of the right hand side of the finite element system. I.\+e., the numerically computed right hand side can only be \char`\"{}correct\char`\"{} (to within the accuracy of the finite difference approach) if the total potential is correctly implemented; and the numerically computed system matrix can only be \char`\"{}correct\char`\"{} (to within the accuracy of the finite difference approach) if the right hand side is correctly implemented. This fact can be used to check the implementation, which is the main purpose of this method.

For comparison of the finite element systems, the dense system $\left( \boldsymbol{K} + \boldsymbol{L} \boldsymbol{\Pi} \boldsymbol{L}^\top \right) \Delta\boldsymbol{\hat u} = - \boldsymbol{f}$ is used instead of the stretched system provided by \hyperlink{class_assembly_helper_a9d2f3d1152046e639acfa6f6ac317b37}{Assembly\+Helper\+::assemble\+\_\+system()}. This, however, means that this method is dealing internally with dense matrices. As a consequence, the method can only be used for very small test problems.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000005}{Todo}]Presently, the method does not allow to take into account any constraints. This should be incorporated in future releases of the library.\end{DoxyRefDesc}



\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em solution} & Point of linearization $\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$, where the values of $\boldsymbol{\hat \lambda}$ are not used and are, therefore, arbitrary. The appropriate size of {\ttfamily solution} can be obtained from \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{Assembly\+Helper\+::system\+\_\+size()}.\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+ref\+\_\+sets} & Sets of reference solution vectors, which can e.\+g. be the solution vectors of previous times steps. Make sure that you pass at least as many reference sets here as are required by the \hyperlink{class_scalar_functional}{Scalar\+Functional} objects (see \hyperlink{class_scalar_functional_a1b9874b2fd591c844ecfcd1db8212c54}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()} and \hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}) and the \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution} objects (see \hyperlink{class_total_potential_contribution_a0d281fceeb90ece5c4d2655df5eb9948}{Total\+Potential\+Contribution\+::get\+\_\+potential\+\_\+contribution()}) to complete their computations. In general, the order of the sets of reference values in \hyperlink{class_scalar_functional_a1b9874b2fd591c844ecfcd1db8212c54}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()}, \hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}, and \hyperlink{class_total_potential_contribution_a0d281fceeb90ece5c4d2655df5eb9948}{Total\+Potential\+Contribution\+::get\+\_\+potential\+\_\+contribution()} corresponds to the order in {\ttfamily solution\+\_\+ref\+\_\+sets}. If e.\+g. a function \hyperlink{class_scalar_functional_a1b9874b2fd591c844ecfcd1db8212c54}{Scalar\+Functional\+::get\+\_\+h\+\_\+sigma()} requires two reference sets of dependent variable values while {\ttfamily solution\+\_\+ref\+\_\+sets} contains more than two reference sets of dof values, the first two sets from {\ttfamily solution\+\_\+ref\+\_\+sets} will be used to obtain the reference sets of dependent variable values.\\
\hline
\mbox{\tt in}  & {\em detailed\+\_\+printout\+\_\+file} & A file to which detailed printout is written (if no file name is provided, the results of the comparison will just be written to screen)\\
\hline
\mbox{\tt in}  & {\em epsilon} & Step width for finite difference computation \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution@{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution}}
\index{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution@{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution(const Vector\+Type \&solution, const Function$<$ spacedim $>$ \&exact\+\_\+solution\+\_\+domain, const Function$<$ spacedim $>$ \&exact\+\_\+solution\+\_\+interface, const Quadrature$<$ spacedim $>$ quadrature\+\_\+domain, const Quadrature$<$ spacedim-\/1 $>$ quadrature\+\_\+interface, const Vector\+Tools\+::\+Norm\+Type norm\+\_\+type=\+Vector\+Tools\+::\+Norm\+Type\+::\+L2\+\_\+norm, const Component\+Mask component\+\_\+mask\+\_\+domain=\+Component\+Mask(), const Component\+Mask component\+\_\+mask\+\_\+interface=\+Component\+Mask(), const double exponent=2.\+0) const }{compute_distance_to_exact_solution(const VectorType &solution, const Function< spacedim > &exact_solution_domain, const Function< spacedim > &exact_solution_interface, const Quadrature< spacedim > quadrature_domain, const Quadrature< spacedim-1 > quadrature_interface, const VectorTools::NormType norm_type=VectorTools::NormType::L2_norm, const ComponentMask component_mask_domain=ComponentMask(), const ComponentMask component_mask_interface=ComponentMask(), const double exponent=2.0) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Vector\+Type $>$ std\+::pair$<$const double, const double$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::compute\+\_\+distance\+\_\+to\+\_\+exact\+\_\+solution (
\begin{DoxyParamCaption}
\item[{const {\bf Vector\+Type} \&}]{solution, }
\item[{const {\bf Function}$<$ spacedim $>$ \&}]{exact\+\_\+solution\+\_\+domain, }
\item[{const {\bf Function}$<$ spacedim $>$ \&}]{exact\+\_\+solution\+\_\+interface, }
\item[{const {\bf Quadrature}$<$ spacedim $>$}]{quadrature\+\_\+domain, }
\item[{const {\bf Quadrature}$<$ spacedim-\/1 $>$}]{quadrature\+\_\+interface, }
\item[{const {\bf Vector\+Tools\+::\+Norm\+Type}}]{norm\+\_\+type = {\ttfamily VectorTools\+:\+:NormType\+:\+:L2\+\_\+norm}, }
\item[{const {\bf Component\+Mask}}]{component\+\_\+mask\+\_\+domain = {\ttfamily {\bf Component\+Mask}()}, }
\item[{const {\bf Component\+Mask}}]{component\+\_\+mask\+\_\+interface = {\ttfamily {\bf Component\+Mask}()}, }
\item[{const double}]{exponent = {\ttfamily 2.0}}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_aca82c19b1abbc316d0bc563e04db727c}{}\label{class_assembly_helper_aca82c19b1abbc316d0bc563e04db727c}
Function computing the \char`\"{}distance\char`\"{} of the solution vector {\ttfamily solution} to an exact solution.

The exact and the numerical solution are subtracted and finally the norm of the resulting difference is computed numerically on the mesh of this \hyperlink{class_assembly_helper}{Assembly\+Helper}. This is done for the domain related and the interface related part separately.

Note that the values of the independent scalars are currently not taken into account in this method.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em solution} & The solution $\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$, where the values of $\boldsymbol{\hat \lambda}$ are not used and are, therefore, arbitrary. The appropriate size of {\ttfamily solution} can be obtained from \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{Assembly\+Helper\+::system\+\_\+size()}.\\
\hline
\mbox{\tt in}  & {\em exact\+\_\+solution\+\_\+domain} & Exact solution on domain (use \hyperlink{class_assembly_helper_a396b89981e546af6b9bc0e35634290b3}{Assembly\+Helper\+::get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+indices()} to obtain information about the component indexing)\\
\hline
\mbox{\tt in}  & {\em exact\+\_\+solution\+\_\+interface} & Exact solution on interface (use \hyperlink{class_assembly_helper_aca4d34e08f177e8d075c86bb34906f2f}{Assembly\+Helper\+::get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+indices()} to obtain information about the component indexing)\\
\hline
\mbox{\tt in}  & {\em quadrature\+\_\+domain} & {\bf Quadrature} scheme to be used on the domain for the computation of the norm\\
\hline
\mbox{\tt in}  & {\em quadrature\+\_\+interface} & {\bf Quadrature} scheme to be used on the interface for the computation of the norm\\
\hline
\mbox{\tt in}  & {\em norm\+\_\+type} & Type of the norm\\
\hline
\mbox{\tt in}  & {\em component\+\_\+mask\+\_\+domain} & Domain related solution components to be included in the calculation. If the {\bf Component\+Mask} is empty, all components will be included.\\
\hline
\mbox{\tt in}  & {\em component\+\_\+mask\+\_\+interface} & Interface related solution components to be included in the calculation. If the {\bf Component\+Mask} is empty, all components will be included.\\
\hline
\mbox{\tt in}  & {\em exponent} & Exponent of the norm if required\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of the norm computed on the domain and the interface, respectively 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution@{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution}}
\index{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution@{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution(const Vector\+Type \&solution, const Vector\+Type \&other\+\_\+solution, const Assembly\+Helper$<$ spacedim $>$ \&other\+\_\+assembly\+\_\+helper, const Quadrature$<$ spacedim $>$ quadrature\+\_\+domain, const Quadrature$<$ spacedim-\/1 $>$ quadrature\+\_\+interface, const Vector\+Tools\+::\+Norm\+Type norm\+\_\+type=\+Vector\+Tools\+::\+Norm\+Type\+::\+L2\+\_\+norm, const Component\+Mask component\+\_\+mask\+\_\+domain=\+Component\+Mask(), const Component\+Mask component\+\_\+mask\+\_\+interface=\+Component\+Mask(), const double exponent=2.\+0) const }{compute_distance_to_other_solution(const VectorType &solution, const VectorType &other_solution, const AssemblyHelper< spacedim > &other_assembly_helper, const Quadrature< spacedim > quadrature_domain, const Quadrature< spacedim-1 > quadrature_interface, const VectorTools::NormType norm_type=VectorTools::NormType::L2_norm, const ComponentMask component_mask_domain=ComponentMask(), const ComponentMask component_mask_interface=ComponentMask(), const double exponent=2.0) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Vector\+Type $>$ std\+::pair$<$const double, const double$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::compute\+\_\+distance\+\_\+to\+\_\+other\+\_\+solution (
\begin{DoxyParamCaption}
\item[{const {\bf Vector\+Type} \&}]{solution, }
\item[{const {\bf Vector\+Type} \&}]{other\+\_\+solution, }
\item[{const {\bf Assembly\+Helper}$<$ spacedim $>$ \&}]{other\+\_\+assembly\+\_\+helper, }
\item[{const {\bf Quadrature}$<$ spacedim $>$}]{quadrature\+\_\+domain, }
\item[{const {\bf Quadrature}$<$ spacedim-\/1 $>$}]{quadrature\+\_\+interface, }
\item[{const {\bf Vector\+Tools\+::\+Norm\+Type}}]{norm\+\_\+type = {\ttfamily VectorTools\+:\+:NormType\+:\+:L2\+\_\+norm}, }
\item[{const {\bf Component\+Mask}}]{component\+\_\+mask\+\_\+domain = {\ttfamily {\bf Component\+Mask}()}, }
\item[{const {\bf Component\+Mask}}]{component\+\_\+mask\+\_\+interface = {\ttfamily {\bf Component\+Mask}()}, }
\item[{const double}]{exponent = {\ttfamily 2.0}}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_ac7860831588d35d05009474f2a695e14}{}\label{class_assembly_helper_ac7860831588d35d05009474f2a695e14}
Function computing the \char`\"{}distance\char`\"{} of the solution vector {\ttfamily solution} of this \hyperlink{class_assembly_helper}{Assembly\+Helper} to the solution {\ttfamily other\+\_\+solution} of another \hyperlink{class_assembly_helper}{Assembly\+Helper} object (the Assembly\+Helpers must be the same apart from the mesh refinement, in particular they must be based on the same coarse mesh).

Note that the values of the independent scalars are currently not taken into account in this method.

The solution of the other \hyperlink{class_assembly_helper}{Assembly\+Helper} is interpolated to the mesh of this \hyperlink{class_assembly_helper}{Assembly\+Helper}, then both solutions are subtracted and finally the norm of the resulting difference is computed numerically on the mesh of this \hyperlink{class_assembly_helper}{Assembly\+Helper}. This is done for the domain related and the interface related part separately.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000007}{Todo}]Hanging node constraints are currently not taken care of after interpolation of the solution. Also not all {\bf Vector\+Tools\+::\+Norm\+Type} norms are implemented yet.\end{DoxyRefDesc}



\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em solution} & The solution $\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$, where the values of $\boldsymbol{\hat \lambda}$ are not used and are, therefore, arbitrary. The appropriate size of {\ttfamily solution} can be obtained from \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{Assembly\+Helper\+::system\+\_\+size()}.\\
\hline
\mbox{\tt in}  & {\em other\+\_\+solution} & The solution $\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$ of the other \hyperlink{class_assembly_helper}{Assembly\+Helper}, where the values of $\boldsymbol{\hat \lambda}$ are not used and are, therefore, arbitrary. The appropriate size of {\ttfamily solution} can be obtained from \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{Assembly\+Helper\+::system\+\_\+size()}.\\
\hline
\mbox{\tt in}  & {\em other\+\_\+assembly\+\_\+helper} & The other \hyperlink{class_assembly_helper}{Assembly\+Helper} object\\
\hline
\mbox{\tt in}  & {\em quadrature\+\_\+domain} & {\bf Quadrature} scheme to be used on the domain for the computation of the norm\\
\hline
\mbox{\tt in}  & {\em quadrature\+\_\+interface} & {\bf Quadrature} scheme to be used on the interface for the computation of the norm\\
\hline
\mbox{\tt in}  & {\em norm\+\_\+type} & Type of the norm (note\+: currently only {\bf Vector\+Tools\+::\+Norm\+Type}\+:\+:{\ttfamily L2\+\_\+norm} and {\bf Vector\+Tools\+::\+Norm\+Type}\+:\+:{\ttfamily Linfty\+\_\+norm} are implemented)\\
\hline
\mbox{\tt in}  & {\em component\+\_\+mask\+\_\+domain} & Domain related solution components to be included in the calculation. If the {\bf Component\+Mask} is empty, all components will be included\\
\hline
\mbox{\tt in}  & {\em component\+\_\+mask\+\_\+interface} & Interface related solution components to be included in the calculation. If the {\bf Component\+Mask} is empty, all components will be included\\
\hline
\mbox{\tt in}  & {\em exponent} & Exponent of the norm if required. Currently this is unused because no norms with variable exponent are implemented.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of the norm computed on the domain and the interface, respectively 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!compute\+\_\+e\+\_\+omega@{compute\+\_\+e\+\_\+omega}}
\index{compute\+\_\+e\+\_\+omega@{compute\+\_\+e\+\_\+omega}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{compute\+\_\+e\+\_\+omega(const unsigned int internal\+\_\+index, const unsigned int scalar\+\_\+functional\+\_\+index, const unsigned int q\+\_\+point, const Vector$<$ double $>$ \&solution\+\_\+u\+\_\+omega, const Vector$<$ double $>$ \&solution\+\_\+\+C, Vector$<$ double $>$ \&e\+\_\+omega, Full\+Matrix$<$ double $>$ \&de\+\_\+omega\+\_\+dsol\+\_\+\+T, const bool compute\+\_\+derivative=true, const bool ignore\+\_\+constants=false) const }{compute_e_omega(const unsigned int internal_index, const unsigned int scalar_functional_index, const unsigned int q_point, const Vector< double > &solution_u_omega, const Vector< double > &solution_C, Vector< double > &e_omega, FullMatrix< double > &de_omega_dsol_T, const bool compute_derivative=true, const bool ignore_constants=false) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::compute\+\_\+e\+\_\+omega (
\begin{DoxyParamCaption}
\item[{const unsigned int}]{internal\+\_\+index, }
\item[{const unsigned int}]{scalar\+\_\+functional\+\_\+index, }
\item[{const unsigned int}]{q\+\_\+point, }
\item[{const {\bf Vector}$<$ double $>$ \&}]{solution\+\_\+u\+\_\+omega, }
\item[{const {\bf Vector}$<$ double $>$ \&}]{solution\+\_\+C, }
\item[{{\bf Vector}$<$ double $>$ \&}]{e\+\_\+omega, }
\item[{{\bf Full\+Matrix}$<$ double $>$ \&}]{de\+\_\+omega\+\_\+dsol\+\_\+T, }
\item[{const bool}]{compute\+\_\+derivative = {\ttfamily true}, }
\item[{const bool}]{ignore\+\_\+constants = {\ttfamily false}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a78e22b83e1effe9b40d26ed150bebc7f}{}\label{class_assembly_helper_a78e22b83e1effe9b40d26ed150bebc7f}
Method to compute the dependent fields on the domain ( $e^\Omega_\lambda$) and the derivatives w.\+r.\+t. the relevant dofs at a quadrature point.

It is assumed that all quantities except {\ttfamily de\+\_\+omega\+\_\+dsol\+\_\+T} have the correct size when passed in and that the required {\bf F\+E\+Values} objects are properly initialized.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em internal\+\_\+index} & internal index of domain portion\\
\hline
\mbox{\tt in}  & {\em scalar\+\_\+functional\+\_\+index} & scalar functional index within domain portion\\
\hline
\mbox{\tt in}  & {\em q\+\_\+point} & quadrature point\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+u\+\_\+omega} & local solution vector for dofs related to domain related independent fields (in scalar functional related shape function indexing)\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+C} & local solution vector for dofs related to independent scalars (in scalar functional related independent scalar indexing)\\
\hline
\mbox{\tt out}  & {\em e\+\_\+omega} & computed values of the dependent fields\\
\hline
\mbox{\tt out}  & {\em de\+\_\+omega\+\_\+dsol\+\_\+T} & derivatives of the dependent fields w.\+r.\+t. the local dofs (each row in {\ttfamily de\+\_\+omega\+\_\+dsol\+\_\+T} corresponds either to a domain related dof or to an independent scalar; the domain related dofs come first with the same indexing as for {\ttfamily solution\+\_\+u\+\_\+omega}, and the independent scalars follow with the same indexing as for {\ttfamily solution\+\_\+C}; the size of {\ttfamily de\+\_\+omega\+\_\+dsol\+\_\+T} is ({\ttfamily solution\+\_\+omega.\+size()} + {\ttfamily solution\+\_\+\+C.\+size()}) x {\ttfamily e\+\_\+omega.\+size()})\\
\hline
\mbox{\tt in}  & {\em compute\+\_\+derivative} & indicates whether {\ttfamily de\+\_\+omega\+\_\+dsol\+\_\+T} is to be computed or not\\
\hline
\mbox{\tt in}  & {\em ignore\+\_\+constants} & If {\ttfamily true}, the constant terms in the dependent fields are ignored (this is required for the computation of increments of dependent fields upon increments of the solution) \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!compute\+\_\+e\+\_\+sigma@{compute\+\_\+e\+\_\+sigma}}
\index{compute\+\_\+e\+\_\+sigma@{compute\+\_\+e\+\_\+sigma}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{compute\+\_\+e\+\_\+sigma(const unsigned int internal\+\_\+index, const unsigned int scalar\+\_\+functional\+\_\+index, const unsigned int q\+\_\+point, const Vector$<$ double $>$ \&solution\+\_\+u\+\_\+sigma, const Vector$<$ double $>$ \&solution\+\_\+u\+\_\+omega\+\_\+minus, const Vector$<$ double $>$ \&solution\+\_\+u\+\_\+omega\+\_\+plus, const Vector$<$ double $>$ \&solution\+\_\+\+C, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+interface\+\_\+dof\+\_\+indices\+\_\+combined, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+minus\+\_\+dof\+\_\+indices\+\_\+combined, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+plus\+\_\+dof\+\_\+indices\+\_\+combined, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+\+C\+\_\+dof\+\_\+indices\+\_\+combined, const std\+::vector$<$ unsigned int $>$ \&dof\+\_\+indices\+\_\+global\+\_\+combined, Vector$<$ double $>$ \&e\+\_\+sigma, Full\+Matrix$<$ double $>$ \&de\+\_\+sigma\+\_\+dsol\+\_\+\+T, const bool compute\+\_\+derivative=true, const bool ignore\+\_\+constants=false) const }{compute_e_sigma(const unsigned int internal_index, const unsigned int scalar_functional_index, const unsigned int q_point, const Vector< double > &solution_u_sigma, const Vector< double > &solution_u_omega_minus, const Vector< double > &solution_u_omega_plus, const Vector< double > &solution_C, const std::vector< unsigned int > &dof_indices_interface_dof_indices_combined, const std::vector< unsigned int > &dof_indices_minus_dof_indices_combined, const std::vector< unsigned int > &dof_indices_plus_dof_indices_combined, const std::vector< unsigned int > &dof_indices_C_dof_indices_combined, const std::vector< unsigned int > &dof_indices_global_combined, Vector< double > &e_sigma, FullMatrix< double > &de_sigma_dsol_T, const bool compute_derivative=true, const bool ignore_constants=false) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::compute\+\_\+e\+\_\+sigma (
\begin{DoxyParamCaption}
\item[{const unsigned int}]{internal\+\_\+index, }
\item[{const unsigned int}]{scalar\+\_\+functional\+\_\+index, }
\item[{const unsigned int}]{q\+\_\+point, }
\item[{const {\bf Vector}$<$ double $>$ \&}]{solution\+\_\+u\+\_\+sigma, }
\item[{const {\bf Vector}$<$ double $>$ \&}]{solution\+\_\+u\+\_\+omega\+\_\+minus, }
\item[{const {\bf Vector}$<$ double $>$ \&}]{solution\+\_\+u\+\_\+omega\+\_\+plus, }
\item[{const {\bf Vector}$<$ double $>$ \&}]{solution\+\_\+C, }
\item[{const std\+::vector$<$ unsigned int $>$ \&}]{dof\+\_\+indices\+\_\+interface\+\_\+dof\+\_\+indices\+\_\+combined, }
\item[{const std\+::vector$<$ unsigned int $>$ \&}]{dof\+\_\+indices\+\_\+minus\+\_\+dof\+\_\+indices\+\_\+combined, }
\item[{const std\+::vector$<$ unsigned int $>$ \&}]{dof\+\_\+indices\+\_\+plus\+\_\+dof\+\_\+indices\+\_\+combined, }
\item[{const std\+::vector$<$ unsigned int $>$ \&}]{dof\+\_\+indices\+\_\+\+C\+\_\+dof\+\_\+indices\+\_\+combined, }
\item[{const std\+::vector$<$ unsigned int $>$ \&}]{dof\+\_\+indices\+\_\+global\+\_\+combined, }
\item[{{\bf Vector}$<$ double $>$ \&}]{e\+\_\+sigma, }
\item[{{\bf Full\+Matrix}$<$ double $>$ \&}]{de\+\_\+sigma\+\_\+dsol\+\_\+T, }
\item[{const bool}]{compute\+\_\+derivative = {\ttfamily true}, }
\item[{const bool}]{ignore\+\_\+constants = {\ttfamily false}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a17cff5d9e32bd2ceac43d9218edd0b9b}{}\label{class_assembly_helper_a17cff5d9e32bd2ceac43d9218edd0b9b}
Method to compute the dependent fields on the domain ( $e^\Sigma_\nu$) and the derivatives w.\+r.\+t. the relevant dofs at a quadrature point.

It is assumed that all quantities except {\ttfamily de\+\_\+sigma\+\_\+dsol\+\_\+T} have the correct size when passed in and that the required \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface} objects are properly initialized.

The indexing of dofs used here is a bit awkward, but is necessary to treat duplicate dofs on the minus and the plus side. See \hyperlink{namespace_auxiliary_a1d90ebc8738df3d8c70b540034137019}{Auxiliary\+::combine\+\_\+dof\+\_\+indices()} for further information.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em internal\+\_\+index} & internal index of interface (sub)portion\\
\hline
\mbox{\tt in}  & {\em scalar\+\_\+functional\+\_\+index} & scalar functional index within interface (sub)portion\\
\hline
\mbox{\tt in}  & {\em q\+\_\+point} & quadrature point\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+u\+\_\+sigma} & local solution vector for dofs related to interface related independent fields (in scalar functional related shape function indexing)\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+u\+\_\+omega\+\_\+minus} & local solution vector for dofs related to domain related independent fields on minus side (in scalar functional related shape function indexing)\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+u\+\_\+omega\+\_\+plus} & local solution vector for dofs related to domain related independent fields on plus side (in scalar functional related shape function indexing)\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+C} & local solution vector for dofs related to independent scalars (in scalar functional related independent scalar indexing)\\
\hline
\mbox{\tt in}  & {\em dof\+\_\+indices\+\_\+interface\+\_\+dof\+\_\+indices\+\_\+combined} & {\ttfamily dof\+\_\+indices\+\_\+interface\+\_\+dof\+\_\+indices\+\_\+combined}\mbox{[}{\ttfamily i}\mbox{]} is the row in {\ttfamily de\+\_\+sigma\+\_\+dsol\+\_\+T} and {\ttfamily dof\+\_\+indices\+\_\+global\+\_\+combined} corresponding to {\ttfamily solution\+\_\+u\+\_\+sigma}\mbox{[}{\ttfamily i}\mbox{]}\\
\hline
\mbox{\tt in}  & {\em dof\+\_\+indices\+\_\+minus\+\_\+dof\+\_\+indices\+\_\+combined} & {\ttfamily dof\+\_\+indices\+\_\+minus\+\_\+dof\+\_\+indices\+\_\+combined}\mbox{[}{\ttfamily i}\mbox{]} is the row in {\ttfamily de\+\_\+sigma\+\_\+dsol\+\_\+T} and {\ttfamily dof\+\_\+indices\+\_\+global\+\_\+combined} corresponding to {\ttfamily solution\+\_\+u\+\_\+omega\+\_\+minus}\mbox{[}{\ttfamily i}\mbox{]}\\
\hline
\mbox{\tt in}  & {\em dof\+\_\+indices\+\_\+plus\+\_\+dof\+\_\+indices\+\_\+combined} & {\ttfamily dof\+\_\+indices\+\_\+plus\+\_\+dof\+\_\+indices\+\_\+combined}\mbox{[}{\ttfamily i}\mbox{]} is the row in {\ttfamily de\+\_\+sigma\+\_\+dsol\+\_\+T} and {\ttfamily dof\+\_\+indices\+\_\+global\+\_\+combined} corresponding to {\ttfamily solution\+\_\+u\+\_\+omega\+\_\+plus}\mbox{[}{\ttfamily i}\mbox{]}\\
\hline
\mbox{\tt in}  & {\em dof\+\_\+indices\+\_\+\+C\+\_\+dof\+\_\+indices\+\_\+combined} & {\ttfamily dof\+\_\+indices\+\_\+\+C\+\_\+dof\+\_\+indices\+\_\+combined}\mbox{[}{\ttfamily i}\mbox{]} is the row in {\ttfamily de\+\_\+sigma\+\_\+dsol\+\_\+T} and {\ttfamily dof\+\_\+indices\+\_\+global\+\_\+combined} corresponding to {\ttfamily solution\+\_\+C}\mbox{[}{\ttfamily i}\mbox{]}\\
\hline
\mbox{\tt in}  & {\em dof\+\_\+indices\+\_\+global\+\_\+combined} & combined global dof indices, see also \hyperlink{namespace_auxiliary_a1d90ebc8738df3d8c70b540034137019}{Auxiliary\+::combine\+\_\+dof\+\_\+indices()}; this parameter is not really used inside the function except to determine the correct size of {\ttfamily de\+\_\+sigma\+\_\+dsol\+\_\+T} \\
\hline
\mbox{\tt out}  & {\em e\+\_\+sigma} & computed values of the dependent fields\\
\hline
\mbox{\tt out}  & {\em de\+\_\+sigma\+\_\+dsol\+\_\+T} & derivatives of the dependent fields w.\+r.\+t. the local dofs (each row in {\ttfamily de\+\_\+sigma\+\_\+dsol\+\_\+T} corresponds either to an interface related dof, or to a domain related dof on the minus side, or to a domain related dof on the plus side, or to an independent scalar; the indexing is determined by {\ttfamily dof\+\_\+indices\+\_\+interface\+\_\+dof\+\_\+indices\+\_\+combined}, {\ttfamily dof\+\_\+indices\+\_\+minus\+\_\+dof\+\_\+indices\+\_\+combined}, {\ttfamily dof\+\_\+indices\+\_\+plus\+\_\+dof\+\_\+indices\+\_\+combined}, {\ttfamily dof\+\_\+indices\+\_\+\+C\+\_\+dof\+\_\+indices\+\_\+combined} and is consistent with the indexing in {\ttfamily dof\+\_\+indices\+\_\+global\+\_\+combined}; the size of {\ttfamily de\+\_\+sigma\+\_\+dsol\+\_\+T} is {\ttfamily dof\+\_\+indices\+\_\+global\+\_\+combined.\+size()} x {\ttfamily e\+\_\+sigma.\+size()} )\\
\hline
\mbox{\tt in}  & {\em compute\+\_\+derivative} & indicates whether {\ttfamily de\+\_\+sigma\+\_\+dsol\+\_\+T} is to be computed or not\\
\hline
\mbox{\tt in}  & {\em ignore\+\_\+constants} & If {\ttfamily true}, the constant terms in the dependent fields are ignored (this is required for the computation of increments of dependent fields upon increments of the solution) \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!convert\+\_\+dependent\+\_\+fields\+\_\+to\+\_\+shapefunctions@{convert\+\_\+dependent\+\_\+fields\+\_\+to\+\_\+shapefunctions}}
\index{convert\+\_\+dependent\+\_\+fields\+\_\+to\+\_\+shapefunctions@{convert\+\_\+dependent\+\_\+fields\+\_\+to\+\_\+shapefunctions}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{convert\+\_\+dependent\+\_\+fields\+\_\+to\+\_\+shapefunctions()}{convert_dependent_fields_to_shapefunctions()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::convert\+\_\+dependent\+\_\+fields\+\_\+to\+\_\+shapefunctions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_aad21ced11a2d90c804827854c18f7f89}{}\label{class_assembly_helper_aad21ced11a2d90c804827854c18f7f89}
This function converts the dependent field definitions into a format suitable for assembly of the finite element system (essentially by defining how each dependent field is related to the shape functions and, possibly, the derivatives thereof). This member initializes the following member variables\+: \hyperlink{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}, \hyperlink{class_assembly_helper_ab346e146cf91fb7a0688076551b37355}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}, \hyperlink{class_assembly_helper_a12299d82365553a21fef8529c8fe8a17}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+minus}, \hyperlink{class_assembly_helper_af07bb528fdd350e9b467b08dc44a03e7}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+plus}, \hyperlink{class_assembly_helper_a0edd25820c92a25ae87fc240f4916804}{Assembly\+Helper\+::coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}, \hyperlink{class_assembly_helper_a311e176038ee2b7ca0719abb384ca57b}{Assembly\+Helper\+::coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}, \hyperlink{class_assembly_helper_a13fef9096e5fc7b1e922ea78d7aa2c28}{Assembly\+Helper\+::a\+\_\+omega}, \hyperlink{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}{Assembly\+Helper\+::b\+\_\+omega}, \hyperlink{class_assembly_helper_a75e6f76c0b12b91c5feb230251f0137f}{Assembly\+Helper\+::c\+\_\+omega}, \hyperlink{class_assembly_helper_ad93b109608d4425d318434e01cb6246c}{Assembly\+Helper\+::d\+\_\+omega}, \hyperlink{class_assembly_helper_aa266cc07e9670319481da52d633d2583}{Assembly\+Helper\+::a\+\_\+sigma}, \hyperlink{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}{Assembly\+Helper\+::b\+\_\+sigma}, \hyperlink{class_assembly_helper_a4461be378c9be0364ca23153c367d24c}{Assembly\+Helper\+::a\+\_\+minus}, \hyperlink{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}{Assembly\+Helper\+::b\+\_\+minus}, \hyperlink{class_assembly_helper_a8eb513a6239d94cc0f1a6a01a037c572}{Assembly\+Helper\+::a\+\_\+plus}, \hyperlink{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}{Assembly\+Helper\+::b\+\_\+plus}, \hyperlink{class_assembly_helper_ab3d4370661ba726010ee687ef0e98140}{Assembly\+Helper\+::c\+\_\+sigma}, \hyperlink{class_assembly_helper_a48d7d677120eb1c84b4983f470246e02}{Assembly\+Helper\+::d\+\_\+sigma}. \index{Assembly\+Helper@{Assembly\+Helper}!distribute\+\_\+dofs@{distribute\+\_\+dofs}}
\index{distribute\+\_\+dofs@{distribute\+\_\+dofs}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{distribute\+\_\+dofs()}{distribute_dofs()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::distribute\+\_\+dofs (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a953859cc4cd745a1b51fdec5418be682}{}\label{class_assembly_helper_a953859cc4cd745a1b51fdec5418be682}
This distributes the dofs. This function is called automatically after construction of an \hyperlink{class_assembly_helper}{Assembly\+Helper} object as well as after a change of the mesh. It makes sure that the active fe indices are updated before distributing the dofs. \index{Assembly\+Helper@{Assembly\+Helper}!generate\+\_\+sparsity\+\_\+pattern\+\_\+by\+\_\+simulation@{generate\+\_\+sparsity\+\_\+pattern\+\_\+by\+\_\+simulation}}
\index{generate\+\_\+sparsity\+\_\+pattern\+\_\+by\+\_\+simulation@{generate\+\_\+sparsity\+\_\+pattern\+\_\+by\+\_\+simulation}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{generate\+\_\+sparsity\+\_\+pattern\+\_\+by\+\_\+simulation(\+Sparsity\+Pattern\+Type \&dsp\+\_\+\+K, const Affine\+Constraints$<$ double $>$ \&constraints) const }{generate_sparsity_pattern_by_simulation(SparsityPatternType &dsp_K, const AffineConstraints< double > &constraints) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Sparsity\+Pattern\+Type $>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::generate\+\_\+sparsity\+\_\+pattern\+\_\+by\+\_\+simulation (
\begin{DoxyParamCaption}
\item[{Sparsity\+Pattern\+Type \&}]{dsp\+\_\+K, }
\item[{const Affine\+Constraints$<$ double $>$ \&}]{constraints}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_af45c789076262ceb24613c04427b654e}{}\label{class_assembly_helper_af45c789076262ceb24613c04427b654e}
Generate the current sparsity pattern by simulation of the assembly process, thereby taking into account the particular structure of the total potential function.

The sparsity pattern must be initialized correctly outside this function. For the parallel case, don\textquotesingle{}t forget to distribute the sparsity pattern after this function is called in order to make sure that every processor knows about its non-\/zero entries (entries in the sparsity pattern owned by a processor {\ttfamily i} may actually be written by a different processor {\ttfamily j}). See also the deal.\+II function {\bf Sparsity\+Tools\+::distribute\+\_\+sparsity\+\_\+pattern()}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em dsp\+\_\+K} & the resulting sparsity pattern for the stretched system matrix $\boldsymbol{K}^\mathrm{s}$\\
\hline
\mbox{\tt in}  & {\em constraints} & constraints to be taken into consideration when building the sparsity pattern\\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em Sparsity\+Pattern\+Type} & the type of the sparsity pattern \\
\hline
\end{DoxyTemplParams}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+dof\+\_\+handler\+\_\+system@{get\+\_\+dof\+\_\+handler\+\_\+system}}
\index{get\+\_\+dof\+\_\+handler\+\_\+system@{get\+\_\+dof\+\_\+handler\+\_\+system}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+dof\+\_\+handler\+\_\+system() const }{get_dof_handler_system() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const {\bf Do\+F\+Handler\+System}$<$spacedim$>$\& {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+dof\+\_\+handler\+\_\+system (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_ab8e95f0469f1595ab00c3fb48bcaf4fd}{}\label{class_assembly_helper_ab8e95f0469f1595ab00c3fb48bcaf4fd}
Function returning the \hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System}

\begin{DoxyReturn}{Returns}
the \hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System} \hyperlink{class_assembly_helper_a885e660c749e91a35e3279643ebcd87f}{Assembly\+Helper\+::dof\+\_\+handler\+\_\+system} 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+dof\+\_\+handler\+\_\+system@{get\+\_\+dof\+\_\+handler\+\_\+system}}
\index{get\+\_\+dof\+\_\+handler\+\_\+system@{get\+\_\+dof\+\_\+handler\+\_\+system}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+dof\+\_\+handler\+\_\+system()}{get_dof_handler_system()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ {\bf Do\+F\+Handler\+System}$<$spacedim$>$\& {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+dof\+\_\+handler\+\_\+system (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_assembly_helper_a04523eef6062ced8c88d4c093b65df3d}{}\label{class_assembly_helper_a04523eef6062ced8c88d4c093b65df3d}
Function returning the \hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System}. This function does return a non-\/const reference and can, therefore, for example be used for reordering of dof indices if desired.

\begin{DoxyReturn}{Returns}
the \hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System} \hyperlink{class_assembly_helper_a885e660c749e91a35e3279643ebcd87f}{Assembly\+Helper\+::dof\+\_\+handler\+\_\+system} 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+omega@{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+omega}}
\index{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+omega@{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+omega}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+omega(const Independent\+Field$<$ spacedim, spacedim $>$ $\ast$u\+\_\+omega, const unsigned int component, const Point$<$ spacedim $>$ p) const }{get_dof_index_at_point_omega(const IndependentField< spacedim, spacedim > *u_omega, const unsigned int component, const Point< spacedim > p) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+omega (
\begin{DoxyParamCaption}
\item[{const {\bf Independent\+Field}$<$ spacedim, spacedim $>$ $\ast$}]{u\+\_\+omega, }
\item[{const unsigned int}]{component, }
\item[{const {\bf Point}$<$ spacedim $>$}]{p}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a53c369b25d3a595229a9834950200da7}{}\label{class_assembly_helper_a53c369b25d3a595229a9834950200da7}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em u\+\_\+omega} & independent field\\
\hline
\mbox{\tt in}  & {\em component} & component\\
\hline
\mbox{\tt in}  & {\em p} & point\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
global dof index of {\ttfamily component} of {\ttfamily u\+\_\+omega} at point {\ttfamily point} . This requires that the FE used for the independent field has support points defined. 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+sigma@{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+sigma}}
\index{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+sigma@{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+sigma}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+sigma(const Independent\+Field$<$ spacedim-\/1, spacedim $>$ $\ast$u\+\_\+sigma, const unsigned int component, const Point$<$ spacedim $>$ p) const }{get_dof_index_at_point_sigma(const IndependentField< spacedim-1, spacedim > *u_sigma, const unsigned int component, const Point< spacedim > p) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+dof\+\_\+index\+\_\+at\+\_\+point\+\_\+sigma (
\begin{DoxyParamCaption}
\item[{const {\bf Independent\+Field}$<$ spacedim-\/1, spacedim $>$ $\ast$}]{u\+\_\+sigma, }
\item[{const unsigned int}]{component, }
\item[{const {\bf Point}$<$ spacedim $>$}]{p}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a8c3efbac750aa236f8b116af994c07ee}{}\label{class_assembly_helper_a8c3efbac750aa236f8b116af994c07ee}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em u\+\_\+sigma} & independent field\\
\hline
\mbox{\tt in}  & {\em component} & component\\
\hline
\mbox{\tt in}  & {\em p} & point\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
global dof index of {\ttfamily component} of {\ttfamily u\+\_\+sigma} at point {\ttfamily point} . This requires that the FE used for the independent field has support points defined. 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+dof\+\_\+indices\+\_\+C@{get\+\_\+dof\+\_\+indices\+\_\+C}}
\index{get\+\_\+dof\+\_\+indices\+\_\+C@{get\+\_\+dof\+\_\+indices\+\_\+C}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+dof\+\_\+indices\+\_\+\+C(std\+::vector$<$ unsigned int $>$ \&global\+\_\+dof\+\_\+indices\+\_\+\+C) const }{get_dof_indices_C(std::vector< unsigned int > &global_dof_indices_C) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+dof\+\_\+indices\+\_\+C (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ unsigned int $>$ \&}]{global\+\_\+dof\+\_\+indices\+\_\+C}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a4cc746ddb7917fa0e9f7cdda05345b94}{}\label{class_assembly_helper_a4cc746ddb7917fa0e9f7cdda05345b94}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em global\+\_\+dof\+\_\+indices\+\_\+C} & vector with the global dof indices corresponding to the independent scalars stored in \hyperlink{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}{Assembly\+Helper\+::C} \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+global\+\_\+dof\+\_\+index\+\_\+C@{get\+\_\+global\+\_\+dof\+\_\+index\+\_\+C}}
\index{get\+\_\+global\+\_\+dof\+\_\+index\+\_\+C@{get\+\_\+global\+\_\+dof\+\_\+index\+\_\+C}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+global\+\_\+dof\+\_\+index\+\_\+\+C(const Independent\+Field$<$ 0, spacedim $>$ $\ast$independent\+\_\+scalar) const }{get_global_dof_index_C(const IndependentField< 0, spacedim > *independent_scalar) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+global\+\_\+dof\+\_\+index\+\_\+C (
\begin{DoxyParamCaption}
\item[{const {\bf Independent\+Field}$<$ 0, spacedim $>$ $\ast$}]{independent\+\_\+scalar}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a035fabd9601baf9efade5393164ea370}{}\label{class_assembly_helper_a035fabd9601baf9efade5393164ea370}
Method returning the global dof index of an independent scalar.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em independent\+\_\+scalar} & independent scalar\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the global dof index corresponding to {\ttfamily independent\+\_\+scalar} 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+initial\+\_\+fields\+\_\+vector@{get\+\_\+initial\+\_\+fields\+\_\+vector}}
\index{get\+\_\+initial\+\_\+fields\+\_\+vector@{get\+\_\+initial\+\_\+fields\+\_\+vector}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+initial\+\_\+fields\+\_\+vector(\+Vector\+Type \&initial\+\_\+fields, const Affine\+Constraints$<$ double $>$ $\ast$constraints=nullptr) const }{get_initial_fields_vector(VectorType &initial_fields, const AffineConstraints< double > *constraints=nullptr) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Vector\+Type $>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+initial\+\_\+fields\+\_\+vector (
\begin{DoxyParamCaption}
\item[{{\bf Vector\+Type} \&}]{initial\+\_\+fields, }
\item[{const Affine\+Constraints$<$ double $>$ $\ast$}]{constraints = {\ttfamily nullptr}}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_ade14ba73257f862f4e9cde8d0d6df12e}{}\label{class_assembly_helper_ade14ba73257f862f4e9cde8d0d6df12e}
Method returning the global initial fields vector (i.\+e., a vector containing the initial dof values) as defined by \hyperlink{class_independent_field_a274c902785d2937a6065f7e09f3976c3}{Independent\+Field\+::initial\+\_\+vals} and \hyperlink{class_independent_field_3_010_00_01spacedim_01_4_a8c4c434806dadc5b885102322e27357c}{Independent\+Field$<$0, spacedim$>$\+::initial\+\_\+value}. The vector has the format $\begin{pmatrix} \boldsymbol{u}^\mathrm{initial} \\ \boldsymbol{0} \end{pmatrix}$. Here, $\boldsymbol{u}^\mathrm{initial}$ contains the initial dof values, with the dofs of \hyperlink{class_assembly_helper_a885e660c749e91a35e3279643ebcd87f}{Assembly\+Helper\+::dof\+\_\+handler\+\_\+system} being first, followed by the independent scalar dofs (i.\+e., the size of $\boldsymbol{u}^\mathrm{initial}$ is \hyperlink{class_assembly_helper_a885e660c749e91a35e3279643ebcd87f}{Assembly\+Helper\+::dof\+\_\+handler\+\_\+system}.\hyperlink{class_do_f_handler_system_a69aca46be1a419d4ae3b66d57bed8b8e}{n\+\_\+dofs\+\_\+domain() } + \hyperlink{class_assembly_helper_a885e660c749e91a35e3279643ebcd87f}{Assembly\+Helper\+::dof\+\_\+handler\+\_\+system}.\hyperlink{class_do_f_handler_system_ac9edbf2dd12e85e83f9a945bd43065ab}{n\+\_\+dofs\+\_\+interface() } + \hyperlink{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}{Assembly\+Helper\+::C}{\ttfamily }.size()). The $\boldsymbol{0}$ vector corresponds to the additional lines in the finite element system associated with the scalar functionals and independent scalars entering the total potential non-\/primitively (i.\+e., it has size \hyperlink{class_assembly_helper_af7bcfc1db651535a7aefc6071a81e124}{Assembly\+Helper\+::n\+\_\+scalar\+\_\+functionals\+\_\+nonprimitive} + \hyperlink{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}{Assembly\+Helper\+::C}{\ttfamily }.size()). Note, in this context, that the independent scalars always enter the total potential non-\/primitively.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em initial\+\_\+fields} & initial fields (the vector must be passed in with the correct size, the appropriate size can be queried by \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{Assembly\+Helper\+::system\+\_\+size()})\\
\hline
\mbox{\tt in}  & {\em constraints} & if a constraint matrix is passed, the initial fields will be made consistent with these constraints\\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em Vector\+Type} & The type used for the initial fields vector\\
\hline
\end{DoxyTemplParams}
\begin{DoxyWarning}{Warning}
Currently, this method only works if all finite elements are associated with support points. If this is not the case, the method will fail. 
\end{DoxyWarning}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+locally\+\_\+owned\+\_\+indices@{get\+\_\+locally\+\_\+owned\+\_\+indices}}
\index{get\+\_\+locally\+\_\+owned\+\_\+indices@{get\+\_\+locally\+\_\+owned\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+locally\+\_\+owned\+\_\+indices() const }{get_locally_owned_indices() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const {\bf Index\+Set} {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+locally\+\_\+owned\+\_\+indices (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a51d99905072b1e6d1aadc43e62c5af92}{}\label{class_assembly_helper_a51d99905072b1e6d1aadc43e62c5af92}
\begin{DoxyReturn}{Returns}
The set of locally owned dofs (including the stretched rows; ownership of the stretched rows is assigned to the last processor) 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+locally\+\_\+owned\+\_\+indices\+\_\+blocks@{get\+\_\+locally\+\_\+owned\+\_\+indices\+\_\+blocks}}
\index{get\+\_\+locally\+\_\+owned\+\_\+indices\+\_\+blocks@{get\+\_\+locally\+\_\+owned\+\_\+indices\+\_\+blocks}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+locally\+\_\+owned\+\_\+indices\+\_\+blocks() const }{get_locally_owned_indices_blocks() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const std\+::vector$<${\bf Index\+Set}$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+locally\+\_\+owned\+\_\+indices\+\_\+blocks (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a1d0898b738b49d1ed38448d5686e19ba}{}\label{class_assembly_helper_a1d0898b738b49d1ed38448d5686e19ba}
\begin{DoxyReturn}{Returns}
Same as \hyperlink{class_assembly_helper_a51d99905072b1e6d1aadc43e62c5af92}{Assembly\+Helper\+::get\+\_\+locally\+\_\+owned\+\_\+indices()}, but block-\/wise (the first index set contains the fe related indices, and the second index set the rest) 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+locally\+\_\+relevant\+\_\+indices@{get\+\_\+locally\+\_\+relevant\+\_\+indices}}
\index{get\+\_\+locally\+\_\+relevant\+\_\+indices@{get\+\_\+locally\+\_\+relevant\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+locally\+\_\+relevant\+\_\+indices() const }{get_locally_relevant_indices() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const {\bf Index\+Set} {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+locally\+\_\+relevant\+\_\+indices (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_ae6c72b5ed3b1cd419d58e081562e0ee7}{}\label{class_assembly_helper_ae6c72b5ed3b1cd419d58e081562e0ee7}
\begin{DoxyReturn}{Returns}
The set of locally relevant indices (including the stretched rows) 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+locally\+\_\+relevant\+\_\+indices\+\_\+blocks@{get\+\_\+locally\+\_\+relevant\+\_\+indices\+\_\+blocks}}
\index{get\+\_\+locally\+\_\+relevant\+\_\+indices\+\_\+blocks@{get\+\_\+locally\+\_\+relevant\+\_\+indices\+\_\+blocks}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+locally\+\_\+relevant\+\_\+indices\+\_\+blocks() const }{get_locally_relevant_indices_blocks() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const std\+::vector$<${\bf Index\+Set}$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+locally\+\_\+relevant\+\_\+indices\+\_\+blocks (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_ae405978288614436b0851e1d9047f084}{}\label{class_assembly_helper_ae405978288614436b0851e1d9047f084}
\begin{DoxyReturn}{Returns}
Same as \hyperlink{class_assembly_helper_ae6c72b5ed3b1cd419d58e081562e0ee7}{Assembly\+Helper\+::get\+\_\+locally\+\_\+relevant\+\_\+indices()}, but block-\/wise (the first index contains the fe related indices, and the second block the rest) 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+maximum\+\_\+step\+\_\+length@{get\+\_\+maximum\+\_\+step\+\_\+length}}
\index{get\+\_\+maximum\+\_\+step\+\_\+length@{get\+\_\+maximum\+\_\+step\+\_\+length}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+maximum\+\_\+step\+\_\+length(const Vector\+Type \&solution, const std\+::vector$<$ const Vector\+Type $\ast$ $>$ solution\+\_\+ref\+\_\+sets, const Vector\+Type \&delta\+\_\+solution) const }{get_maximum_step_length(const VectorType &solution, const std::vector< const VectorType * > solution_ref_sets, const VectorType &delta_solution) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Vector\+Type $>$ double {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+maximum\+\_\+step\+\_\+length (
\begin{DoxyParamCaption}
\item[{const {\bf Vector\+Type} \&}]{solution, }
\item[{const std\+::vector$<$ const {\bf Vector\+Type} $\ast$ $>$}]{solution\+\_\+ref\+\_\+sets, }
\item[{const {\bf Vector\+Type} \&}]{delta\+\_\+solution}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_aae924a79482fed55899a59052bd9103d}{}\label{class_assembly_helper_aae924a79482fed55899a59052bd9103d}
Method determining the maximum permissible step length into a certain direction.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em solution} & the current global solution vector\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+ref\+\_\+sets} & a set of reference solution vectors (e.\+g. solutions at previous time steps), which may enter into the calculation of the scalar functionals\\
\hline
\mbox{\tt in}  & {\em delta\+\_\+solution} & The direction into which the solution is updated\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The maximum step length alpha such that solution + alpha$\ast$delta\+\_\+solution is a permissible state
\end{DoxyReturn}

\begin{DoxyTemplParams}{Template Parameters}
{\em Vector\+Type} & The type used for the solution vector \\
\hline
\end{DoxyTemplParams}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+n\+\_\+C@{get\+\_\+n\+\_\+C}}
\index{get\+\_\+n\+\_\+C@{get\+\_\+n\+\_\+C}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+n\+\_\+\+C() const }{get_n_C() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+n\+\_\+C (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_ad6590021b351fac59dcc655e3d0da9ee}{}\label{class_assembly_helper_ad6590021b351fac59dcc655e3d0da9ee}
\begin{DoxyReturn}{Returns}
The number of independent scalars attached to the \hyperlink{class_assembly_helper}{Assembly\+Helper} 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+n\+\_\+stretched\+\_\+rows@{get\+\_\+n\+\_\+stretched\+\_\+rows}}
\index{get\+\_\+n\+\_\+stretched\+\_\+rows@{get\+\_\+n\+\_\+stretched\+\_\+rows}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+n\+\_\+stretched\+\_\+rows() const }{get_n_stretched_rows() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+n\+\_\+stretched\+\_\+rows (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a5cd3242e02bc5cb8b74cf808df257da0}{}\label{class_assembly_helper_a5cd3242e02bc5cb8b74cf808df257da0}
\begin{DoxyReturn}{Returns}
\hyperlink{class_assembly_helper_af7bcfc1db651535a7aefc6071a81e124}{Assembly\+Helper\+::n\+\_\+scalar\+\_\+functionals\+\_\+nonprimitive} + Assembly\+Helper\+::\+C.\+size() 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values@{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values}}
\index{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values@{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values(const Vector\+Type \&solution, const std\+::vector$<$ const Vector\+Type $\ast$ $>$ solution\+\_\+ref\+\_\+sets, Vector$<$ double $>$ \&nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values) const }{get_nonprimitive_scalar_functional_values(const VectorType &solution, const std::vector< const VectorType * > solution_ref_sets, Vector< double > &nonprimitive_scalar_functional_values) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Vector\+Type $>$ bool {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values (
\begin{DoxyParamCaption}
\item[{const {\bf Vector\+Type} \&}]{solution, }
\item[{const std\+::vector$<$ const {\bf Vector\+Type} $\ast$ $>$}]{solution\+\_\+ref\+\_\+sets, }
\item[{{\bf Vector}$<$ double $>$ \&}]{nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a5ab3659137ee74754cc27d9c18e1f9db}{}\label{class_assembly_helper_a5ab3659137ee74754cc27d9c18e1f9db}
Method computing the values of the scalar functionals entering non-\/primitively into the total potential

This method is required since the assembly of the finite element system cannot be done before the current values of the scalar functionals entering non-\/primitively into the total potential are known.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em solution} & the global solution vector\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+ref\+\_\+sets} & a set of reference solution vectors (e.\+g. solutions at previous time steps), which may enter into the calculation of the scalar functionals\\
\hline
\mbox{\tt out}  & {\em nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values} & Values of scalar functionals entering non-\/primitively into the total potential. The indexing is according to \hyperlink{class_assembly_helper_acf05fab2ddf57769a103d82a4f2d1cd3}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices} and \hyperlink{class_assembly_helper_a0d15b3ab0c7bec9fc4f40e532f8776f4}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices}\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily false} if the evaluation of the scalar functionals was successful, and {\ttfamily true} if an error prevented the proper calculation of these quantities
\end{DoxyReturn}

\begin{DoxyTemplParams}{Template Parameters}
{\em Vector\+Type} & The type used for the solution vector \\
\hline
\end{DoxyTemplParams}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values@{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values}}
\index{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values@{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values(const Vector\+Type \&solution, const std\+::vector$<$ const Vector\+Type $\ast$ $>$ solution\+\_\+ref\+\_\+sets, std\+::map$<$ const Scalar\+Functional$<$ spacedim, spacedim $>$ $\ast$, double $>$ \&nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values\+\_\+domain, std\+::map$<$ const Scalar\+Functional$<$ spacedim-\/1, spacedim $>$ $\ast$, double $>$ \&nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values\+\_\+interface) const }{get_nonprimitive_scalar_functional_values(const VectorType &solution, const std::vector< const VectorType * > solution_ref_sets, std::map< const ScalarFunctional< spacedim, spacedim > *, double > &nonprimitive_scalar_functional_values_domain, std::map< const ScalarFunctional< spacedim-1, spacedim > *, double > &nonprimitive_scalar_functional_values_interface) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Vector\+Type $>$ bool {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values (
\begin{DoxyParamCaption}
\item[{const {\bf Vector\+Type} \&}]{solution, }
\item[{const std\+::vector$<$ const {\bf Vector\+Type} $\ast$ $>$}]{solution\+\_\+ref\+\_\+sets, }
\item[{std\+::map$<$ const {\bf Scalar\+Functional}$<$ spacedim, spacedim $>$ $\ast$, double $>$ \&}]{nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values\+\_\+domain, }
\item[{std\+::map$<$ const {\bf Scalar\+Functional}$<$ spacedim-\/1, spacedim $>$ $\ast$, double $>$ \&}]{nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values\+\_\+interface}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a43bac43f3aecf18e08bfd1741cf30af6}{}\label{class_assembly_helper_a43bac43f3aecf18e08bfd1741cf30af6}
Method computing the values of the scalar functionals entering non-\/primitively into the total potential


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em solution} & the global solution vector\\
\hline
\mbox{\tt in}  & {\em solution\+\_\+ref\+\_\+sets} & a set of reference solution vectors (e.\+g. solutions at previous time steps), which may enter into the calculation of the scalar functionals\\
\hline
\mbox{\tt out}  & {\em nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values\+\_\+domain} & Values of domain related scalar functionals entering non-\/primitively into the total potential.\\
\hline
\mbox{\tt out}  & {\em nonprimitive\+\_\+scalar\+\_\+functional\+\_\+values\+\_\+interface} & Values of interface related scalar functionals entering non-\/primitively into the total potential.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily false} if the evaluation of the scalar functionals was successful, and {\ttfamily true} if an error prevented the proper calculation of these quantities
\end{DoxyReturn}

\begin{DoxyTemplParams}{Template Parameters}
{\em Vector\+Type} & The type used for the solution vector \\
\hline
\end{DoxyTemplParams}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+scalar\+\_\+functional\+\_\+indices@{get\+\_\+scalar\+\_\+functional\+\_\+indices}}
\index{get\+\_\+scalar\+\_\+functional\+\_\+indices@{get\+\_\+scalar\+\_\+functional\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+scalar\+\_\+functional\+\_\+indices(const Scalar\+Functional$<$ spacedim, spacedim $>$ $\ast$scalar\+\_\+functional) const }{get_scalar_functional_indices(const ScalarFunctional< spacedim, spacedim > *scalar_functional) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::pair$<$const int, const int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+scalar\+\_\+functional\+\_\+indices (
\begin{DoxyParamCaption}
\item[{const {\bf Scalar\+Functional}$<$ spacedim, spacedim $>$ $\ast$}]{scalar\+\_\+functional}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_aad795811df548677cb883341f6c52001}{}\label{class_assembly_helper_aad795811df548677cb883341f6c52001}
Function returning nonprimitive index of a domain related scalar functional according to \hyperlink{class_assembly_helper_acf05fab2ddf57769a103d82a4f2d1cd3}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices} as well as the primitive index of that scalar functional according to \hyperlink{class_assembly_helper_a4f08790a2235e48ce19f5d8d965a7874}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices}. Note that both indices may exist, because a certain scalar functional may enter different \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution} objects, with some being primitive and others non-\/primitive. If {\ttfamily scalar\+\_\+functional} is not related to any non-\/primitive \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution}, the first of the returned indices will be {\ttfamily -\/1}; and if {\ttfamily scalar\+\_\+functional} is not related to any primitive \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution}, the second of the returned indices is {\ttfamily -\/1}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em scalar\+\_\+functional} & the domain related scalar functional for which the indices are requested\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
(non-\/primitive index, primitive index) 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+scalar\+\_\+functional\+\_\+indices@{get\+\_\+scalar\+\_\+functional\+\_\+indices}}
\index{get\+\_\+scalar\+\_\+functional\+\_\+indices@{get\+\_\+scalar\+\_\+functional\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+scalar\+\_\+functional\+\_\+indices(const Scalar\+Functional$<$ spacedim-\/1, spacedim $>$ $\ast$scalar\+\_\+functional) const }{get_scalar_functional_indices(const ScalarFunctional< spacedim-1, spacedim > *scalar_functional) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::pair$<$const int, const int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+scalar\+\_\+functional\+\_\+indices (
\begin{DoxyParamCaption}
\item[{const {\bf Scalar\+Functional}$<$ spacedim-\/1, spacedim $>$ $\ast$}]{scalar\+\_\+functional}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ae5791ac73405d479df790815abc06380}{}\label{class_assembly_helper_ae5791ac73405d479df790815abc06380}
Function returning nonprimitive index of an interface related scalar functional according to \hyperlink{class_assembly_helper_a0d15b3ab0c7bec9fc4f40e532f8776f4}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices} as well as the primitive index of that scalar functional according to \hyperlink{class_assembly_helper_ad99c75f32cf3f18aa1d4067ad8b56ae8}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface\+\_\+primitive\+\_\+indices}. Note that both indices may exist, because a certain scalar functional may enter different \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution} objects, with some being primitive and others non-\/primitive. If {\ttfamily scalar\+\_\+functional} is not related to any non-\/primitive \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution}, the first of the returned indices will be {\ttfamily -\/1}; and if {\ttfamily scalar\+\_\+functional} is not related to any primitive \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution}, the second of the returned indices is {\ttfamily -\/1}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em scalar\+\_\+functional} & the interface related scalar functional for which the indices are requested\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
(non-\/primitive index, primitive index) 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+triangulation\+\_\+system@{get\+\_\+triangulation\+\_\+system}}
\index{get\+\_\+triangulation\+\_\+system@{get\+\_\+triangulation\+\_\+system}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+triangulation\+\_\+system() const }{get_triangulation_system() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const {\bf Triangulation\+System}$<$spacedim$>$\& {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+triangulation\+\_\+system (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a261ecb9213338856aa88c8ae60a44c78}{}\label{class_assembly_helper_a261ecb9213338856aa88c8ae60a44c78}
Function returning the \hyperlink{class_triangulation_system}{Triangulation\+System}

\begin{DoxyReturn}{Returns}
the \hyperlink{class_triangulation_system}{Triangulation\+System} \hyperlink{class_assembly_helper_add08a8a7bb9c9325fcc7d92bfce525d4}{Assembly\+Helper\+::tria\+\_\+system} 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+triangulation\+\_\+system@{get\+\_\+triangulation\+\_\+system}}
\index{get\+\_\+triangulation\+\_\+system@{get\+\_\+triangulation\+\_\+system}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+triangulation\+\_\+system()}{get_triangulation_system()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ {\bf Triangulation\+System}$<$spacedim$>$\& {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+triangulation\+\_\+system (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{class_assembly_helper_a16f9d21a79922d4879e37916b414f7d0}{}\label{class_assembly_helper_a16f9d21a79922d4879e37916b414f7d0}
Function returning the \hyperlink{class_triangulation_system}{Triangulation\+System}

\begin{DoxyReturn}{Returns}
the \hyperlink{class_triangulation_system}{Triangulation\+System} \hyperlink{class_assembly_helper_add08a8a7bb9c9325fcc7d92bfce525d4}{Assembly\+Helper\+::tria\+\_\+system} 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+index@{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+index}}
\index{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+index@{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+index}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+index(const Independent\+Field$<$ spacedim, spacedim $>$ \&u\+\_\+omega) const }{get_u_omega_global_component_index(const IndependentField< spacedim, spacedim > &u_omega) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+index (
\begin{DoxyParamCaption}
\item[{const {\bf Independent\+Field}$<$ spacedim, spacedim $>$ \&}]{u\+\_\+omega}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a41bdbb21e3f77cf717c9f7465363e415}{}\label{class_assembly_helper_a41bdbb21e3f77cf717c9f7465363e415}
Compute the global component index (in the domain related {\bf F\+E\+System}) of the first component of {\ttfamily u\+\_\+omega} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em u\+\_\+omega} & The domain related independent field\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
global component index 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+indices@{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+indices}}
\index{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+indices@{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+indices() const }{get_u_omega_global_component_indices() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<$const {\bf Independent\+Field}$<$spacedim, spacedim$>$$\ast$, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+u\+\_\+omega\+\_\+global\+\_\+component\+\_\+indices (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a396b89981e546af6b9bc0e35634290b3}{}\label{class_assembly_helper_a396b89981e546af6b9bc0e35634290b3}
\begin{DoxyReturn}{Returns}
map between domain related \hyperlink{class_independent_field}{Independent\+Field} objects and the global component indices (in the {\bf F\+E\+System}) of the first components of the respective \hyperlink{class_independent_field}{Independent\+Field} objects 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+index@{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+index}}
\index{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+index@{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+index}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+index(const Independent\+Field$<$ spacedim-\/1, spacedim $>$ \&u\+\_\+sigma) const }{get_u_sigma_global_component_index(const IndependentField< spacedim-1, spacedim > &u_sigma) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+index (
\begin{DoxyParamCaption}
\item[{const {\bf Independent\+Field}$<$ spacedim-\/1, spacedim $>$ \&}]{u\+\_\+sigma}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a9a8e7a9f29b275dc20811cac001bd18f}{}\label{class_assembly_helper_a9a8e7a9f29b275dc20811cac001bd18f}
Compute the global component index (in the interface related {\bf F\+E\+System}) of the first component of {\ttfamily u\+\_\+sigma} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em u\+\_\+sigma} & The interface related independent field\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
global component index 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+indices@{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+indices}}
\index{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+indices@{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+indices() const }{get_u_sigma_global_component_indices() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<$const {\bf Independent\+Field}$<$spacedim-\/1, spacedim$>$$\ast$, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::get\+\_\+u\+\_\+sigma\+\_\+global\+\_\+component\+\_\+indices (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_aca4d34e08f177e8d075c86bb34906f2f}{}\label{class_assembly_helper_aca4d34e08f177e8d075c86bb34906f2f}
\begin{DoxyReturn}{Returns}
map between interface related \hyperlink{class_independent_field}{Independent\+Field} objects and the global component indices (in the {\bf F\+E\+System}) of the first components of the respective \hyperlink{class_independent_field}{Independent\+Field} objects 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!initialize\+\_\+fe\+\_\+values\+\_\+domain@{initialize\+\_\+fe\+\_\+values\+\_\+domain}}
\index{initialize\+\_\+fe\+\_\+values\+\_\+domain@{initialize\+\_\+fe\+\_\+values\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{initialize\+\_\+fe\+\_\+values\+\_\+domain(const typename hp\+::\+Do\+F\+Handler$<$ spacedim, spacedim $>$\+::active\+\_\+cell\+\_\+iterator \&cell, const unsigned int internal\+\_\+index, const bool nonprimitive=false) const }{initialize_fe_values_domain(const typename hp::DoFHandler< spacedim, spacedim >::active_cell_iterator &cell, const unsigned int internal_index, const bool nonprimitive=false) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::initialize\+\_\+fe\+\_\+values\+\_\+domain (
\begin{DoxyParamCaption}
\item[{const typename {\bf hp\+::\+Do\+F\+Handler}$<$ spacedim, spacedim $>$\+::{\bf active\+\_\+cell\+\_\+iterator} \&}]{cell, }
\item[{const unsigned int}]{internal\+\_\+index, }
\item[{const bool}]{nonprimitive = {\ttfamily false}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ab4c51b059d53f0086ebce3b60d4d2400}{}\label{class_assembly_helper_ab4c51b059d53f0086ebce3b60d4d2400}
Method to initialize the required {\bf F\+E\+Values} objects for assembly of the contribution of a domain cell to the finite element system.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cell} & The domain cell\\
\hline
\mbox{\tt in}  & {\em internal\+\_\+index} & The internal index of the domain portion the domain cell belongs to. In principle, the function could determine the {\ttfamily internal\+\_\+index} from {\ttfamily cell}. However, typically it is already known when the function is called and therefore it is passed here as an argument.\\
\hline
\mbox{\tt in}  & {\em nonprimitive} & if {\ttfamily true\+:} initialize only those {\bf F\+E\+Values} objects needed for evaluation of the scalar functionals entering non-\/primitively into the total potential \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!initialize\+\_\+fe\+\_\+values\+\_\+interface@{initialize\+\_\+fe\+\_\+values\+\_\+interface}}
\index{initialize\+\_\+fe\+\_\+values\+\_\+interface@{initialize\+\_\+fe\+\_\+values\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{initialize\+\_\+fe\+\_\+values\+\_\+interface(const Interface\+Cell\+Domain\+Cells\+Do\+F$<$ spacedim $>$ \&interface\+\_\+cell\+\_\+domain\+\_\+cells, const unsigned int internal\+\_\+index, const bool nonprimitive=false) const }{initialize_fe_values_interface(const InterfaceCellDomainCellsDoF< spacedim > &interface_cell_domain_cells, const unsigned int internal_index, const bool nonprimitive=false) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::initialize\+\_\+fe\+\_\+values\+\_\+interface (
\begin{DoxyParamCaption}
\item[{const {\bf Interface\+Cell\+Domain\+Cells\+DoF}$<$ spacedim $>$ \&}]{interface\+\_\+cell\+\_\+domain\+\_\+cells, }
\item[{const unsigned int}]{internal\+\_\+index, }
\item[{const bool}]{nonprimitive = {\ttfamily false}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a07b7b359ed67e0f949aa8817853ad0c2}{}\label{class_assembly_helper_a07b7b359ed67e0f949aa8817853ad0c2}
Method to initialize the required \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface} objects for assembly of the contribution of an interface cell (and the neighboring domain cells) to the finite element system.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em interface\+\_\+cell\+\_\+domain\+\_\+cells} & The interface cell (and the neighboring domain cells)\\
\hline
\mbox{\tt in}  & {\em internal\+\_\+index} & The internal index of the interface (sub)portion the interface cell belongs to. In principle, the function could determine the {\ttfamily internal\+\_\+index} from {\ttfamily interface\+\_\+cell\+\_\+domain\+\_\+cell}. However, typically it is already known when the function is called and therefore it is passed here as an argument.\\
\hline
\mbox{\tt in}  & {\em nonprimitive} & if {\ttfamily true\+:} initialize only those \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface} objects needed for evaluation of the scalar functionals entering non-\/primitively into the total potential \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!initialize\+\_\+hidden\+\_\+variables@{initialize\+\_\+hidden\+\_\+variables}}
\index{initialize\+\_\+hidden\+\_\+variables@{initialize\+\_\+hidden\+\_\+variables}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{initialize\+\_\+hidden\+\_\+variables() const }{initialize_hidden_variables() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::initialize\+\_\+hidden\+\_\+variables (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a1cd5d35b136347876aa13b89749338a0}{}\label{class_assembly_helper_a1cd5d35b136347876aa13b89749338a0}
Function initializing the hidden variables of the scalar functionals. This uses the functions \hyperlink{class_scalar_functional_a602d0bc2c945822c6b756fc63183ae2b}{Scalar\+Functional\+::initial\+\_\+vals\+\_\+hidden} and \hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ae3282d5182360e0030e4cc5e02fbe2eb}{Scalar\+Functional$<$spacedim, spacedim$>$\+::initial\+\_\+vals\+\_\+hidden}, respectively.

\begin{DoxyWarning}{Warning}
At present the transfer of hidden variables upon mesh refinement is not implemented. So, use hidden variables only if the mesh is not changed after the \hyperlink{class_assembly_helper}{Assembly\+Helper} has been set up! 
\end{DoxyWarning}
\index{Assembly\+Helper@{Assembly\+Helper}!make\+\_\+dirichlet\+\_\+constraints@{make\+\_\+dirichlet\+\_\+constraints}}
\index{make\+\_\+dirichlet\+\_\+constraints@{make\+\_\+dirichlet\+\_\+constraints}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{make\+\_\+dirichlet\+\_\+constraints(\+Affine\+Constraints$<$ double $>$ \&constraint\+\_\+matrix, const std\+::vector$<$ const Dirichlet\+Constraint$<$ spacedim $>$ $\ast$ $>$ \&dirichlet\+\_\+constraints, const Affine\+Constraints$<$ double $>$ \&constraints\+\_\+ignore=\+Affine\+Constraints$<$ double $>$()) const }{make_dirichlet_constraints(AffineConstraints< double > &constraint_matrix, const std::vector< const DirichletConstraint< spacedim > * > &dirichlet_constraints, const AffineConstraints< double > &constraints_ignore=AffineConstraints< double >()) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::make\+\_\+dirichlet\+\_\+constraints (
\begin{DoxyParamCaption}
\item[{Affine\+Constraints$<$ double $>$ \&}]{constraint\+\_\+matrix, }
\item[{const std\+::vector$<$ const {\bf Dirichlet\+Constraint}$<$ spacedim $>$ $\ast$ $>$ \&}]{dirichlet\+\_\+constraints, }
\item[{const Affine\+Constraints$<$ double $>$ \&}]{constraints\+\_\+ignore = {\ttfamily AffineConstraints$<$~double~$>$()}}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_ab9602b90beefa27eba50d9d837c1bf7b}{}\label{class_assembly_helper_ab9602b90beefa27eba50d9d837c1bf7b}
Method generating Dirichlet type constraints on domain related independent fields on interfaces.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em constraint\+\_\+matrix} & resulting constraint matrix with the Dirichlet type constraints\\
\hline
\mbox{\tt in}  & {\em dirichlet\+\_\+constraints} & constraints to be applied to the domain related fields\\
\hline
\mbox{\tt in}  & {\em constraints\+\_\+ignore} & All dofs which are already constrained in {\ttfamily ignore\+\_\+constrained} will not again be constrained in {\ttfamily constraint\+\_\+matrix} \\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
The constraint matrix will be cleared before the constraints are written. This means that if you have other constraints, it will be necessary to merge the constraint matrices. The {\ttfamily local\+\_\+lines} property will be set to what \hyperlink{class_do_f_handler_system_a15566db3dbb5d3ab2e4732354432f56e}{Do\+F\+Handler\+System\+::get\+\_\+locally\+\_\+relevant\+\_\+dofs()} of the object \hyperlink{class_assembly_helper_a885e660c749e91a35e3279643ebcd87f}{Assembly\+Helper\+::dof\+\_\+handler\+\_\+system} returns.

Domain related independent fields can only be directly constrained using this method if they are discretized based on finite elements having support points! Attempting to constrain independent fields discretized in terms of elements not having support points with this function will have no effect. 
\end{DoxyWarning}
\index{Assembly\+Helper@{Assembly\+Helper}!make\+\_\+dirichlet\+\_\+constraints\+\_\+recursion@{make\+\_\+dirichlet\+\_\+constraints\+\_\+recursion}}
\index{make\+\_\+dirichlet\+\_\+constraints\+\_\+recursion@{make\+\_\+dirichlet\+\_\+constraints\+\_\+recursion}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{make\+\_\+dirichlet\+\_\+constraints\+\_\+recursion(const typename Triangulation\+System$<$ spacedim $>$\+::\+Domain\+Cell \&domain\+\_\+cell, const unsigned int face, const std\+::vector$<$ unsigned int $>$ \&shapefuns, const Dirichlet\+Constraint$<$ spacedim $>$ \&constraint, Affine\+Constraints$<$ double $>$ \&constraint\+\_\+matrix, const Affine\+Constraints$<$ double $>$ \&constraints\+\_\+ignore) const }{make_dirichlet_constraints_recursion(const typename TriangulationSystem< spacedim >::DomainCell &domain_cell, const unsigned int face, const std::vector< unsigned int > &shapefuns, const DirichletConstraint< spacedim > &constraint, AffineConstraints< double > &constraint_matrix, const AffineConstraints< double > &constraints_ignore) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::make\+\_\+dirichlet\+\_\+constraints\+\_\+recursion (
\begin{DoxyParamCaption}
\item[{const typename {\bf Triangulation\+System}$<$ spacedim $>$\+::Domain\+Cell \&}]{domain\+\_\+cell, }
\item[{const unsigned int}]{face, }
\item[{const std\+::vector$<$ unsigned int $>$ \&}]{shapefuns, }
\item[{const {\bf Dirichlet\+Constraint}$<$ spacedim $>$ \&}]{constraint, }
\item[{Affine\+Constraints$<$ double $>$ \&}]{constraint\+\_\+matrix, }
\item[{const Affine\+Constraints$<$ double $>$ \&}]{constraints\+\_\+ignore}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a5c4d81be4c30b8a40761ac5710734576}{}\label{class_assembly_helper_a5c4d81be4c30b8a40761ac5710734576}
Auxiliary function for creation of Dirichlet constraints


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em domain\+\_\+cell} & The domain cell for which constraints are to be created\\
\hline
\mbox{\tt in}  & {\em face} & The face of the domain cell on which constraints are to be created\\
\hline
\mbox{\tt in}  & {\em shapefuns} & The shape functions to be constrained\\
\hline
\mbox{\tt in}  & {\em constraint} & The constraint object describing the constraint\\
\hline
\mbox{\tt in,out}  & {\em constraint\+\_\+matrix} & The constraint matrix into which the constraints go\\
\hline
\mbox{\tt in}  & {\em constraints\+\_\+ignore} & A constraint matrix with indices which should not be constrained again \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!print\+\_\+assembly\+\_\+helper\+\_\+definition@{print\+\_\+assembly\+\_\+helper\+\_\+definition}}
\index{print\+\_\+assembly\+\_\+helper\+\_\+definition@{print\+\_\+assembly\+\_\+helper\+\_\+definition}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{print\+\_\+assembly\+\_\+helper\+\_\+definition(const bool detailed\+\_\+printout\+\_\+shapefuns=true) const }{print_assembly_helper_definition(const bool detailed_printout_shapefuns=true) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::print\+\_\+assembly\+\_\+helper\+\_\+definition (
\begin{DoxyParamCaption}
\item[{const bool}]{detailed\+\_\+printout\+\_\+shapefuns = {\ttfamily true}}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_afd598b93397e6af53f0e4e274e6f880e}{}\label{class_assembly_helper_afd598b93397e6af53f0e4e274e6f880e}
Outputs the problem definition for diagnostic purposes to screen (e.\+g., how the total potential looks like, which finite elements are used, which quadrature rules are used, etc.).

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000006}{Todo}]Currently this function does not print information about independent scalars and the constant terms in the dependent fields. This must be changed.\end{DoxyRefDesc}



\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em detailed\+\_\+printout\+\_\+shapefuns} & if {\ttfamily true} print out a detailed summary about how dependent fields are related to shape functions \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!print\+\_\+dof\+\_\+information@{print\+\_\+dof\+\_\+information}}
\index{print\+\_\+dof\+\_\+information@{print\+\_\+dof\+\_\+information}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{print\+\_\+dof\+\_\+information(const unsigned int dof\+\_\+index) const }{print_dof_information(const unsigned int dof_index) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ void {\bf Assembly\+Helper}$<$ spacedim $>$\+::print\+\_\+dof\+\_\+information (
\begin{DoxyParamCaption}
\item[{const unsigned int}]{dof\+\_\+index}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a532f565a8725675fcca12c1f8c669a44}{}\label{class_assembly_helper_a532f565a8725675fcca12c1f8c669a44}
Function for printing out information about a dof


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dof\+\_\+index} & The dof index \\
\hline
\end{DoxyParams}
\index{Assembly\+Helper@{Assembly\+Helper}!system\+\_\+size@{system\+\_\+size}}
\index{system\+\_\+size@{system\+\_\+size}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{system\+\_\+size() const }{system_size() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::system\+\_\+size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{}\label{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}
\begin{DoxyReturn}{Returns}
The size of the stretched finite element system 
\end{DoxyReturn}
\index{Assembly\+Helper@{Assembly\+Helper}!write\+\_\+output\+\_\+independent\+\_\+fields@{write\+\_\+output\+\_\+independent\+\_\+fields}}
\index{write\+\_\+output\+\_\+independent\+\_\+fields@{write\+\_\+output\+\_\+independent\+\_\+fields}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{write\+\_\+output\+\_\+independent\+\_\+fields(const Vector\+Type \&solution, const std\+::string file\+\_\+name\+\_\+domain, const std\+::string file\+\_\+name\+\_\+interface, const unsigned int file\+\_\+index=0, const std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$ \&dp\+\_\+domain=std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$(), const std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$ \&dp\+\_\+interface=std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$(), const unsigned int n\+\_\+subdivisions=1) const }{write_output_independent_fields(const VectorType &solution, const std::string file_name_domain, const std::string file_name_interface, const unsigned int file_index=0, const std::vector< dealii::SmartPointer< const dealii::DataPostprocessor< spacedim >>> &dp_domain=std::vector< dealii::SmartPointer< const dealii::DataPostprocessor< spacedim >>>(), const std::vector< dealii::SmartPointer< const dealii::DataPostprocessor< spacedim >>> &dp_interface=std::vector< dealii::SmartPointer< const dealii::DataPostprocessor< spacedim >>>(), const unsigned int n_subdivisions=1) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ template$<$class Vector\+Type $>$ std\+::pair$<$const std\+::string, const std\+::string$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::write\+\_\+output\+\_\+independent\+\_\+fields (
\begin{DoxyParamCaption}
\item[{const {\bf Vector\+Type} \&}]{solution, }
\item[{const std\+::string}]{file\+\_\+name\+\_\+domain, }
\item[{const std\+::string}]{file\+\_\+name\+\_\+interface, }
\item[{const unsigned int}]{file\+\_\+index = {\ttfamily 0}, }
\item[{const std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$ \&}]{dp\+\_\+domain = {\ttfamily std\+:\+:vector$<$~dealii\+:\+:SmartPointer$<$~const~dealii\+:\+:DataPostprocessor$<$~spacedim~$>$$>$$>$()}, }
\item[{const std\+::vector$<$ dealii\+::\+Smart\+Pointer$<$ const dealii\+::\+Data\+Postprocessor$<$ spacedim $>$$>$$>$ \&}]{dp\+\_\+interface = {\ttfamily std\+:\+:vector$<$~dealii\+:\+:SmartPointer$<$~const~dealii\+:\+:DataPostprocessor$<$~spacedim~$>$$>$$>$()}, }
\item[{const unsigned int}]{n\+\_\+subdivisions = {\ttfamily 1}}
\end{DoxyParamCaption}
) const}\hypertarget{class_assembly_helper_a74187aa98464043ea6572c3ac345640e}{}\label{class_assembly_helper_a74187aa98464043ea6572c3ac345640e}
Function to write dof output to $\ast$.vtu files (one for the domain and one for the interface). This only writes the dofs on the domain and the interface to the file; the independent scalars are currently not included in the output.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em solution} & The solution $\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$, where the values of $\boldsymbol{\hat \lambda}$ are not used and are, therefore, arbitrary. The appropriate size of {\ttfamily solution} can be obtained from \hyperlink{class_assembly_helper_a7de6972444e41dadb8eaac8024b261f6}{Assembly\+Helper\+::system\+\_\+size()}.\\
\hline
\mbox{\tt in}  & {\em file\+\_\+name\+\_\+domain} & A file name for the output of domain related dofs (note that the extension .vtu will be appended automatically)\\
\hline
\mbox{\tt in}  & {\em file\+\_\+name\+\_\+interface} & A file name for the output of interface related dofs (note that the extension .vtu will be appended automatically)\\
\hline
\mbox{\tt in}  & {\em file\+\_\+index} & An index which is appended to the file name (but in front of the extension)\\
\hline
\mbox{\tt in}  & {\em dp\+\_\+domain} & {\bf Data\+Postprocessor} objects for extra output on domain cells\\
\hline
\mbox{\tt in}  & {\em dp\+\_\+interface} & {\bf Data\+Postprocessor} objects for extra output on interface cells\\
\hline
\mbox{\tt in}  & {\em n\+\_\+subdivisions} & The number of subdivisions of the cell (to get a better representation in case of curved inner cells, higher order elements, etc.)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The file names actually used for writing domain and interface output (including the file name extension) 
\end{DoxyReturn}


\subsection{Member Data Documentation}
\index{Assembly\+Helper@{Assembly\+Helper}!a\+\_\+minus@{a\+\_\+minus}}
\index{a\+\_\+minus@{a\+\_\+minus}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{a\+\_\+minus}{a_minus}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$const double, const unsigned int, std\+::vector$<$unsigned int$>$ $>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::a\+\_\+minus\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a4461be378c9be0364ca23153c367d24c}{}\label{class_assembly_helper_a4461be378c9be0364ca23153c367d24c}
This member contains information about how interface related dependent fields $e^\Sigma_\nu$ are related to shape functions. In particular, it relates shape functions to the terms $a^-_{\nu\epsilon} (u^\Omega_\epsilon)^-$ (see \hyperlink{class_dependent_field}{Dependent\+Field} for further information).

\hyperlink{class_assembly_helper_a4461be378c9be0364ca23153c367d24c}{Assembly\+Helper\+::a\+\_\+minus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the interface (sub)portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_a4461be378c9be0364ca23153c367d24c}{Assembly\+Helper\+::a\+\_\+minus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $a^-_{\nu\epsilon} (u^\Omega_\epsilon)^-$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_a4461be378c9be0364ca23153c367d24c}{Assembly\+Helper\+::a\+\_\+minus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $a^-_{\nu\epsilon}$, {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_a4461be378c9be0364ca23153c367d24c}{Assembly\+Helper\+::a\+\_\+minus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the global component corresponding to the independent field $u^\Omega_\epsilon$, and {\ttfamily get$<${\ttfamily 2$>$}(\hyperlink{class_assembly_helper_a4461be378c9be0364ca23153c367d24c}{Assembly\+Helper\+::a\+\_\+minus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) contains all the (scalar functional related) shape function indices of a domain cell on the minus side corresponding to shape functions which are non-\/zero in the relevant global component. \index{Assembly\+Helper@{Assembly\+Helper}!a\+\_\+omega@{a\+\_\+omega}}
\index{a\+\_\+omega@{a\+\_\+omega}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{a\+\_\+omega}{a_omega}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$const double, const unsigned int, std\+::vector$<$unsigned int$>$ $>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::a\+\_\+omega\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a13fef9096e5fc7b1e922ea78d7aa2c28}{}\label{class_assembly_helper_a13fef9096e5fc7b1e922ea78d7aa2c28}
This member contains information about how domain related dependent fields $e^\Omega_\lambda$ are related to shape functions. In particular, it relates shape functions to the terms $a^\Omega_{\lambda\epsilon} u^\Omega_\epsilon$ (see \hyperlink{class_dependent_field_3_01spacedim_00_01spacedim_01_4}{Dependent\+Field$<$spacedim, spacedim$>$} for further information).

\hyperlink{class_assembly_helper_a13fef9096e5fc7b1e922ea78d7aa2c28}{Assembly\+Helper\+::a\+\_\+omega}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the domain portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_a13fef9096e5fc7b1e922ea78d7aa2c28}{Assembly\+Helper\+::a\+\_\+omega}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $a^\Omega_{\lambda \epsilon} u^\Omega_\epsilon$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_a13fef9096e5fc7b1e922ea78d7aa2c28}{Assembly\+Helper\+::a\+\_\+omega}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $a^\Omega_{\lambda \epsilon}$, {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_a13fef9096e5fc7b1e922ea78d7aa2c28}{Assembly\+Helper\+::a\+\_\+omega}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the global component corresponding to the independent field $u^\Omega_\epsilon$, and {\ttfamily get$<${\ttfamily 2$>$}(\hyperlink{class_assembly_helper_a13fef9096e5fc7b1e922ea78d7aa2c28}{Assembly\+Helper\+::a\+\_\+omega}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) contains all the (scalar functional related) shape function indices of a domain cell corresponding to shape functions which are non-\/zero in the relevant global component. \index{Assembly\+Helper@{Assembly\+Helper}!a\+\_\+plus@{a\+\_\+plus}}
\index{a\+\_\+plus@{a\+\_\+plus}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{a\+\_\+plus}{a_plus}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$const double, const unsigned int, std\+::vector$<$unsigned int$>$ $>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::a\+\_\+plus\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a8eb513a6239d94cc0f1a6a01a037c572}{}\label{class_assembly_helper_a8eb513a6239d94cc0f1a6a01a037c572}
This member contains information about how interface related dependent fields $e^\Sigma_\nu$ are related to shape functions. In particular, it relates shape functions to the terms $a^+_{\nu\epsilon} (u^\Omega_\epsilon)^+$ (see \hyperlink{class_dependent_field}{Dependent\+Field} for further information).

\hyperlink{class_assembly_helper_a8eb513a6239d94cc0f1a6a01a037c572}{Assembly\+Helper\+::a\+\_\+plus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the interface (sub)portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_a8eb513a6239d94cc0f1a6a01a037c572}{Assembly\+Helper\+::a\+\_\+plus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $a^+_{\nu\epsilon} (u^\Omega_\epsilon)^+$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_a8eb513a6239d94cc0f1a6a01a037c572}{Assembly\+Helper\+::a\+\_\+plus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $a^+_{\nu\epsilon}$, {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_a8eb513a6239d94cc0f1a6a01a037c572}{Assembly\+Helper\+::a\+\_\+plus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the global component corresponding to the independent field $u^\Omega_\epsilon$, and {\ttfamily get$<${\ttfamily 2$>$}(\hyperlink{class_assembly_helper_a8eb513a6239d94cc0f1a6a01a037c572}{Assembly\+Helper\+::a\+\_\+plus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) contains all the (scalar functional related) shape function indices of a domain cell on the plus side corresponding to shape functions which are non-\/zero in the relevant global component. \index{Assembly\+Helper@{Assembly\+Helper}!a\+\_\+sigma@{a\+\_\+sigma}}
\index{a\+\_\+sigma@{a\+\_\+sigma}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{a\+\_\+sigma}{a_sigma}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$const double, const unsigned int, std\+::vector$<$unsigned int$>$ $>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::a\+\_\+sigma\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_aa266cc07e9670319481da52d633d2583}{}\label{class_assembly_helper_aa266cc07e9670319481da52d633d2583}
This member contains information about how interface related dependent fields $e^\Sigma_\nu$ are related to shape functions. In particular, it relates shape functions to the terms $a^\Sigma_{\nu\eta} u^\Sigma_\eta$ (see \hyperlink{class_dependent_field}{Dependent\+Field} for further information).

\hyperlink{class_assembly_helper_aa266cc07e9670319481da52d633d2583}{Assembly\+Helper\+::a\+\_\+sigma}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the interface (sub)portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_aa266cc07e9670319481da52d633d2583}{Assembly\+Helper\+::a\+\_\+sigma}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $a^\Sigma_{\nu\eta} u^\Sigma_\eta$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_aa266cc07e9670319481da52d633d2583}{Assembly\+Helper\+::a\+\_\+sigma}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $a^\Sigma_{\nu \eta}$, {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_aa266cc07e9670319481da52d633d2583}{Assembly\+Helper\+::a\+\_\+sigma}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the global component corresponding to the independent field $u^\Sigma_\eta$, and {\ttfamily get$<${\ttfamily 2$>$}(\hyperlink{class_assembly_helper_aa266cc07e9670319481da52d633d2583}{Assembly\+Helper\+::a\+\_\+sigma}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) contains all the (scalar functional related) shape function indices of an interface cell corresponding to shape functions which are non-\/zero in the relevant global component. \index{Assembly\+Helper@{Assembly\+Helper}!b\+\_\+minus@{b\+\_\+minus}}
\index{b\+\_\+minus@{b\+\_\+minus}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{b\+\_\+minus}{b_minus}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$const double, const unsigned int, const unsigned int, std\+::vector$<$unsigned int$>$ $>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::b\+\_\+minus\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}{}\label{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}
This member contains information about how interface related dependent fields $e^\Sigma_\nu$ are related to shape functions. In particular, it relates shape functions to the terms $b^-_{\nu\epsilon i} \left(\dfrac{\partial u^\Omega_\epsilon}{\partial x_i}\right)^-$ (see \hyperlink{class_dependent_field}{Dependent\+Field} for further information).

\hyperlink{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}{Assembly\+Helper\+::b\+\_\+minus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the interface (sub)portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}{Assembly\+Helper\+::b\+\_\+minus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $b^-_{\nu\epsilon i} \left(\dfrac{\partial u^\Omega_\epsilon}{\partial x_i}\right)^-$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}{Assembly\+Helper\+::b\+\_\+minus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $b^-_{\nu\epsilon i}$, {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}{Assembly\+Helper\+::b\+\_\+minus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the global component corresponding to the independent field $u^\Omega_\epsilon$, {\ttfamily get$<${\ttfamily 2$>$}(\hyperlink{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}{Assembly\+Helper\+::b\+\_\+minus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the derivative $i$ of the independent field $u^\Omega_\epsilon$, and {\ttfamily get$<${\ttfamily 3$>$}(\hyperlink{class_assembly_helper_a6f51f8b4dfdae385a2e2fe2dd9e66cdb}{Assembly\+Helper\+::b\+\_\+minus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) contains all the (scalar functional related) shape function indices of a domain cell on the minus side corresponding to shape functions which are non-\/zero in the relevant global component. \index{Assembly\+Helper@{Assembly\+Helper}!b\+\_\+omega@{b\+\_\+omega}}
\index{b\+\_\+omega@{b\+\_\+omega}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{b\+\_\+omega}{b_omega}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$const double, const unsigned int, const unsigned int, std\+::vector$<$unsigned int$>$ $>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::b\+\_\+omega\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}{}\label{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}
This member contains information about how domain related dependent fields $e^\Omega_\lambda$ are related to shape functions. In particular, it relates shape functions to the terms $b^\Omega_{\lambda \epsilon i} \dfrac{\partial u^\Omega_\epsilon}{\partial x_i}$ (see \hyperlink{class_dependent_field_3_01spacedim_00_01spacedim_01_4}{Dependent\+Field$<$spacedim, spacedim$>$} for further information).

\hyperlink{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}{Assembly\+Helper\+::b\+\_\+omega}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the domain portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}{Assembly\+Helper\+::b\+\_\+omega}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $b^\Omega_{\lambda \epsilon i} \dfrac{\partial u^\Omega_\epsilon}{\partial x_i}$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}{Assembly\+Helper\+::b\+\_\+omega}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $b^\Omega_{\lambda \epsilon i}$, {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}{Assembly\+Helper\+::b\+\_\+omega}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the global component corresponding to the independent field $u^\Omega_\epsilon$, {\ttfamily get$<${\ttfamily 2$>$}(\hyperlink{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}{Assembly\+Helper\+::b\+\_\+omega}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the derivative $i$ of the independent field $u^\Omega_\epsilon$, and {\ttfamily get$<${\ttfamily 3$>$}(\hyperlink{class_assembly_helper_a5fbb532e798c2427af5285c2df10c9f4}{Assembly\+Helper\+::b\+\_\+omega}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) contains all the (scalar functional related) shape function indices of a domain cell corresponding to shape functions which are non-\/zero in the relevant global component. \index{Assembly\+Helper@{Assembly\+Helper}!b\+\_\+plus@{b\+\_\+plus}}
\index{b\+\_\+plus@{b\+\_\+plus}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{b\+\_\+plus}{b_plus}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$const double, const unsigned int, const unsigned int, std\+::vector$<$unsigned int$>$ $>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::b\+\_\+plus\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}{}\label{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}
This member contains information about how interface related dependent fields $e^\Sigma_\nu$ are related to shape functions. In particular, it relates shape functions to the terms $b^+_{\nu\epsilon i} \left(\dfrac{\partial u^\Omega_\epsilon}{\partial x_i}\right)^+$ (see \hyperlink{class_dependent_field}{Dependent\+Field} for further information).

\hyperlink{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}{Assembly\+Helper\+::b\+\_\+plus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the interface (sub)portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}{Assembly\+Helper\+::b\+\_\+plus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $b^+_{\nu\epsilon i} \left(\dfrac{\partial u^\Omega_\epsilon}{\partial x_i}\right)^+$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}{Assembly\+Helper\+::b\+\_\+plus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $b^+_{\nu\epsilon i}$, {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}{Assembly\+Helper\+::b\+\_\+plus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the global component corresponding to the independent field $u^\Omega_\epsilon$, {\ttfamily get$<${\ttfamily 2$>$}(\hyperlink{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}{Assembly\+Helper\+::b\+\_\+plus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the derivative $i$ of the independent field $u^\Omega_\epsilon$, and {\ttfamily get$<${\ttfamily 3$>$}(\hyperlink{class_assembly_helper_ab09dd07d3ec596525be83f8f5859bef7}{Assembly\+Helper\+::b\+\_\+plus}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) contains all the (scalar functional related) shape function indices of a domain cell on the plus side corresponding to shape functions which are non-\/zero in the relevant global component. \index{Assembly\+Helper@{Assembly\+Helper}!b\+\_\+sigma@{b\+\_\+sigma}}
\index{b\+\_\+sigma@{b\+\_\+sigma}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{b\+\_\+sigma}{b_sigma}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$ std\+::tuple$<$const double, const unsigned int, const unsigned int, std\+::vector$<$unsigned int$>$ $>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::b\+\_\+sigma\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}{}\label{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}
This member contains information about how interface related dependent fields $e^\Sigma_\nu$ are related to shape functions. In particular, it relates shape functions to the terms $b^\Sigma_{\nu \eta i} \dfrac{\partial u^\Sigma_\eta}{\partial x_i}$ (see \hyperlink{class_dependent_field}{Dependent\+Field} for further information).

\hyperlink{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}{Assembly\+Helper\+::b\+\_\+sigma}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the interface (sub)portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}{Assembly\+Helper\+::b\+\_\+sigma}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $b^\Sigma_{\nu \eta i} \dfrac{\partial u^\Sigma_\eta}{\partial x_i}$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}{Assembly\+Helper\+::b\+\_\+sigma}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $b^\Sigma_{\nu \eta i}$, {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}{Assembly\+Helper\+::b\+\_\+sigma}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the global component corresponding to the independent field $u^\Sigma_\eta$, {\ttfamily get$<${\ttfamily 2$>$}(\hyperlink{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}{Assembly\+Helper\+::b\+\_\+sigma}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the derivative $i$ of the independent field $u^\Sigma_\eta$, and {\ttfamily get$<${\ttfamily 3$>$}(\hyperlink{class_assembly_helper_af58c9a1c7093edc306070913aa1b9be2}{Assembly\+Helper\+::b\+\_\+sigma}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) contains all the (scalar functional related) shape function indices of an interface cell corresponding to shape functions which are non-\/zero in the relevant global component. \index{Assembly\+Helper@{Assembly\+Helper}!C@{C}}
\index{C@{C}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{C}{C}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<${\bf Smart\+Pointer}$<$const {\bf Independent\+Field}$<$0, spacedim$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::C\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}{}\label{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}
vector of independent scalars $C_\iota$ involved in the definition of the problem. These independent scalars are sorted by \hyperlink{class_independent_field_3_010_00_01spacedim_01_4_a05ecdcc8310253f055fbc59abaa2bc90}{Independent\+Field$<$0, spacedim$>$\+::name} \index{Assembly\+Helper@{Assembly\+Helper}!c\+\_\+omega@{c\+\_\+omega}}
\index{c\+\_\+omega@{c\+\_\+omega}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{c\+\_\+omega}{c_omega}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$std\+::tuple$<$const double, unsigned int$>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::c\+\_\+omega\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a75e6f76c0b12b91c5feb230251f0137f}{}\label{class_assembly_helper_a75e6f76c0b12b91c5feb230251f0137f}
This member contains information about how domain related dependent fields $e^\Omega_\lambda$ are related to independent scalars. In particular, it relates scalar functional related independent scalar indices to terms $c^\Omega_{\lambda\iota} C_\iota$ (see \hyperlink{class_dependent_field_3_01spacedim_00_01spacedim_01_4}{Dependent\+Field$<$spacedim, spacedim$>$} for further information).

\hyperlink{class_assembly_helper_a75e6f76c0b12b91c5feb230251f0137f}{Assembly\+Helper\+::c\+\_\+omega}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the domain portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_a75e6f76c0b12b91c5feb230251f0137f}{Assembly\+Helper\+::c\+\_\+omega}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $c^\Omega_{\lambda\iota} C_\iota$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_a75e6f76c0b12b91c5feb230251f0137f}{Assembly\+Helper\+::c\+\_\+omega}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $c^\Omega_{\lambda\iota}$, and {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_a75e6f76c0b12b91c5feb230251f0137f}{Assembly\+Helper\+::c\+\_\+omega}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the scalar functional related independent scalar index corresponding to the independent scalar $C_\iota$ \index{Assembly\+Helper@{Assembly\+Helper}!c\+\_\+sigma@{c\+\_\+sigma}}
\index{c\+\_\+sigma@{c\+\_\+sigma}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{c\+\_\+sigma}{c_sigma}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$ std\+::vector$<$std\+::tuple$<$const double, unsigned int$>$ $>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::c\+\_\+sigma\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ab3d4370661ba726010ee687ef0e98140}{}\label{class_assembly_helper_ab3d4370661ba726010ee687ef0e98140}
This member contains information about how interface related dependent fields $e^\Sigma_\nu$ are related to independent scalars. In particular, it relates scalar functional related independent scalar indices to terms $c^\Sigma_{\nu\iota} C_\iota$ (see \hyperlink{class_dependent_field}{Dependent\+Field} for further information).

\hyperlink{class_assembly_helper_ab3d4370661ba726010ee687ef0e98140}{Assembly\+Helper\+::c\+\_\+sigma}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} is used for the evaluation of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the interface (sub)portion with internal index {\ttfamily u}.

Each \hyperlink{class_assembly_helper_ab3d4370661ba726010ee687ef0e98140}{Assembly\+Helper\+::c\+\_\+sigma}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]} corresponds to a single term $c^\Sigma_{\nu\iota} C_\iota$, where {\ttfamily get$<${\ttfamily 0$>$}(\hyperlink{class_assembly_helper_ab3d4370661ba726010ee687ef0e98140}{Assembly\+Helper\+::c\+\_\+sigma}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the coefficient $c^\Sigma_{\nu\iota}$, and {\ttfamily get$<${\ttfamily 1$>$}(\hyperlink{class_assembly_helper_ab3d4370661ba726010ee687ef0e98140}{Assembly\+Helper\+::c\+\_\+sigma}}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]}\mbox{[}{\ttfamily l}\mbox{]}) is the scalar functional related independent scalar index corresponding to the independent scalar $C_\iota$ \index{Assembly\+Helper@{Assembly\+Helper}!component\+\_\+names\+\_\+domain@{component\+\_\+names\+\_\+domain}}
\index{component\+\_\+names\+\_\+domain@{component\+\_\+names\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{component\+\_\+names\+\_\+domain}{component_names_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::pair$<$std\+::string, unsigned int$>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::component\+\_\+names\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_af5e29448f133863a1859be8bfbb300c6}{}\label{class_assembly_helper_af5e29448f133863a1859be8bfbb300c6}
\hyperlink{class_assembly_helper_af5e29448f133863a1859be8bfbb300c6}{Assembly\+Helper\+::component\+\_\+names\+\_\+domain}\mbox{[}{\ttfamily i}\mbox{]} is a name (name characterized by string and component) for the global component with global index {\ttfamily i} on the domain. This name is formed from the pair (\hyperlink{class_independent_field_ae05f8565e4ce1a70b5b833555dc084b5}{Independent\+Field\+::name}, {\ttfamily component}) of the underlying domain related independent field. The name is used to identify independent fields in output. \index{Assembly\+Helper@{Assembly\+Helper}!component\+\_\+names\+\_\+interface@{component\+\_\+names\+\_\+interface}}
\index{component\+\_\+names\+\_\+interface@{component\+\_\+names\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{component\+\_\+names\+\_\+interface}{component_names_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::pair$<$std\+::string, unsigned int$>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::component\+\_\+names\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a7ae6ae2ec356cbb7b830d968315d280c}{}\label{class_assembly_helper_a7ae6ae2ec356cbb7b830d968315d280c}
\hyperlink{class_assembly_helper_a7ae6ae2ec356cbb7b830d968315d280c}{Assembly\+Helper\+::component\+\_\+names\+\_\+interface}\mbox{[}{\ttfamily i}\mbox{]} is a name (name characterized by string and component) for the global component with global index {\ttfamily i} on the interface. This name is formed from the pair (\hyperlink{class_independent_field_ae05f8565e4ce1a70b5b833555dc084b5}{Independent\+Field\+::name}, {\ttfamily component}) of the underlying interface related independent field. The name is used to identify independent fields in output. \index{Assembly\+Helper@{Assembly\+Helper}!components\+\_\+to\+\_\+shapefuns\+\_\+domain@{components\+\_\+to\+\_\+shapefuns\+\_\+domain}}
\index{components\+\_\+to\+\_\+shapefuns\+\_\+domain@{components\+\_\+to\+\_\+shapefuns\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{components\+\_\+to\+\_\+shapefuns\+\_\+domain}{components_to_shapefuns_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::components\+\_\+to\+\_\+shapefuns\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a0bdb6e2e2f9623f3f10dfa2ebe8e234c}{}\label{class_assembly_helper_a0bdb6e2e2f9623f3f10dfa2ebe8e234c}
Mapping between global components of domain related {\bf F\+E\+System}\textquotesingle{}s (which are stored in \hyperlink{class_assembly_helper_af3803b0aad9853e6bf018c70be41e791}{Assembly\+Helper\+::fe\+\_\+collection\+\_\+domain}) and local shape function indices. \hyperlink{class_assembly_helper_a0bdb6e2e2f9623f3f10dfa2ebe8e234c}{Assembly\+Helper\+::components\+\_\+to\+\_\+shapefuns\+\_\+domain}\mbox{[}{\ttfamily i}\mbox{]}\mbox{[}{\ttfamily j}\mbox{]} contains the local shape function indices of shape functions contributing to the global component {\ttfamily j} of the {\ttfamily i-\/th} {\bf F\+E\+System} in \hyperlink{class_assembly_helper_af3803b0aad9853e6bf018c70be41e791}{Assembly\+Helper\+::fe\+\_\+collection\+\_\+domain}. \index{Assembly\+Helper@{Assembly\+Helper}!components\+\_\+to\+\_\+shapefuns\+\_\+domain\+\_\+facewise@{components\+\_\+to\+\_\+shapefuns\+\_\+domain\+\_\+facewise}}
\index{components\+\_\+to\+\_\+shapefuns\+\_\+domain\+\_\+facewise@{components\+\_\+to\+\_\+shapefuns\+\_\+domain\+\_\+facewise}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{components\+\_\+to\+\_\+shapefuns\+\_\+domain\+\_\+facewise}{components_to_shapefuns_domain_facewise}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::components\+\_\+to\+\_\+shapefuns\+\_\+domain\+\_\+facewise\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ae92560183f1d2060265f0744a84f0349}{}\label{class_assembly_helper_ae92560183f1d2060265f0744a84f0349}
This member is similar to \hyperlink{class_assembly_helper_a0bdb6e2e2f9623f3f10dfa2ebe8e234c}{Assembly\+Helper\+::components\+\_\+to\+\_\+shapefuns\+\_\+domain}. However, the information is additionally broken down in cell faces. In particular, \hyperlink{class_assembly_helper_ae92560183f1d2060265f0744a84f0349}{Assembly\+Helper\+::components\+\_\+to\+\_\+shapefuns\+\_\+domain\+\_\+facewise}\mbox{[}{\ttfamily i}\mbox{]}\mbox{[}{\ttfamily j}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} contains the indices of shape functions related to the global component {\ttfamily j} of the {\ttfamily i-\/th} {\bf F\+E\+System} in \hyperlink{class_assembly_helper_af3803b0aad9853e6bf018c70be41e791}{Assembly\+Helper\+::fe\+\_\+collection\+\_\+domain} which have support on face {\ttfamily k}.

It is noted that not all shape functions included in \hyperlink{class_assembly_helper_a0bdb6e2e2f9623f3f10dfa2ebe8e234c}{Assembly\+Helper\+::components\+\_\+to\+\_\+shapefuns\+\_\+domain}\mbox{[}{\ttfamily i}\mbox{]}\mbox{[}{\ttfamily j}\mbox{]} may be present in \hyperlink{class_assembly_helper_ae92560183f1d2060265f0744a84f0349}{Assembly\+Helper\+::components\+\_\+to\+\_\+shapefuns\+\_\+domain\+\_\+facewise}\mbox{[}{\ttfamily i}\mbox{]}\mbox{[}{\ttfamily j}\mbox{]} because there may be shape functions which don\textquotesingle{}t have support on a face or which are not associated with support points at all.

The main use of this data structure is to facilitate the assembly of Dirichlet type constraints imposed on domain related independent fields on interfaces (such constraints can only be applied directly if the shape functions related to the constrained independent field are associated with support points). \index{Assembly\+Helper@{Assembly\+Helper}!components\+\_\+to\+\_\+shapefuns\+\_\+interface@{components\+\_\+to\+\_\+shapefuns\+\_\+interface}}
\index{components\+\_\+to\+\_\+shapefuns\+\_\+interface@{components\+\_\+to\+\_\+shapefuns\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{components\+\_\+to\+\_\+shapefuns\+\_\+interface}{components_to_shapefuns_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::components\+\_\+to\+\_\+shapefuns\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_abcad51e64347fc3141d2840a2835b46c}{}\label{class_assembly_helper_abcad51e64347fc3141d2840a2835b46c}
Mapping between global components of interface related {\bf F\+E\+System}\textquotesingle{}s (which are stored in \hyperlink{class_assembly_helper_a8b4d224a9ecd2e926a8860829874d2a1}{Assembly\+Helper\+::fe\+\_\+collection\+\_\+interface}) and local shape function indices. \hyperlink{class_assembly_helper_abcad51e64347fc3141d2840a2835b46c}{Assembly\+Helper\+::components\+\_\+to\+\_\+shapefuns\+\_\+interface}\mbox{[}{\ttfamily i}\mbox{]}\mbox{[}{\ttfamily j}\mbox{]} contains the local shape function indices of shape functions contributing to the global component {\ttfamily j} of the {\ttfamily i-\/th} {\bf F\+E\+System} in \hyperlink{class_assembly_helper_a8b4d224a9ecd2e926a8860829874d2a1}{Assembly\+Helper\+::fe\+\_\+collection\+\_\+interface}. \index{Assembly\+Helper@{Assembly\+Helper}!contributions\+\_\+scalar\+\_\+functionals\+\_\+domain\+\_\+total\+\_\+potential@{contributions\+\_\+scalar\+\_\+functionals\+\_\+domain\+\_\+total\+\_\+potential}}
\index{contributions\+\_\+scalar\+\_\+functionals\+\_\+domain\+\_\+total\+\_\+potential@{contributions\+\_\+scalar\+\_\+functionals\+\_\+domain\+\_\+total\+\_\+potential}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{contributions\+\_\+scalar\+\_\+functionals\+\_\+domain\+\_\+total\+\_\+potential}{contributions_scalar_functionals_domain_total_potential}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf Smart\+Pointer}$<$const {\bf Scalar\+Functional}$<$spacedim, spacedim$>$ $>$, std\+::vector$<$std\+::pair$<$const unsigned int, const unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::contributions\+\_\+scalar\+\_\+functionals\+\_\+domain\+\_\+total\+\_\+potential\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_aceaf7ba62dfe0fa06ecb15ee8c14da34}{}\label{class_assembly_helper_aceaf7ba62dfe0fa06ecb15ee8c14da34}
Map between domain related scalar functionals and a vector of pairs of (\char`\"{}contribution to total potential\char`\"{}, \char`\"{}scalar functional index within contribution to total potential\char`\"{}), where \char`\"{}contribution to total potential\char`\"{} is an index into \hyperlink{class_total_potential_a5a14ce0e2fabf8116566aa67fb11db35}{Total\+Potential\+::total\+\_\+potential\+\_\+contributions} and \char`\"{}scalar functional index within contribution to total potential\char`\"{} is an index into \hyperlink{class_total_potential_contribution_a15191539345978a3d0c7293bd7ecaa91}{Total\+Potential\+Contribution\+::\+H\+\_\+omega}. This member essentially describes how a domain related scalar functional factors into the \hyperlink{class_total_potential}{Total\+Potential} \index{Assembly\+Helper@{Assembly\+Helper}!contributions\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+total\+\_\+potential@{contributions\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+total\+\_\+potential}}
\index{contributions\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+total\+\_\+potential@{contributions\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+total\+\_\+potential}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{contributions\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+total\+\_\+potential}{contributions_scalar_functionals_interface_total_potential}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf Smart\+Pointer}$<$const {\bf Scalar\+Functional}$<$spacedim-\/1, spacedim$>$ $>$, std\+::vector$<$std\+::pair$<$const unsigned int, const unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::contributions\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+total\+\_\+potential\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a9e76874224ab4946218fdce9bdba0e03}{}\label{class_assembly_helper_a9e76874224ab4946218fdce9bdba0e03}
Map between interface related scalar functionals and a vector of pairs of (\char`\"{}contribution to total potential\char`\"{}, \char`\"{}scalar functional index within contribution to total potential\char`\"{}), where \char`\"{}contribution to total potential\char`\"{} is an index into \hyperlink{class_total_potential_a5a14ce0e2fabf8116566aa67fb11db35}{Total\+Potential\+::total\+\_\+potential\+\_\+contributions} and \char`\"{}scalar functional index within contribution to total potential\char`\"{} is an index into \hyperlink{class_total_potential_contribution_aac404e3a8493d9170541e34bd96673d3}{Total\+Potential\+Contribution\+::\+H\+\_\+sigma} (but shifted by the size of \hyperlink{class_total_potential_contribution_a15191539345978a3d0c7293bd7ecaa91}{Total\+Potential\+Contribution\+::\+H\+\_\+omega}). This member essentially describes how an interface related scalar functional factors into the \hyperlink{class_total_potential}{Total\+Potential} \index{Assembly\+Helper@{Assembly\+Helper}!coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain@{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}}
\index{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain@{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}{coupled_C_indices_scalar_functionals_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a0edd25820c92a25ae87fc240f4916804}{}\label{class_assembly_helper_a0edd25820c92a25ae87fc240f4916804}
This member contains information about the independent scalars coupling for a certain domain related scalar functional (see \hyperlink{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}{Assembly\+Helper\+::C} and \hyperlink{class_assembly_helper_a9a8f0e8ea8c67ce9429c16a2017cafdc}{Assembly\+Helper\+::global\+\_\+indices\+\_\+C} for the global indexing of the independent scalars). Essentially, this data structure transforms the global indexing of independent scalars into a scalar functional related independent scalar indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.

\hyperlink{class_assembly_helper_a0edd25820c92a25ae87fc240f4916804}{Assembly\+Helper\+::coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]} contains all global independent scalar indices coupling for the {\ttfamily v-\/th} scalar functional on the domain portion with internal index {\ttfamily u} (the ordering of the scalar functionals on the domain portion with internal index {\ttfamily u} is given by \hyperlink{class_assembly_helper_aa6fa619e4c2582e95950e878cd06628e}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain}\mbox{[}{\ttfamily u}\mbox{]}).

See also \hyperlink{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain} for further explanations regarding the relevance of this data structure.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000003}{Todo}]This data structure contains redundancy because the way how the independent scalars couple for a certain scalar functional does not depend on the domain portion. This redundancy has initially been introduced to allow for a consistent treatment of cell related dofs and independent scalar related dofs. However, its should be eliminated in later releases.\end{DoxyRefDesc}
\index{Assembly\+Helper@{Assembly\+Helper}!coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface@{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}}
\index{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface@{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}{coupled_C_indices_scalar_functionals_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a311e176038ee2b7ca0719abb384ca57b}{}\label{class_assembly_helper_a311e176038ee2b7ca0719abb384ca57b}
This member contains information about the independent scalars coupling for a certain interface related scalar functional (see \hyperlink{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}{Assembly\+Helper\+::C} and \hyperlink{class_assembly_helper_a9a8f0e8ea8c67ce9429c16a2017cafdc}{Assembly\+Helper\+::global\+\_\+indices\+\_\+C} for the indexing of the independent scalars). Essentially, this data structure transforms the global indexing of independent scalars into a scalar functional related independent scalar indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.

\hyperlink{class_assembly_helper_a311e176038ee2b7ca0719abb384ca57b}{Assembly\+Helper\+::coupled\+\_\+\+C\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]} contains all global independent scalar indices coupling for the {\ttfamily v-\/th} scalar functional on the interface portion with internal index {\ttfamily u} (the ordering of the scalar functionals on the interface portion with internal index {\ttfamily u} is given by \hyperlink{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface}\mbox{[}{\ttfamily u}\mbox{]}).

See also \hyperlink{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain} for further explanations regarding the relevance of this data structure.

\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000004}{Todo}]This data structure contains redundancy because the way how the independent scalars couple for a certain scalar functional does not depend on the interface portion. This redundancy has initially been introduced to allow for a consistent treatment of cell related dofs and independent scalar related dofs. However, its should be eliminated in later releases. \end{DoxyRefDesc}
\index{Assembly\+Helper@{Assembly\+Helper}!coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain@{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}}
\index{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain@{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}{coupled_dof_indices_scalar_functionals_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{}\label{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}
This member contains information about the shape functions coupling for a certain domain related scalar functional. Essentially, this data structure transforms the cell related indexing of shape functions of deal.\+II into a scalar functional related shape function indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.

\hyperlink{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]} contains all (cell related) dof indices which couple for the {\ttfamily v-\/th} scalar functional on the domain portion with internal index {\ttfamily u} (the ordering of the scalar functionals on the domain portion with internal index {\ttfamily u} is given by \hyperlink{class_assembly_helper_aa6fa619e4c2582e95950e878cd06628e}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain}\mbox{[}{\ttfamily u}\mbox{]}).

Using this data structure it is e.\+g. possible to make sure that only those entries are included in the sparsity pattern which are really needed. As an example, consider the case that there are two domain related scalar functionals $H^\Omega_1[e^\Omega_1(u^\Omega_1, u^\Omega_2)]$ and $H^\Omega_2[e^\Omega_2(u^\Omega_2, u^\Omega_3)]$. For this case, the shape functions related to $u^\Omega_1$ will couple to those related to $u^\Omega_2$; and the shape functions related to $u^\Omega_2$ will couple to those related to $u^\Omega_3$; however there is no coupling between $u^\Omega_1$ and $u^\Omega_3$. The standard approach of assuming that all shape functions living on a certain cell couple would miss this subtlety and allocate entries in the finite element system matrix which are always zero. However, by using the scalar functional related shape function indexing provided by the member \hyperlink{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain} this is avoided. \index{Assembly\+Helper@{Assembly\+Helper}!coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface@{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}}
\index{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface@{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}{coupled_dof_indices_scalar_functionals_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ab346e146cf91fb7a0688076551b37355}{}\label{class_assembly_helper_ab346e146cf91fb7a0688076551b37355}
This member contains information about the shape functions of an interface cell coupling for a certain interface related scalar functional. Essentially, this data structure transforms the cell related indexing of shape functions of deal.\+II into a scalar functional related shape function indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.

\hyperlink{class_assembly_helper_ab346e146cf91fb7a0688076551b37355}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]} contains all (cell related) dof indices of an interface cell which couple for the {\ttfamily v-\/th} scalar functional on the interface portion with internal index {\ttfamily u} (the ordering of the scalar functionals on the interface portion with internal index {\ttfamily u} is given by \hyperlink{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface}\mbox{[}{\ttfamily u}\mbox{]}).

See also \hyperlink{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain} for further explanations regarding the relevance of this data structure. \index{Assembly\+Helper@{Assembly\+Helper}!coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+minus@{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+minus}}
\index{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+minus@{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+minus}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+minus}{coupled_dof_indices_scalar_functionals_interface_minus}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+minus\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a12299d82365553a21fef8529c8fe8a17}{}\label{class_assembly_helper_a12299d82365553a21fef8529c8fe8a17}
This member contains information about the shape functions of a domain cell on the minus side of the interface coupling for a certain interface related scalar functional. Essentially, this data structure transforms the cell related indexing of shape functions of deal.\+II into a scalar functional related shape function indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.

\hyperlink{class_assembly_helper_a12299d82365553a21fef8529c8fe8a17}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+minus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]} contains all (cell related) dof indices of a domain cell on the minus side of the interface which couple for the {\ttfamily v-\/th} scalar functional on the interface portion with internal index {\ttfamily u} (the ordering of the scalar functionals on the interface portion with internal index {\ttfamily u} is given by \hyperlink{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface}\mbox{[}{\ttfamily u}\mbox{]}).

See also \hyperlink{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain} for further explanations regarding the relevance of this data structure. \index{Assembly\+Helper@{Assembly\+Helper}!coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+plus@{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+plus}}
\index{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+plus@{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+plus}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+plus}{coupled_dof_indices_scalar_functionals_interface_plus}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+plus\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_af07bb528fdd350e9b467b08dc44a03e7}{}\label{class_assembly_helper_af07bb528fdd350e9b467b08dc44a03e7}
This member contains information about the shape functions of a domain cell on the plus side of the interface coupling for a certain interface related scalar functional. Essentially, this data structure transforms the cell related indexing of shape functions of deal.\+II into a scalar functional related shape function indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.

\hyperlink{class_assembly_helper_af07bb528fdd350e9b467b08dc44a03e7}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+interface\+\_\+plus}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]} contains all (cell related) dof indices of a domain cell on the plus side of the interface which couple for the {\ttfamily v-\/th} scalar functional on the interface portion with internal index {\ttfamily u} (the ordering of the scalar functionals on the interface portion with internal index {\ttfamily u} is given by \hyperlink{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface}\mbox{[}{\ttfamily u}\mbox{]}).

See also \hyperlink{class_assembly_helper_a1a26b40224e3f04e5168accc91486493}{Assembly\+Helper\+::coupled\+\_\+dof\+\_\+indices\+\_\+scalar\+\_\+functionals\+\_\+domain} for further explanations regarding the relevance of this data structure. \index{Assembly\+Helper@{Assembly\+Helper}!d\+\_\+omega@{d\+\_\+omega}}
\index{d\+\_\+omega@{d\+\_\+omega}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{d\+\_\+omega}{d_omega}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$double$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::d\+\_\+omega\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ad93b109608d4425d318434e01cb6246c}{}\label{class_assembly_helper_ad93b109608d4425d318434e01cb6246c}
This member contains information about the constant terms $d^\Omega_\lambda$ of domain related dependent fields $e^\Omega_\lambda$. (see \hyperlink{class_dependent_field_3_01spacedim_00_01spacedim_01_4}{Dependent\+Field$<$spacedim, spacedim$>$} for further information).

\hyperlink{class_assembly_helper_ad93b109608d4425d318434e01cb6246c}{Assembly\+Helper\+::d\+\_\+omega}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} contains $d^\Omega_\lambda$ of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the domain portion with internal index {\ttfamily u}. For computation of a dependent variable $d^\Omega_{\lambda}$ is added to the other contributions to the dependent variable. \index{Assembly\+Helper@{Assembly\+Helper}!d\+\_\+sigma@{d\+\_\+sigma}}
\index{d\+\_\+sigma@{d\+\_\+sigma}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{d\+\_\+sigma}{d_sigma}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::vector$<$double$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::d\+\_\+sigma\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a48d7d677120eb1c84b4983f470246e02}{}\label{class_assembly_helper_a48d7d677120eb1c84b4983f470246e02}
This member contains information about the constant terms $d^\Sigma_\nu$ of domain related dependent fields $e^\Omega_\lambda$. (see \hyperlink{class_dependent_field}{Dependent\+Field} for further information).

\hyperlink{class_assembly_helper_a48d7d677120eb1c84b4983f470246e02}{Assembly\+Helper\+::d\+\_\+sigma}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} contains $d^\Sigma_\nu$ of the {\ttfamily k-\/th} dependent variable of the {\ttfamily v-\/th} scalar functional on the interface (sub)portion with internal index {\ttfamily u}. For computation of a dependent variable $d^\Sigma_{\nu}$ is added to the other contributions to the dependent variable. \index{Assembly\+Helper@{Assembly\+Helper}!dof\+\_\+handler\+\_\+system@{dof\+\_\+handler\+\_\+system}}
\index{dof\+\_\+handler\+\_\+system@{dof\+\_\+handler\+\_\+system}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{dof\+\_\+handler\+\_\+system}{dof_handler_system}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ {\bf Do\+F\+Handler\+System}$<$spacedim$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::dof\+\_\+handler\+\_\+system\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a885e660c749e91a35e3279643ebcd87f}{}\label{class_assembly_helper_a885e660c749e91a35e3279643ebcd87f}
The \hyperlink{class_do_f_handler_system}{Do\+F\+Handler\+System} \index{Assembly\+Helper@{Assembly\+Helper}!fe\+\_\+collection\+\_\+domain@{fe\+\_\+collection\+\_\+domain}}
\index{fe\+\_\+collection\+\_\+domain@{fe\+\_\+collection\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{fe\+\_\+collection\+\_\+domain}{fe_collection_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ {\bf hp\+::\+F\+E\+Collection}$<$spacedim, spacedim$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::fe\+\_\+collection\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_af3803b0aad9853e6bf018c70be41e791}{}\label{class_assembly_helper_af3803b0aad9853e6bf018c70be41e791}
{\bf hp\+::\+F\+E\+Collection} to be used on domain. This contains the finite element systems to be used for different domain portions identified by different {\bf types\+::material\+\_\+id}s.

The components of the finite element systems are sorted according to \hyperlink{class_assembly_helper_a6dae4b6ae7934eaec1ad7baff258ce6e}{Assembly\+Helper\+::global\+\_\+component\+\_\+indices\+\_\+u\+\_\+omega}. \index{Assembly\+Helper@{Assembly\+Helper}!fe\+\_\+collection\+\_\+interface@{fe\+\_\+collection\+\_\+interface}}
\index{fe\+\_\+collection\+\_\+interface@{fe\+\_\+collection\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{fe\+\_\+collection\+\_\+interface}{fe_collection_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ {\bf hp\+::\+F\+E\+Collection}$<$spacedim-\/1, spacedim$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::fe\+\_\+collection\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a8b4d224a9ecd2e926a8860829874d2a1}{}\label{class_assembly_helper_a8b4d224a9ecd2e926a8860829874d2a1}
{\bf hp\+::\+F\+E\+Collection} for interface. This contains the finite element systems to be used for different interface portions identified by different {\bf types\+::material\+\_\+id}s.

The components of the finite element systems are sorted according to \hyperlink{class_assembly_helper_a992a53a1fcac8a393ca53fb8d504bdfe}{Assembly\+Helper\+::global\+\_\+component\+\_\+indices\+\_\+u\+\_\+sigma}. \index{Assembly\+Helper@{Assembly\+Helper}!fe\+\_\+values\+\_\+domain@{fe\+\_\+values\+\_\+domain}}
\index{fe\+\_\+values\+\_\+domain@{fe\+\_\+values\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{fe\+\_\+values\+\_\+domain}{fe_values_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::shared\+\_\+ptr$<${\bf F\+E\+Values}$<$spacedim, spacedim$>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::fe\+\_\+values\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a904a24f53b66e1c1ef89f1bb7989eb32}{}\label{class_assembly_helper_a904a24f53b66e1c1ef89f1bb7989eb32}
{\bf F\+E\+Values} objects needed for evaluation of scalar functionals on domain cells.

\hyperlink{class_assembly_helper_a904a24f53b66e1c1ef89f1bb7989eb32}{Assembly\+Helper\+::fe\+\_\+values\+\_\+domain}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]} is used for the evaluation of the {\ttfamily v-\/th} scalar functional on the domain portion with internal index {\ttfamily u}.

Using a shared pointer here allows to re-\/use {\bf F\+E\+Values} objects if there are several scalar functionals defined on a certain domain portion and the integration of two or more of these scalar functionals is done based on the same quadrature rule. \index{Assembly\+Helper@{Assembly\+Helper}!fe\+\_\+values\+\_\+domain\+\_\+reinit@{fe\+\_\+values\+\_\+domain\+\_\+reinit}}
\index{fe\+\_\+values\+\_\+domain\+\_\+reinit@{fe\+\_\+values\+\_\+domain\+\_\+reinit}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{fe\+\_\+values\+\_\+domain\+\_\+reinit}{fe_values_domain_reinit}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::set$<$std\+::shared\+\_\+ptr$<${\bf F\+E\+Values}$<$spacedim, spacedim$>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::fe\+\_\+values\+\_\+domain\+\_\+reinit\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a28b58551c6afc68c7beaaa2604bc6e92}{}\label{class_assembly_helper_a28b58551c6afc68c7beaaa2604bc6e92}
\hyperlink{class_assembly_helper_a28b58551c6afc68c7beaaa2604bc6e92}{Assembly\+Helper\+::fe\+\_\+values\+\_\+domain\+\_\+reinit}\mbox{[}{\ttfamily i}\mbox{]} contains the {\bf F\+E\+Values} objects for the domain portion with internal index {\ttfamily i}, which are actually needed when a particular cell of this domain portion is visited. By using this data structure, multiple initializations of {\bf F\+E\+Values} objects with the same cell are avoided. \index{Assembly\+Helper@{Assembly\+Helper}!fe\+\_\+values\+\_\+domain\+\_\+reinit\+\_\+nonprimitive@{fe\+\_\+values\+\_\+domain\+\_\+reinit\+\_\+nonprimitive}}
\index{fe\+\_\+values\+\_\+domain\+\_\+reinit\+\_\+nonprimitive@{fe\+\_\+values\+\_\+domain\+\_\+reinit\+\_\+nonprimitive}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{fe\+\_\+values\+\_\+domain\+\_\+reinit\+\_\+nonprimitive}{fe_values_domain_reinit_nonprimitive}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::set$<$std\+::shared\+\_\+ptr$<${\bf F\+E\+Values}$<$spacedim, spacedim$>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::fe\+\_\+values\+\_\+domain\+\_\+reinit\+\_\+nonprimitive\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a3c592ef0a148753891cc3e03fd08324c}{}\label{class_assembly_helper_a3c592ef0a148753891cc3e03fd08324c}
The same as \hyperlink{class_assembly_helper_a28b58551c6afc68c7beaaa2604bc6e92}{Assembly\+Helper\+::fe\+\_\+values\+\_\+domain\+\_\+reinit}, but only contains those {\bf F\+E\+Values} objects needed for evaluation of scalar functionals entering non-\/primitively into the total potential \index{Assembly\+Helper@{Assembly\+Helper}!fe\+\_\+values\+\_\+interface@{fe\+\_\+values\+\_\+interface}}
\index{fe\+\_\+values\+\_\+interface@{fe\+\_\+values\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{fe\+\_\+values\+\_\+interface}{fe_values_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$std\+::shared\+\_\+ptr$<${\bf F\+E\+Values\+Interface}$<$spacedim$>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::fe\+\_\+values\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ae1e2643696005415d78421882ca80e8e}{}\label{class_assembly_helper_ae1e2643696005415d78421882ca80e8e}
{\bf F\+E\+Values} objects needed for evaluation of scalar functionals on interface cells

\hyperlink{class_assembly_helper_ae1e2643696005415d78421882ca80e8e}{Assembly\+Helper\+::fe\+\_\+values\+\_\+interface}\mbox{[}{\ttfamily u}\mbox{]}\mbox{[}{\ttfamily v}\mbox{]} is used for the evaluation of the {\ttfamily v-\/th} scalar functional on the interface (sub)portion with internal index {\ttfamily u}.

\begin{DoxyNote}{Note}
Using a shared pointers here allows to re-\/use \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface} objects, see also the note to \hyperlink{class_assembly_helper_a904a24f53b66e1c1ef89f1bb7989eb32}{Assembly\+Helper\+::fe\+\_\+values\+\_\+domain} 
\end{DoxyNote}
\index{Assembly\+Helper@{Assembly\+Helper}!fe\+\_\+values\+\_\+interface\+\_\+reinit@{fe\+\_\+values\+\_\+interface\+\_\+reinit}}
\index{fe\+\_\+values\+\_\+interface\+\_\+reinit@{fe\+\_\+values\+\_\+interface\+\_\+reinit}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{fe\+\_\+values\+\_\+interface\+\_\+reinit}{fe_values_interface_reinit}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::set$<$std\+::shared\+\_\+ptr$<${\bf F\+E\+Values\+Interface}$<$spacedim$>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::fe\+\_\+values\+\_\+interface\+\_\+reinit\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ac9789c5a00867744dd906b85580e3091}{}\label{class_assembly_helper_ac9789c5a00867744dd906b85580e3091}
\hyperlink{class_assembly_helper_ac9789c5a00867744dd906b85580e3091}{Assembly\+Helper\+::fe\+\_\+values\+\_\+interface\+\_\+reinit}\mbox{[}{\ttfamily i}\mbox{]} contains the \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface} objects for the interface (sub)portion with internal index {\ttfamily i}, which are actually needed when a particular cell of this interface (sub)portion is visited. By using this data structure, multiple initializations of \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface} objects with the same cell are avoided. \index{Assembly\+Helper@{Assembly\+Helper}!fe\+\_\+values\+\_\+interface\+\_\+reinit\+\_\+nonprimitive@{fe\+\_\+values\+\_\+interface\+\_\+reinit\+\_\+nonprimitive}}
\index{fe\+\_\+values\+\_\+interface\+\_\+reinit\+\_\+nonprimitive@{fe\+\_\+values\+\_\+interface\+\_\+reinit\+\_\+nonprimitive}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{fe\+\_\+values\+\_\+interface\+\_\+reinit\+\_\+nonprimitive}{fe_values_interface_reinit_nonprimitive}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::set$<$std\+::shared\+\_\+ptr$<${\bf F\+E\+Values\+Interface}$<$spacedim$>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::fe\+\_\+values\+\_\+interface\+\_\+reinit\+\_\+nonprimitive\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_afaa20027ee539ca8d9c40c317127e471}{}\label{class_assembly_helper_afaa20027ee539ca8d9c40c317127e471}
The same as \hyperlink{class_assembly_helper_ac9789c5a00867744dd906b85580e3091}{Assembly\+Helper\+::fe\+\_\+values\+\_\+interface\+\_\+reinit}, but only contains those \hyperlink{class_f_e_values_interface}{F\+E\+Values\+Interface} objects needed for evaluation of scalar functionals entering non-\/primitively into the total potential \index{Assembly\+Helper@{Assembly\+Helper}!global\+\_\+component\+\_\+indices\+\_\+u\+\_\+omega@{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+omega}}
\index{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+omega@{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+omega}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+omega}{global_component_indices_u_omega}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf Smart\+Pointer}$<$const {\bf Independent\+Field}$<$spacedim, spacedim$>$ $>$, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::global\+\_\+component\+\_\+indices\+\_\+u\+\_\+omega\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a6dae4b6ae7934eaec1ad7baff258ce6e}{}\label{class_assembly_helper_a6dae4b6ae7934eaec1ad7baff258ce6e}
Map between domain related \hyperlink{class_independent_field}{Independent\+Field} objects and global component indices of the respective first components (\char`\"{}global component indices\char`\"{} refers to the indexing of components in \hyperlink{class_assembly_helper_af3803b0aad9853e6bf018c70be41e791}{Assembly\+Helper\+::fe\+\_\+collection\+\_\+domain}). The Independent\+Fields are distinguished by memory address. I.\+e., two different \hyperlink{class_independent_field}{Independent\+Field} objects with the same contents are not considered the same. \index{Assembly\+Helper@{Assembly\+Helper}!global\+\_\+component\+\_\+indices\+\_\+u\+\_\+sigma@{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+sigma}}
\index{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+sigma@{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+sigma}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{global\+\_\+component\+\_\+indices\+\_\+u\+\_\+sigma}{global_component_indices_u_sigma}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf Smart\+Pointer}$<$const {\bf Independent\+Field}$<$spacedim-\/1, spacedim$>$ $>$, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::global\+\_\+component\+\_\+indices\+\_\+u\+\_\+sigma\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a992a53a1fcac8a393ca53fb8d504bdfe}{}\label{class_assembly_helper_a992a53a1fcac8a393ca53fb8d504bdfe}
Map between interface related \hyperlink{class_independent_field}{Independent\+Field} objects and global component indices of the respective first components (\char`\"{}global component indices\char`\"{} refers to the indexing of components in \hyperlink{class_assembly_helper_a8b4d224a9ecd2e926a8860829874d2a1}{Assembly\+Helper\+::fe\+\_\+collection\+\_\+interface}). The Independent\+Fields are distinguished by memory address. I.\+e., two different \hyperlink{class_independent_field}{Independent\+Field} objects with the same contents are not considered the same. \index{Assembly\+Helper@{Assembly\+Helper}!global\+\_\+indices\+\_\+C@{global\+\_\+indices\+\_\+C}}
\index{global\+\_\+indices\+\_\+C@{global\+\_\+indices\+\_\+C}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{global\+\_\+indices\+\_\+C}{global_indices_C}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf Smart\+Pointer}$<$const {\bf Independent\+Field}$<$0, spacedim$>$ $>$, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::global\+\_\+indices\+\_\+C\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a9a8f0e8ea8c67ce9429c16a2017cafdc}{}\label{class_assembly_helper_a9a8f0e8ea8c67ce9429c16a2017cafdc}
Map between independent scalars and \char`\"{}global indices\char`\"{} for the independent scalars. This is essentially the inverse of the member \hyperlink{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}{Assembly\+Helper\+::C} (in that the global index corresponding to a certain independent scalar is the index into \hyperlink{class_assembly_helper_aa5234a46be82cfe7d92678169d38f326}{Assembly\+Helper\+::C} containing this independent scalar). \index{Assembly\+Helper@{Assembly\+Helper}!mapping\+\_\+domain@{mapping\+\_\+domain}}
\index{mapping\+\_\+domain@{mapping\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{mapping\+\_\+domain}{mapping_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const {\bf Smart\+Pointer}$<$const {\bf Mapping}$<$spacedim, spacedim$>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::mapping\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a3fbb49461000dea8f64266f830709fad}{}\label{class_assembly_helper_a3fbb49461000dea8f64266f830709fad}
{\bf Mapping} to be used for domain cells (should be consistent with \hyperlink{class_assembly_helper_a055fde6217c18e62cd80188d0130c201}{Assembly\+Helper\+::mapping\+\_\+interface}) \index{Assembly\+Helper@{Assembly\+Helper}!mapping\+\_\+interface@{mapping\+\_\+interface}}
\index{mapping\+\_\+interface@{mapping\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{mapping\+\_\+interface}{mapping_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const {\bf Smart\+Pointer}$<$const {\bf Mapping}$<$spacedim-\/1, spacedim$>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::mapping\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a055fde6217c18e62cd80188d0130c201}{}\label{class_assembly_helper_a055fde6217c18e62cd80188d0130c201}
{\bf Mapping} to be used for interface cells (should be consistent with \hyperlink{class_assembly_helper_a3fbb49461000dea8f64266f830709fad}{Assembly\+Helper\+::mapping\+\_\+domain}) \index{Assembly\+Helper@{Assembly\+Helper}!material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+domain@{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+domain}}
\index{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+domain@{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+domain}{material_id_to_fe_system_id_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf types\+::material\+\_\+id}, unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a3045f80801fc31920efd161a268aae8e}{}\label{class_assembly_helper_a3045f80801fc31920efd161a268aae8e}
Map between {\bf types\+::material\+\_\+id}s on domain and corresponding fe index in \hyperlink{class_assembly_helper_af3803b0aad9853e6bf018c70be41e791}{Assembly\+Helper\+::fe\+\_\+collection\+\_\+domain} \index{Assembly\+Helper@{Assembly\+Helper}!material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+interface@{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+interface}}
\index{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+interface@{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+interface}{material_id_to_fe_system_id_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf types\+::material\+\_\+id}, unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::material\+\_\+id\+\_\+to\+\_\+fe\+\_\+system\+\_\+id\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a5fea54137e3c1c5a514e39c9b2ad7926}{}\label{class_assembly_helper_a5fea54137e3c1c5a514e39c9b2ad7926}
Map between {\bf types\+::material\+\_\+id}s on interface and corresponding fe index in \hyperlink{class_assembly_helper_a8b4d224a9ecd2e926a8860829874d2a1}{Assembly\+Helper\+::fe\+\_\+collection\+\_\+interface} \index{Assembly\+Helper@{Assembly\+Helper}!material\+\_\+id\+\_\+to\+\_\+internal\+\_\+index\+\_\+domain@{material\+\_\+id\+\_\+to\+\_\+internal\+\_\+index\+\_\+domain}}
\index{material\+\_\+id\+\_\+to\+\_\+internal\+\_\+index\+\_\+domain@{material\+\_\+id\+\_\+to\+\_\+internal\+\_\+index\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{material\+\_\+id\+\_\+to\+\_\+internal\+\_\+index\+\_\+domain}{material_id_to_internal_index_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf types\+::material\+\_\+id}, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::material\+\_\+id\+\_\+to\+\_\+internal\+\_\+index\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a10b3acf64bccc169ee14dc2505ce4b46}{}\label{class_assembly_helper_a10b3acf64bccc169ee14dc2505ce4b46}
Map between the {\bf types\+::material\+\_\+id}s associated with domain cells and a unique \char`\"{}internal material index\char`\"{}, which is assigned upon construction of an \hyperlink{class_assembly_helper}{Assembly\+Helper} object.

Whereas the {\bf types\+::material\+\_\+id}s need not be consecutive numbers, the internal material index is consecutive and starts from zero. This allows to reduce map lookups to a minimum. In particular, if a domain cell is visited during fe system assembly, the internal material index corresponding to the {\bf types\+::material\+\_\+id} is looked up and no further lookups are required afterwards. \index{Assembly\+Helper@{Assembly\+Helper}!material\+\_\+ids\+\_\+to\+\_\+internal\+\_\+index\+\_\+interface@{material\+\_\+ids\+\_\+to\+\_\+internal\+\_\+index\+\_\+interface}}
\index{material\+\_\+ids\+\_\+to\+\_\+internal\+\_\+index\+\_\+interface@{material\+\_\+ids\+\_\+to\+\_\+internal\+\_\+index\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{material\+\_\+ids\+\_\+to\+\_\+internal\+\_\+index\+\_\+interface}{material_ids_to_internal_index_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<$ std\+::tuple$<$ const {\bf types\+::material\+\_\+id}, const {\bf types\+::material\+\_\+id}, const {\bf types\+::material\+\_\+id}$>$, const unsigned int $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::material\+\_\+ids\+\_\+to\+\_\+internal\+\_\+index\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a43b82de0ede96d03b9f7fd8740d81668}{}\label{class_assembly_helper_a43b82de0ede96d03b9f7fd8740d81668}
Map between interface \char`\"{}subportion\char`\"{} (identified by {\bf types\+::material\+\_\+id} of interface, {\bf types\+::material\+\_\+id} of -\/ side and {\bf types\+::material\+\_\+id} of + side) and a unique \char`\"{}internal material index\char`\"{}, which is assigned upon construction of an \hyperlink{class_assembly_helper}{Assembly\+Helper} object.

Whereas the {\bf types\+::material\+\_\+id}s need not be consecutive numbers, the internal material index is consecutive and starts from zero. This allows to reduce map lookups to a minimum. In particular, if an interface cell is visited during fe system assembly, the internal material index corresponding to the {\bf types\+::material\+\_\+id}s of the interface cell and the domain cells on both sides of the interface is looked up and no further lookups are required afterwards.

If an interface subportion is actually a boundary, the third {\bf types\+::material\+\_\+id} in the tuple is {\bf numbers\+::invalid\+\_\+material\+\_\+id}.

It is advantageous to treat every combination of (interface {\bf types\+::material\+\_\+id}, domain {\bf types\+::material\+\_\+id} on -\/ side, domain {\bf types\+::material\+\_\+id} on + side) separately because the finite elements involved in the computation of interface related scalar functionals may be different on different subportions. \index{Assembly\+Helper@{Assembly\+Helper}!n\+\_\+procs@{n\+\_\+procs}}
\index{n\+\_\+procs@{n\+\_\+procs}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{n\+\_\+procs}{n_procs}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::n\+\_\+procs\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a87945d87baf37637673fd124b3803fd5}{}\label{class_assembly_helper_a87945d87baf37637673fd124b3803fd5}
The number of participating processors \index{Assembly\+Helper@{Assembly\+Helper}!n\+\_\+scalar\+\_\+functionals\+\_\+nonprimitive@{n\+\_\+scalar\+\_\+functionals\+\_\+nonprimitive}}
\index{n\+\_\+scalar\+\_\+functionals\+\_\+nonprimitive@{n\+\_\+scalar\+\_\+functionals\+\_\+nonprimitive}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{n\+\_\+scalar\+\_\+functionals\+\_\+nonprimitive}{n_scalar_functionals_nonprimitive}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::n\+\_\+scalar\+\_\+functionals\+\_\+nonprimitive\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_af7bcfc1db651535a7aefc6071a81e124}{}\label{class_assembly_helper_af7bcfc1db651535a7aefc6071a81e124}
Number of scalar functionals entering non-\/primitively into the total potential. This is the sum of the sizes of the maps \hyperlink{class_assembly_helper_acf05fab2ddf57769a103d82a4f2d1cd3}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices} and \hyperlink{class_assembly_helper_a0d15b3ab0c7bec9fc4f40e532f8776f4}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices} \index{Assembly\+Helper@{Assembly\+Helper}!n\+\_\+scalar\+\_\+functionals\+\_\+primitive@{n\+\_\+scalar\+\_\+functionals\+\_\+primitive}}
\index{n\+\_\+scalar\+\_\+functionals\+\_\+primitive@{n\+\_\+scalar\+\_\+functionals\+\_\+primitive}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{n\+\_\+scalar\+\_\+functionals\+\_\+primitive}{n_scalar_functionals_primitive}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::n\+\_\+scalar\+\_\+functionals\+\_\+primitive\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_af5e03e8e47a85dbc96444ef61525c454}{}\label{class_assembly_helper_af5e03e8e47a85dbc96444ef61525c454}
Number of scalar functionals entering primitively into the total potential. This is the the sum of the sizes of the maps \hyperlink{class_assembly_helper_a4f08790a2235e48ce19f5d8d965a7874}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices} and \hyperlink{class_assembly_helper_ad99c75f32cf3f18aa1d4067ad8b56ae8}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface\+\_\+primitive\+\_\+indices} \index{Assembly\+Helper@{Assembly\+Helper}!pout@{pout}}
\index{pout@{pout}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{pout}{pout}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ {\bf Conditional\+O\+Stream} {\bf Assembly\+Helper}$<$ spacedim $>$\+::pout\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a717eb6ebc7c62fe00063edcf264f3ecc}{}\label{class_assembly_helper_a717eb6ebc7c62fe00063edcf264f3ecc}
Stream used for standard output to screen (makes sure that output is printed only on one processor in parallel) \index{Assembly\+Helper@{Assembly\+Helper}!scalar\+\_\+functionals\+\_\+domain@{scalar\+\_\+functionals\+\_\+domain}}
\index{scalar\+\_\+functionals\+\_\+domain@{scalar\+\_\+functionals\+\_\+domain}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{scalar\+\_\+functionals\+\_\+domain}{scalar_functionals_domain}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<${\bf Smart\+Pointer}$<$const {\bf Scalar\+Functional}$<$spacedim, spacedim$>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::scalar\+\_\+functionals\+\_\+domain\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_aa6fa619e4c2582e95950e878cd06628e}{}\label{class_assembly_helper_aa6fa619e4c2582e95950e878cd06628e}
\hyperlink{class_assembly_helper_aa6fa619e4c2582e95950e878cd06628e}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain}\mbox{[}{\ttfamily i}\mbox{]} contains the domain related scalar functionals which have non-\/zero integrands $h^\Omega_\rho$ on the domain portion with internal index {\ttfamily i}. If the contribution of a certain domain cell associated with internal index {\ttfamily i} to the finite element system is to be assembled, it is looped over all scalar functionals contained in \hyperlink{class_assembly_helper_aa6fa619e4c2582e95950e878cd06628e}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain}\mbox{[}{\ttfamily i}\mbox{]}. \index{Assembly\+Helper@{Assembly\+Helper}!scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive@{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive}}
\index{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive@{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive}{scalar_functionals_domain_nonprimitive}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a5fe78a019aec03cbeeb336d1d2874729}{}\label{class_assembly_helper_a5fe78a019aec03cbeeb336d1d2874729}
\hyperlink{class_assembly_helper_aa6fa619e4c2582e95950e878cd06628e}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain}\mbox{[}{\ttfamily i}\mbox{]}\mbox{[} \hyperlink{class_assembly_helper_a5fe78a019aec03cbeeb336d1d2874729}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive}\mbox{[}{\ttfamily i}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} \mbox{]} is the {\ttfamily k-\/th} domain related scalar functional entering non-\/primitively into the total potential (i.\+e., the scalar functional is part of at least one \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution} with the member \hyperlink{class_total_potential_contribution_a45bfb25a7693c949c26e223cf4a1a1e7}{Total\+Potential\+Contribution\+::is\+\_\+primitive} set to {\ttfamily false}) \index{Assembly\+Helper@{Assembly\+Helper}!scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices@{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices}}
\index{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices@{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices}{scalar_functionals_domain_nonprimitive_indices}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf Smart\+Pointer}$<$const {\bf Scalar\+Functional}$<$spacedim, spacedim$>$ $>$, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_acf05fab2ddf57769a103d82a4f2d1cd3}{}\label{class_assembly_helper_acf05fab2ddf57769a103d82a4f2d1cd3}
Map assigning indices to all domain related scalar functionals entering into at least one non-\/primitive \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution}. \index{Assembly\+Helper@{Assembly\+Helper}!scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices@{scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices}}
\index{scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices@{scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices}{scalar_functionals_domain_primitive_indices}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf Smart\+Pointer}$<$const {\bf Scalar\+Functional}$<$spacedim, spacedim$>$ $>$, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a4f08790a2235e48ce19f5d8d965a7874}{}\label{class_assembly_helper_a4f08790a2235e48ce19f5d8d965a7874}
Map assigning indices to all domain related scalar functionals entering into at least one primitive \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution}. \index{Assembly\+Helper@{Assembly\+Helper}!scalar\+\_\+functionals\+\_\+interface@{scalar\+\_\+functionals\+\_\+interface}}
\index{scalar\+\_\+functionals\+\_\+interface@{scalar\+\_\+functionals\+\_\+interface}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{scalar\+\_\+functionals\+\_\+interface}{scalar_functionals_interface}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<${\bf Smart\+Pointer}$<$const {\bf Scalar\+Functional}$<$spacedim-\/1, spacedim$>$ $>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::scalar\+\_\+functionals\+\_\+interface\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}{}\label{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}
\hyperlink{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface}\mbox{[}{\ttfamily i}\mbox{]} contains the interface related scalar functionals which have non-\/zero integrands $h^\Sigma_\tau$ on the interface portion with internal index {\ttfamily i}. If the contribution of a certain interface cell associated with internal index {\ttfamily i} to the finite element system is to be assembled, it is looped over all scalar functionals contained in \hyperlink{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface}\mbox{[}{\ttfamily i}\mbox{]}. \index{Assembly\+Helper@{Assembly\+Helper}!scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive@{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive}}
\index{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive@{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive}{scalar_functionals_interface_nonprimitive}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$std\+::vector$<$unsigned int$>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a833383aa6d157157545204143897ed9e}{}\label{class_assembly_helper_a833383aa6d157157545204143897ed9e}
\hyperlink{class_assembly_helper_a29aa77e0e8e6b35c94966ea88840e462}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface}\mbox{[}{\ttfamily i}\mbox{]}\mbox{[} \hyperlink{class_assembly_helper_a833383aa6d157157545204143897ed9e}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive}\mbox{[}{\ttfamily i}\mbox{]}\mbox{[}{\ttfamily k}\mbox{]} \mbox{]} the {\ttfamily k-\/th} interface related scalar functional entering non-\/primitively into the total potential (i.\+e., the scalar functional is part of at least one \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution} with the member \hyperlink{class_total_potential_contribution_a45bfb25a7693c949c26e223cf4a1a1e7}{Total\+Potential\+Contribution\+::is\+\_\+primitive} set to {\ttfamily false}) \index{Assembly\+Helper@{Assembly\+Helper}!scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices@{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices}}
\index{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices@{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices}{scalar_functionals_interface_nonprimitive_indices}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf Smart\+Pointer}$<$const {\bf Scalar\+Functional}$<$spacedim-\/1, spacedim$>$ $>$, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::scalar\+\_\+functionals\+\_\+interface\+\_\+nonprimitive\+\_\+indices\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a0d15b3ab0c7bec9fc4f40e532f8776f4}{}\label{class_assembly_helper_a0d15b3ab0c7bec9fc4f40e532f8776f4}
Map assigning indices to all interface related scalar functionals entering into at least one non-\/primitive \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution}. Note that the indices here do not start from 0, but rather from \hyperlink{class_assembly_helper_acf05fab2ddf57769a103d82a4f2d1cd3}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain\+\_\+nonprimitive\+\_\+indices} .size(). \index{Assembly\+Helper@{Assembly\+Helper}!scalar\+\_\+functionals\+\_\+interface\+\_\+primitive\+\_\+indices@{scalar\+\_\+functionals\+\_\+interface\+\_\+primitive\+\_\+indices}}
\index{scalar\+\_\+functionals\+\_\+interface\+\_\+primitive\+\_\+indices@{scalar\+\_\+functionals\+\_\+interface\+\_\+primitive\+\_\+indices}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{scalar\+\_\+functionals\+\_\+interface\+\_\+primitive\+\_\+indices}{scalar_functionals_interface_primitive_indices}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::map$<${\bf Smart\+Pointer}$<$const {\bf Scalar\+Functional}$<$spacedim-\/1, spacedim$>$ $>$, const unsigned int$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::scalar\+\_\+functionals\+\_\+interface\+\_\+primitive\+\_\+indices\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_ad99c75f32cf3f18aa1d4067ad8b56ae8}{}\label{class_assembly_helper_ad99c75f32cf3f18aa1d4067ad8b56ae8}
Map assigning indices to all interface related scalar functionals entering into at least one primitive \hyperlink{class_total_potential_contribution}{Total\+Potential\+Contribution}. Note that the indices here do not start from 0, but rather from \hyperlink{class_assembly_helper_a4f08790a2235e48ce19f5d8d965a7874}{Assembly\+Helper\+::scalar\+\_\+functionals\+\_\+domain\+\_\+primitive\+\_\+indices} .size(). \index{Assembly\+Helper@{Assembly\+Helper}!this\+\_\+proc@{this\+\_\+proc}}
\index{this\+\_\+proc@{this\+\_\+proc}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{this\+\_\+proc}{this_proc}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const unsigned int {\bf Assembly\+Helper}$<$ spacedim $>$\+::this\+\_\+proc\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a2aad83ae1bfe5338794cf9b50848469a}{}\label{class_assembly_helper_a2aad83ae1bfe5338794cf9b50848469a}
The id of this processor (which is always zero in sequential computations, and corresponds to the rank of the processor otherwise) \index{Assembly\+Helper@{Assembly\+Helper}!total\+\_\+potential@{total\+\_\+potential}}
\index{total\+\_\+potential@{total\+\_\+potential}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{total\+\_\+potential}{total_potential}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ const {\bf Total\+Potential}$<$spacedim$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::total\+\_\+potential\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a748eed9d73b7437a4bf2dcd73108790b}{}\label{class_assembly_helper_a748eed9d73b7437a4bf2dcd73108790b}
The total potential $\Pi$ \index{Assembly\+Helper@{Assembly\+Helper}!tria\+\_\+listeners@{tria\+\_\+listeners}}
\index{tria\+\_\+listeners@{tria\+\_\+listeners}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{tria\+\_\+listeners}{tria_listeners}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<$boost\+::signals2\+::connection$>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::tria\+\_\+listeners\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a228cec028ab5126d25c3ebf0e12a17a6}{}\label{class_assembly_helper_a228cec028ab5126d25c3ebf0e12a17a6}
A list of connections with which this object connects to the \hyperlink{class_triangulation_system}{Triangulation\+System} \hyperlink{class_do_f_handler_system_a06d93193cb47591db138cd8f41953796}{Do\+F\+Handler\+System\+::tria\+\_\+system} to get notice when it changes. \index{Assembly\+Helper@{Assembly\+Helper}!tria\+\_\+system@{tria\+\_\+system}}
\index{tria\+\_\+system@{tria\+\_\+system}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{tria\+\_\+system}{tria_system}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ {\bf Triangulation\+System}$<$spacedim$>$\& {\bf Assembly\+Helper}$<$ spacedim $>$\+::tria\+\_\+system\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_add08a8a7bb9c9325fcc7d92bfce525d4}{}\label{class_assembly_helper_add08a8a7bb9c9325fcc7d92bfce525d4}
The triangulation system \index{Assembly\+Helper@{Assembly\+Helper}!u\+\_\+omega@{u\+\_\+omega}}
\index{u\+\_\+omega@{u\+\_\+omega}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{u\+\_\+omega}{u_omega}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<${\bf Smart\+Pointer}$<$const {\bf Independent\+Field}$<$spacedim, spacedim$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::u\+\_\+omega\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a1952a054a839a7a683ca108013e7d976}{}\label{class_assembly_helper_a1952a054a839a7a683ca108013e7d976}
vector of domain related independent fields $u^\Omega_\epsilon$ involved in the definition of the total potential \hyperlink{class_assembly_helper_a748eed9d73b7437a4bf2dcd73108790b}{Assembly\+Helper\+::total\+\_\+potential}. These domain related independent fields are sorted by \hyperlink{class_independent_field_ae05f8565e4ce1a70b5b833555dc084b5}{Independent\+Field\+::name} \index{Assembly\+Helper@{Assembly\+Helper}!u\+\_\+sigma@{u\+\_\+sigma}}
\index{u\+\_\+sigma@{u\+\_\+sigma}!Assembly\+Helper@{Assembly\+Helper}}
\subsubsection[{\texorpdfstring{u\+\_\+sigma}{u_sigma}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$unsigned int spacedim$>$ std\+::vector$<${\bf Smart\+Pointer}$<$const {\bf Independent\+Field}$<$spacedim-\/1, spacedim$>$ $>$ $>$ {\bf Assembly\+Helper}$<$ spacedim $>$\+::u\+\_\+sigma\hspace{0.3cm}{\ttfamily [private]}}\hypertarget{class_assembly_helper_a696fe649b3503561235aa1ccbf2ddeef}{}\label{class_assembly_helper_a696fe649b3503561235aa1ccbf2ddeef}
vector of interface related independent fields $u^\Sigma_\eta$ involved in the definition of the total potential \hyperlink{class_assembly_helper_a748eed9d73b7437a4bf2dcd73108790b}{Assembly\+Helper\+::total\+\_\+potential}. These interface related independent fields are sorted by \hyperlink{class_independent_field_ae05f8565e4ce1a70b5b833555dc084b5}{Independent\+Field\+::name} 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/sst/code/\+Galerkin\+Tools/\+Galerkin\+Tools/include/galerkin\+\_\+tools/\hyperlink{assembly__helper_8h}{assembly\+\_\+helper.\+h}\end{DoxyCompactItemize}
