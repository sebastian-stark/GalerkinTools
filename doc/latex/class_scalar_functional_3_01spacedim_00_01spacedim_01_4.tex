\hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4}{}\doxysection{Scalar\+Functional$<$ spacedim, spacedim $>$ Class Template Reference}
\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4}\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}


{\ttfamily \#include $<$scalar\+\_\+functional.\+h$>$}



Inheritance diagram for Scalar\+Functional$<$ spacedim, spacedim $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=238pt]{class_scalar_functional_3_01spacedim_00_01spacedim_01_4__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Scalar\+Functional$<$ spacedim, spacedim $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_scalar_functional_3_01spacedim_00_01spacedim_01_4__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a4c4903b402908f26b8c8b433a7cbeb76}{Scalar\+Functional}} (const std\+::vector$<$ \mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$ spacedim, spacedim $>$$>$ \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{e\+\_\+omega}}, const std\+::set$<$ \textbf{ types\+::material\+\_\+id} $>$ \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_aa192395f822a64f60df43bf9d36c2f3a}{domain\+\_\+of\+\_\+integration}}, const \textbf{ Quadrature}$<$ spacedim $>$ \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ab83ee3ae077b211137824b006098382e}{quadrature}}, const std\+::string \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a195248af3821548af3000872e9e6d00e}{name}}, const unsigned int \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_acee2c3c289e5b2b680996facc2f79e78}{n\+\_\+ref\+\_\+sets}}=0, const unsigned int \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}{n\+\_\+hidden}}=0, const \textbf{ Function}$<$ spacedim $>$ $\ast$const \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ae3282d5182360e0030e4cc5e02fbe2eb}{initial\+\_\+vals\+\_\+hidden}}=nullptr)
\item 
virtual bool \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{get\+\_\+h\+\_\+omega}} (const \textbf{ Vector}$<$ double $>$ \&\mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{e\+\_\+omega}}, const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&e\+\_\+omega\+\_\+ref\+\_\+sets, \textbf{ Vector}$<$ double $>$ \&hidden\+\_\+vars, const \textbf{ Point}$<$ spacedim $>$ \&x, double \&h\+\_\+omega, \textbf{ Vector}$<$ double $>$ \&h\+\_\+omega\+\_\+1, \textbf{ Full\+Matrix}$<$ double $>$ \&h\+\_\+omega\+\_\+2, const std\+::tuple$<$ bool, bool, bool $>$ requested\+\_\+quantities) const =0
\item 
virtual double \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_add1852ebe7ad8b1178063ff725748856}{get\+\_\+maximum\+\_\+step}} (const \textbf{ Vector}$<$ double $>$ \&\mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{e\+\_\+omega}}, const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&e\+\_\+omega\+\_\+ref\+\_\+sets, const \textbf{ Vector}$<$ double $>$ \&delta\+\_\+e\+\_\+omega, const \textbf{ Vector}$<$ double $>$ \&hidden\+\_\+vars, const \textbf{ Point}$<$ spacedim $>$ \&x) const
\item 
virtual void \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a9d98d5f98629c097d73455d8a1fd5643}{modify\+\_\+\+K\+\_\+cell\+\_\+f\+\_\+cell}} (const \mbox{\hyperlink{class_domain_cell_do_f_iterator}{Domain\+Cell\+Do\+F\+Iterator}}$<$ spacedim $>$ \&domain\+\_\+cell, \textbf{ Full\+Matrix}$<$ double $>$ \&K\+\_\+cell, \textbf{ Vector}$<$ double $>$ \&f\+\_\+cell, const std\+::vector$<$ unsigned int $>$ \&scalar\+\_\+functional\+\_\+indices\+\_\+to\+\_\+cell\+\_\+shapefuns, const std\+::vector$<$ unsigned int $>$ \&scalar\+\_\+functional\+\_\+indices\+\_\+to\+\_\+independent\+\_\+scalar\+\_\+indices) const
\item 
void \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ab1cbbd84088b3dae549d152e049240da}{compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives}} (\textbf{ Vector}$<$ double $>$ \&\mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{e\+\_\+omega}}, const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&e\+\_\+omega\+\_\+ref\+\_\+sets, \textbf{ Vector}$<$ double $>$ \&hidden\+\_\+vars, const \textbf{ Point}$<$ spacedim $>$ \&x, const std\+::string detailed\+\_\+printout\+\_\+file=\char`\"{}\char`\"{}, const double \textbf{ epsilon}=1\textbf{ e}-\/8) const
\item 
virtual \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a42b56519b3e4338d248c1e29e29831a6}{$\sim$\+Scalar\+Functional}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
const std\+::set$<$ \textbf{ types\+::material\+\_\+id} $>$ \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_aa192395f822a64f60df43bf9d36c2f3a}{domain\+\_\+of\+\_\+integration}}
\item 
const \textbf{ Smart\+Pointer}$<$ const \textbf{ Function}$<$ spacedim $>$ $>$ \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ae3282d5182360e0030e4cc5e02fbe2eb}{initial\+\_\+vals\+\_\+hidden}}
\item 
const std\+::vector$<$ \mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$ spacedim, spacedim $>$ $>$ \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{e\+\_\+omega}}
\item 
const \textbf{ Quadrature}$<$ spacedim $>$ \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ab83ee3ae077b211137824b006098382e}{quadrature}}
\item 
const unsigned int \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}{n\+\_\+hidden}}
\item 
const std\+::string \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a195248af3821548af3000872e9e6d00e}{name}}
\item 
const unsigned int \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_acee2c3c289e5b2b680996facc2f79e78}{n\+\_\+ref\+\_\+sets}}
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$unsigned int spacedim$>$\newline
class Scalar\+Functional$<$ spacedim, spacedim $>$}

Class defining a domain related scalar functional $H^\Omega_\rho = \int_\Omega h^\Omega_\rho(e^\Omega_\lambda, \boldsymbol{X}) \mathrm{d}V$, where $\rho \in P=\left\{1 \hdots N^\mathrm{H,\Omega}\right\}$.

\char`\"{}\+Hidden\char`\"{} variables involved in the definition of the functions $h^\Omega_\rho$ are allowed for (in order to allow for incorporation of e.\+g. classical plasticity formulations).

The integrand $h^\Omega_\rho$ may, besides the current values of $e^\Omega_\lambda$, also depend on an arbitrary number of sets of \char`\"{}reference values\char`\"{} of $e^\Omega_\lambda$. These reference values can e.\+g. be the values of the $e^\Omega_\lambda$ at previous instants of time. When derivatives of $h^\Omega_\rho$ w.\+r.\+t. the dependent variables are calculated, these reference values are generally regarded as fixed.

In principle, it is often sufficient that the first and second derivatives of $h^\Omega_\rho$ are known, as the values themselves do not factor into the finite element system. However, this depends on the exact problem.

The \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4}{Scalar\+Functional$<$spacedim, spacedim$>$}} class inherits from \textbf{ Subscriptor} in order to be able to check that \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4}{Scalar\+Functional$<$spacedim, spacedim$>$}} objects are only destroyed when they are not needed anymore by other objects.


\begin{DoxyTemplParams}{Template Parameters}
{\em spacedim} & The spatial dimension of the problem \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a4c4903b402908f26b8c8b433a7cbeb76}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a4c4903b402908f26b8c8b433a7cbeb76}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!ScalarFunctional@{ScalarFunctional}}
\index{ScalarFunctional@{ScalarFunctional}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{ScalarFunctional()}{ScalarFunctional()}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
\mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::\mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}} (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$ spacedim, spacedim $>$$>$}]{e\+\_\+omega,  }\item[{const std\+::set$<$ \textbf{ types\+::material\+\_\+id} $>$}]{domain\+\_\+of\+\_\+integration,  }\item[{const \textbf{ Quadrature}$<$ spacedim $>$}]{quadrature,  }\item[{const std\+::string}]{name,  }\item[{const unsigned int}]{n\+\_\+ref\+\_\+sets = {\ttfamily 0},  }\item[{const unsigned int}]{n\+\_\+hidden = {\ttfamily 0},  }\item[{const \textbf{ Function}$<$ spacedim $>$ $\ast$const}]{initial\+\_\+vals\+\_\+hidden = {\ttfamily nullptr} }\end{DoxyParamCaption})}

The constructor of the class


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e\+\_\+omega} & \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{Scalar\+Functional$<$spacedim, spacedim$>$\+::e\+\_\+omega}}\\
\hline
\mbox{\texttt{ in}}  & {\em domain\+\_\+of\+\_\+integration} & \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_aa192395f822a64f60df43bf9d36c2f3a}{Scalar\+Functional$<$spacedim, spacedim$>$\+::domain\+\_\+of\+\_\+integration}}\\
\hline
\mbox{\texttt{ in}}  & {\em quadrature} & \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ab83ee3ae077b211137824b006098382e}{Scalar\+Functional$<$spacedim, spacedim$>$\+::quadrature}}\\
\hline
\mbox{\texttt{ in}}  & {\em name} & \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a195248af3821548af3000872e9e6d00e}{Scalar\+Functional$<$spacedim, spacedim$>$\+::name}}\\
\hline
\mbox{\texttt{ in}}  & {\em n\+\_\+ref\+\_\+sets} & \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_acee2c3c289e5b2b680996facc2f79e78}{Scalar\+Functional$<$spacedim, spacedim$>$\+::n\+\_\+ref\+\_\+sets}}\\
\hline
\mbox{\texttt{ in}}  & {\em n\+\_\+hidden} & \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}{Scalar\+Functional$<$spacedim, spacedim$>$\+::n\+\_\+hidden}}\\
\hline
\mbox{\texttt{ in}}  & {\em initial\+\_\+vals\+\_\+hidden} & \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ae3282d5182360e0030e4cc5e02fbe2eb}{Scalar\+Functional$<$spacedim, spacedim$>$\+::initial\+\_\+vals\+\_\+hidden}} (if {\ttfamily n\+\_\+hidden$>$0} and this argument is omitted, the initial values will be set to zero) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a42b56519b3e4338d248c1e29e29831a6}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a42b56519b3e4338d248c1e29e29831a6}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!````~ScalarFunctional@{$\sim$ScalarFunctional}}
\index{````~ScalarFunctional@{$\sim$ScalarFunctional}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$ScalarFunctional()}{~ScalarFunctional()}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
virtual \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::$\sim$\mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

The destructor of \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4}{Scalar\+Functional$<$spacedim, spacedim$>$}} essentially checks before destruction that the \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4}{Scalar\+Functional$<$spacedim, spacedim$>$}} object is not used by other objects. If this is the case, the program will be aborted. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ab1cbbd84088b3dae549d152e049240da}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ab1cbbd84088b3dae549d152e049240da}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!compare\_derivatives\_with\_numerical\_derivatives@{compare\_derivatives\_with\_numerical\_derivatives}}
\index{compare\_derivatives\_with\_numerical\_derivatives@{compare\_derivatives\_with\_numerical\_derivatives}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{compare\_derivatives\_with\_numerical\_derivatives()}{compare\_derivatives\_with\_numerical\_derivatives()}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
void \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::compare\+\_\+derivatives\+\_\+with\+\_\+numerical\+\_\+derivatives (\begin{DoxyParamCaption}\item[{\textbf{ Vector}$<$ double $>$ \&}]{e\+\_\+omega,  }\item[{const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&}]{e\+\_\+omega\+\_\+ref\+\_\+sets,  }\item[{\textbf{ Vector}$<$ double $>$ \&}]{hidden\+\_\+vars,  }\item[{const \textbf{ Point}$<$ spacedim $>$ \&}]{x,  }\item[{const std\+::string}]{detailed\+\_\+printout\+\_\+file = {\ttfamily \char`\"{}\char`\"{}},  }\item[{const double}]{epsilon = {\ttfamily 1\textbf{ e}-\/8} }\end{DoxyParamCaption}) const}

Function comparing the computed derivatives of the integrand $h^\Omega_\rho$ provided by \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}} with corresponding numerically computed finite difference based derivatives.

In the case of the first derivative, the numerical derivatives are obtained based on the values for $h^\Omega_\rho$ provided by \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}}; and in the case of the second derivatives, the numerical derivatives are obtained based on the values for the first derivatives of $h^\Omega_\rho$ provided by \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}} ). In both cases, a simple forward finite difference approach is used. Generally, the first numerical derivative can only be \char`\"{}correct\char`\"{} if the computation of the value of $h^\Omega_\rho$ is correctly implemented in the function \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}}; and likewise the second numerical derivative can only be \char`\"{}correct\char`\"{} if the computation of the first derivative of $h^\Omega_\rho$ is correctly implemented in the function \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}}.

This function is essentially meant for testing of user defined functions \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}{Scalar\+Functional$<$spacedim, spacedim$>$\+::get\+\_\+h\+\_\+omega()}}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e\+\_\+omega} & Values of $e^\Omega_\lambda$ (the ordering is defined by the ordering of the dependent fields in \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{Scalar\+Functional$<$spacedim, spacedim$>$\+::e\+\_\+omega}})\\
\hline
\mbox{\texttt{ in}}  & {\em e\+\_\+omega\+\_\+ref\+\_\+sets} & Sets of reference values of $e^\Omega_\lambda$ (as required according to \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_acee2c3c289e5b2b680996facc2f79e78}{Scalar\+Functional$<$spacedim, spacedim$>$\+::n\+\_\+ref\+\_\+sets}})\\
\hline
\mbox{\texttt{ in,out}}  & {\em hidden\+\_\+vars} & Values of \char`\"{}hidden\char`\"{} variables associated with the integrand $h^\Omega_\rho$. This vector has the size \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}{Scalar\+Functional$<$spacedim, spacedim$>$\+::n\+\_\+hidden}}.\\
\hline
\mbox{\texttt{ in}}  & {\em x} & Location of material point at which integrand $h^\Omega_\rho$ and derivatives thereof are evaluated\\
\hline
\mbox{\texttt{ in}}  & {\em detailed\+\_\+printout\+\_\+file} & A file to which detailed printout is written if requested\\
\hline
\mbox{\texttt{ in}}  & {\em epsilon} & Step width for finite difference computation \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a629bfeae4d8ea364fc3f72fea8016ac8}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!get\_h\_omega@{get\_h\_omega}}
\index{get\_h\_omega@{get\_h\_omega}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{get\_h\_omega()}{get\_h\_omega()}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
virtual bool \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::get\+\_\+h\+\_\+omega (\begin{DoxyParamCaption}\item[{const \textbf{ Vector}$<$ double $>$ \&}]{e\+\_\+omega,  }\item[{const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&}]{e\+\_\+omega\+\_\+ref\+\_\+sets,  }\item[{\textbf{ Vector}$<$ double $>$ \&}]{hidden\+\_\+vars,  }\item[{const \textbf{ Point}$<$ spacedim $>$ \&}]{x,  }\item[{double \&}]{h\+\_\+omega,  }\item[{\textbf{ Vector}$<$ double $>$ \&}]{h\+\_\+omega\+\_\+1,  }\item[{\textbf{ Full\+Matrix}$<$ double $>$ \&}]{h\+\_\+omega\+\_\+2,  }\item[{const std\+::tuple$<$ bool, bool, bool $>$}]{requested\+\_\+quantities }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

Function for evaluation of integrand $h^\Omega_\rho$ and computation of first and second derivatives w.\+r.\+t. the dependent fields $e^\Omega_\lambda$.

This function is pure virtual, and, therefore, it is not possible to instantiate objects of this class. Rather, derived user defined classes must implement this function.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e\+\_\+omega} & Values of $e^\Omega_\lambda$ (the ordering is defined by the ordering of the dependent fields in \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{Scalar\+Functional$<$spacedim, spacedim$>$\+::e\+\_\+omega}})\\
\hline
\mbox{\texttt{ in}}  & {\em e\+\_\+omega\+\_\+ref\+\_\+sets} & Sets of reference values of $e^\Omega_\lambda$ (as required according to \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_acee2c3c289e5b2b680996facc2f79e78}{Scalar\+Functional$<$spacedim, spacedim$>$\+::n\+\_\+ref\+\_\+sets}})\\
\hline
\mbox{\texttt{ in,out}}  & {\em hidden\+\_\+vars} & Values of \char`\"{}hidden\char`\"{} variables associated with the integrand $h^\Omega_\rho$. This vector has the size \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}{Scalar\+Functional$<$spacedim, spacedim$>$\+::n\+\_\+hidden}}. The inputs are the previously known values of the hidden variables, which may be overwritten by the function (the user can decide during assembly of the finite element system whether the returned updated values of the hidden variables are really used to update the stored values of the hidden variables or whether they are discarded)\\
\hline
\mbox{\texttt{ in}}  & {\em x} & Location of material point at which integrand $h^\Omega_\rho$ and derivatives thereof are evaluated\\
\hline
\mbox{\texttt{ out}}  & {\em h\+\_\+omega} & Current value of $h^\Omega_\rho$.\\
\hline
\mbox{\texttt{ out}}  & {\em h\+\_\+omega\+\_\+1} & First derivatives of $h^\Omega_\rho$ w.\+r.\+t. $e^\Omega_\lambda$ (the ordering is defined by the ordering of the dependent fields in \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{Scalar\+Functional$<$spacedim, spacedim$>$\+::e\+\_\+omega}}, and {\ttfamily h\+\_\+omega\+\_\+1} will already be initialized to the correct size if it is called by \mbox{\hyperlink{class_assembly_helper}{Assembly\+Helper}} objects)\\
\hline
\mbox{\texttt{ out}}  & {\em h\+\_\+omega\+\_\+2} & Second derivatives of $h^\Omega_\rho$ w.\+r.\+t. $e^\Omega_\lambda$ (the ordering is defined by the ordering of the dependent fields in \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}{Scalar\+Functional$<$spacedim, spacedim$>$\+::e\+\_\+omega}}, and {\ttfamily h\+\_\+omega\+\_\+2} will already be initialized to the correct size if it is called by \mbox{\hyperlink{class_assembly_helper}{Assembly\+Helper}} objects). If $h^\Omega_\rho$ exists, this matrix will generally be symmetric. However, in principle the routines do also work for cases where $h^\Omega_\rho$ does not exist and {\ttfamily h\+\_\+omega\+\_\+2} is not symmetric.\\
\hline
\mbox{\texttt{ in}}  & {\em requested\+\_\+quantities} & A tuple indicating which quantities are actually to be computed (e.\+g. ({\ttfamily true}, {\ttfamily false}, {\ttfamily true}) indicates that {\ttfamily h\+\_\+omega} and {\ttfamily h\+\_\+omega\+\_\+2} are to be computed)\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily false} if the evaluation of the integrand $h^\Omega_\rho$ and its derivatives was successful, and {\ttfamily true} if an error prevented the proper calculation of these quantities (e.\+g. because a dependent field, which should be non-\/negative, was actually negative) 
\end{DoxyReturn}


Implemented in \mbox{\hyperlink{class_linear_material_domain_a2892815e854904d44f391e99dd409320}{Linear\+Material\+Domain$<$ spacedim $>$}}.

\mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_add1852ebe7ad8b1178063ff725748856}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_add1852ebe7ad8b1178063ff725748856}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!get\_maximum\_step@{get\_maximum\_step}}
\index{get\_maximum\_step@{get\_maximum\_step}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{get\_maximum\_step()}{get\_maximum\_step()}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
virtual double \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::get\+\_\+maximum\+\_\+step (\begin{DoxyParamCaption}\item[{const \textbf{ Vector}$<$ double $>$ \&}]{e\+\_\+omega,  }\item[{const std\+::vector$<$ \textbf{ Vector}$<$ double $>$$>$ \&}]{e\+\_\+omega\+\_\+ref\+\_\+sets,  }\item[{const \textbf{ Vector}$<$ double $>$ \&}]{delta\+\_\+e\+\_\+omega,  }\item[{const \textbf{ Vector}$<$ double $>$ \&}]{hidden\+\_\+vars,  }\item[{const \textbf{ Point}$<$ spacedim $>$ \&}]{x }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

Function for evaluation of the maximum permissible step length


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e\+\_\+omega} & Values of $e^\Omega_\lambda$ (the ordering is defined by the ordering of the dependent fields in Scalar\+Functional\+::e\+\_\+omega)\\
\hline
\mbox{\texttt{ in}}  & {\em e\+\_\+omega\+\_\+ref\+\_\+sets} & Sets of reference values of $e^\Omega_\lambda$ (as required according to \mbox{\hyperlink{class_scalar_functional_a7e12423f4b29e9e0aaa0f7f9c2d1c0eb}{Scalar\+Functional\+::n\+\_\+ref\+\_\+sets}})\\
\hline
\mbox{\texttt{ in}}  & {\em delta\+\_\+e\+\_\+omega} & Values of $\Delta e^\Omega_\lambda$\\
\hline
\mbox{\texttt{ in}}  & {\em hidden\+\_\+vars} & Values of \char`\"{}hidden\char`\"{} variables associated with the integrand $h^\Omega_\rho$. This vector has the size \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}{Scalar\+Functional$<$spacedim, spacedim$>$\+::n\+\_\+hidden}}.\\
\hline
\mbox{\texttt{ in}}  & {\em x} & Location of material point\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The maximum $\alpha$ such that $e^\Omega_\lambda + \alpha \Delta e^\Omega_\lambda$ is a permissible state; the standard implementation returns D\+B\+L\+\_\+\+M\+AX 
\end{DoxyReturn}
\mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a9d98d5f98629c097d73455d8a1fd5643}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a9d98d5f98629c097d73455d8a1fd5643}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!modify\_K\_cell\_f\_cell@{modify\_K\_cell\_f\_cell}}
\index{modify\_K\_cell\_f\_cell@{modify\_K\_cell\_f\_cell}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{modify\_K\_cell\_f\_cell()}{modify\_K\_cell\_f\_cell()}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
virtual void \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::modify\+\_\+\+K\+\_\+cell\+\_\+f\+\_\+cell (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_domain_cell_do_f_iterator}{Domain\+Cell\+Do\+F\+Iterator}}$<$ spacedim $>$ \&}]{domain\+\_\+cell,  }\item[{\textbf{ Full\+Matrix}$<$ double $>$ \&}]{K\+\_\+cell,  }\item[{\textbf{ Vector}$<$ double $>$ \&}]{f\+\_\+cell,  }\item[{const std\+::vector$<$ unsigned int $>$ \&}]{scalar\+\_\+functional\+\_\+indices\+\_\+to\+\_\+cell\+\_\+shapefuns,  }\item[{const std\+::vector$<$ unsigned int $>$ \&}]{scalar\+\_\+functional\+\_\+indices\+\_\+to\+\_\+independent\+\_\+scalar\+\_\+indices }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [virtual]}}

This allows for manually manipulating the contribution (related to this scalar functional) of a certain domain cell to the global finite element matrix and rhs.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em domain\+\_\+cell} & Reference to the cell\\
\hline
\mbox{\texttt{ in,out}}  & {\em K\+\_\+cell} & The cell matrix. This matrix is indexed by the scalar functional related indexing (indices related to cells come first followed by indices related to independent scalars).\\
\hline
\mbox{\texttt{ in,out}}  & {\em f\+\_\+cell} & The cell rhs. This vector is indexed by the scalar functional related indexing (indices related to cells come first followed by indices related to independent scalars).\\
\hline
\mbox{\texttt{ in}}  & {\em scalar\+\_\+functional\+\_\+indices\+\_\+to\+\_\+cell\+\_\+shapefuns} & This relates the scalar functional related indices to the cell shape function indices. In particular, the i-\/th component of this vector is the cell shape function corresponding to the i-\/th scalar functional related index.\\
\hline
\mbox{\texttt{ in}}  & {\em scalar\+\_\+functional\+\_\+indices\+\_\+to\+\_\+independent\+\_\+scalar\+\_\+indices} & This relates the scalar functional related indices to the independent scalar indices. In particular, the i-\/th component of this vector is the independent scalar index corresponding to the (n\+\_\+dofs\+\_\+cell + i)-\/th scalar functional related index, where n\+\_\+dofs\+\_\+cell is the number of cell related shape functions for this scalar functional. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_aa192395f822a64f60df43bf9d36c2f3a}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_aa192395f822a64f60df43bf9d36c2f3a}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!domain\_of\_integration@{domain\_of\_integration}}
\index{domain\_of\_integration@{domain\_of\_integration}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{domain\_of\_integration}{domain\_of\_integration}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
const std\+::set$<$\textbf{ types\+::material\+\_\+id}$>$ \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::domain\+\_\+of\+\_\+integration}

Set of \textbf{ types\+::material\+\_\+id}s determining the domain of integration (i.\+e. those regions of the domain $\Omega$, where the integrand $h^\Omega_\rho$ is non-\/zero). \mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_adfed9b70b743ba245a39c3e63b951f96}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!e\_omega@{e\_omega}}
\index{e\_omega@{e\_omega}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{e\_omega}{e\_omega}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
const std\+::vector$<$\mbox{\hyperlink{class_dependent_field}{Dependent\+Field}}$<$spacedim, spacedim$>$ $>$ \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::e\+\_\+omega}

Vector containing the dependent fields $e^\Omega_\lambda$ whereupon the integrand $h^\Omega_\rho$ depends. The ordering in this vector defines the ordering in vectors and matrices related to derivatives of $h^\Omega_\rho$ w.\+r.\+t. the dependent fields $e^\Omega_\lambda$. \mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ae3282d5182360e0030e4cc5e02fbe2eb}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ae3282d5182360e0030e4cc5e02fbe2eb}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!initial\_vals\_hidden@{initial\_vals\_hidden}}
\index{initial\_vals\_hidden@{initial\_vals\_hidden}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{initial\_vals\_hidden}{initial\_vals\_hidden}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
const \textbf{ Smart\+Pointer}$<$const \textbf{ Function}$<$spacedim$>$ $>$ \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::initial\+\_\+vals\+\_\+hidden}

A \textbf{ Function}, which must be supplied by the user for determination of non-\/zero initial values of the hidden variables (applies only if \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}{Scalar\+Functional$<$spacedim, spacedim$>$\+::n\+\_\+hidden}} $>$ 0).

The number of components of \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ae3282d5182360e0030e4cc5e02fbe2eb}{Scalar\+Functional$<$spacedim, spacedim$>$\+::initial\+\_\+vals\+\_\+hidden}} must be equal to \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}{Scalar\+Functional$<$spacedim, spacedim$>$\+::n\+\_\+hidden}}

As a minimum requirement, \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ae3282d5182360e0030e4cc5e02fbe2eb}{Scalar\+Functional$<$spacedim, spacedim$>$\+::initial\+\_\+vals\+\_\+hidden}} must implement the method \textbf{ Function\+::value()}. \mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a7df6711471715f907bc9911449c5c825}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!n\_hidden@{n\_hidden}}
\index{n\_hidden@{n\_hidden}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{n\_hidden}{n\_hidden}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
const unsigned int \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::n\+\_\+hidden}

Number of \char`\"{}hidden\char`\"{} variables associated with the integrand $h^\Omega_\rho$ of the scalar functional \mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_acee2c3c289e5b2b680996facc2f79e78}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_acee2c3c289e5b2b680996facc2f79e78}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!n\_ref\_sets@{n\_ref\_sets}}
\index{n\_ref\_sets@{n\_ref\_sets}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{n\_ref\_sets}{n\_ref\_sets}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
const unsigned int \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::n\+\_\+ref\+\_\+sets}

The number of sets of reference values of the dependent fields $e^\Omega_\lambda$ involved in the definition of the integrand $h^\Omega_\rho$ \mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a195248af3821548af3000872e9e6d00e}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_a195248af3821548af3000872e9e6d00e}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!name@{name}}
\index{name@{name}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{name}{name}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
const std\+::string \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::name}

A name for the scalar functional \mbox{\Hypertarget{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ab83ee3ae077b211137824b006098382e}\label{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_ab83ee3ae077b211137824b006098382e}} 
\index{ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}!quadrature@{quadrature}}
\index{quadrature@{quadrature}!ScalarFunctional$<$ spacedim, spacedim $>$@{ScalarFunctional$<$ spacedim, spacedim $>$}}
\doxysubsubsection{\texorpdfstring{quadrature}{quadrature}}
{\footnotesize\ttfamily template$<$unsigned int spacedim$>$ \\
const \textbf{ Quadrature}$<$spacedim$>$ \mbox{\hyperlink{class_scalar_functional}{Scalar\+Functional}}$<$ spacedim, spacedim $>$\+::quadrature}

\textbf{ Quadrature} rule when integrating over the domain determined by \mbox{\hyperlink{class_scalar_functional_3_01spacedim_00_01spacedim_01_4_aa192395f822a64f60df43bf9d36c2f3a}{Scalar\+Functional$<$spacedim, spacedim$>$\+::domain\+\_\+of\+\_\+integration}} 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/sst/code/\+Galerkin\+Tools/\+Galerkin\+Tools/include/galerkin\+\_\+tools/\mbox{\hyperlink{scalar__functional_8h}{scalar\+\_\+functional.\+h}}\end{DoxyCompactItemize}
