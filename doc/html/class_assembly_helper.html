<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Library GalerkinTools: AssemblyHelper&lt; spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Library GalerkinTools
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_assembly_helper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AssemblyHelper&lt; spacedim &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="assembly__helper_8h_source.html">assembly_helper.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for AssemblyHelper&lt; spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="class_assembly_helper__coll__graph.png" border="0" usemap="#_assembly_helper_3_01spacedim_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="_assembly_helper_3_01spacedim_01_4_coll__map" id="_assembly_helper_3_01spacedim_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="932,149,1155,176"/>
<area shape="rect" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html" title=" " alt="" coords="587,5,751,61"/>
<area shape="rect" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html" title=" " alt="" coords="156,17,316,58"/>
<area shape="rect" href="https://dealii.org/9.0.0/doxygen/deal.II/classSubscriptor.html" title=" " alt="" coords="5,120,100,147"/>
<area shape="rect" href="https://dealii.org/9.0.0/doxygen/deal.II/classhp_1_1FECollection.html" title=" " alt="" coords="347,81,556,122"/>
<area shape="rect" href="https://dealii.org/9.0.0/doxygen/deal.II/classhp_1_1FECollection.html" title=" " alt="" coords="349,141,554,182"/>
<area shape="rect" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html" title=" " alt="" coords="149,201,323,242"/>
<area shape="rect" href="https://dealii.org/9.0.0/doxygen/deal.II/classConditionalOStream.html" title=" " alt="" coords="592,291,745,317"/>
<area shape="rect" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html" title=" " alt="" coords="580,211,757,267"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae164448dcc5e9e8d2849c354212d6df5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ae164448dcc5e9e8d2849c354212d6df5">AssemblyHelper</a> (const <a class="el" href="class_total_potential.html">TotalPotential</a>&lt; spacedim &gt; &amp;<a class="el" href="class_assembly_helper.html#a748eed9d73b7437a4bf2dcd73108790b">total_potential</a>, <a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt; spacedim &gt; &amp;<a class="el" href="class_assembly_helper.html#add08a8a7bb9c9325fcc7d92bfce525d4">tria_system</a>, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a>&lt; spacedim, spacedim &gt; &amp;<a class="el" href="class_assembly_helper.html#a3fbb49461000dea8f64266f830709fad">mapping_domain</a>, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a>&lt; spacedim-1, spacedim &gt; &amp;<a class="el" href="class_assembly_helper.html#a055fde6217c18e62cd80188d0130c201">mapping_interface</a>, const std::set&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; 0, spacedim &gt; * &gt; &amp;independent_scalars=std::set&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; 0, spacedim &gt; * &gt;())</td></tr>
<tr class="separator:ae164448dcc5e9e8d2849c354212d6df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82eca7b04aedf772028c6ff77245e9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ac82eca7b04aedf772028c6ff77245e9b">~AssemblyHelper</a> ()</td></tr>
<tr class="separator:ac82eca7b04aedf772028c6ff77245e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for assembly of the finite element system</div></td></tr>
<tr class="memitem:a4043c993c8902ad5d3045a13ed42e6f8"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a4043c993c8902ad5d3045a13ed42e6f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a4043c993c8902ad5d3045a13ed42e6f8">get_initial_fields_vector</a> (<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;initial_fields, const AffineConstraints&lt; double &gt; *constraints=nullptr) const</td></tr>
<tr class="separator:a4043c993c8902ad5d3045a13ed42e6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e7eb10c5dbd5358597f38291b90d85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a40e7eb10c5dbd5358597f38291b90d85">make_dirichlet_constraints</a> (AffineConstraints&lt; double &gt; &amp;constraint_matrix, const std::vector&lt; const <a class="el" href="class_dirichlet_constraint.html">DirichletConstraint</a>&lt; spacedim &gt; * &gt; &amp;dirichlet_constraints, const AffineConstraints&lt; double &gt; &amp;constraints_ignore=AffineConstraints&lt; double &gt;()) const</td></tr>
<tr class="separator:a40e7eb10c5dbd5358597f38291b90d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2d6681755428d4abfe718e54e3c322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a5b2d6681755428d4abfe718e54e3c322">make_dirichlet_constraints</a> (AffineConstraints&lt; double &gt; &amp;constraint_matrix, const std::vector&lt; const <a class="el" href="class_dirichlet_constraint.html">DirichletConstraint</a>&lt; spacedim &gt; * &gt; &amp;dirichlet_constraints, const std::vector&lt; const <a class="el" href="class_point_constraint.html">PointConstraint</a>&lt; spacedim, spacedim &gt; * &gt; &amp;point_constraints_omega, const std::vector&lt; const <a class="el" href="class_point_constraint.html">PointConstraint</a>&lt; spacedim-1, spacedim &gt; * &gt; &amp;point_constraints_sigma, const std::vector&lt; const <a class="el" href="class_point_constraint.html">PointConstraint</a>&lt; 0, spacedim &gt; * &gt; &amp;point_constraints_C, const AffineConstraints&lt; double &gt; &amp;constraints_ignore=AffineConstraints&lt; double &gt;()) const</td></tr>
<tr class="separator:a5b2d6681755428d4abfe718e54e3c322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a2aa2aa08149682feca02e458232d4"><td class="memTemplParams" colspan="2">template&lt;class SparsityPatternType &gt; </td></tr>
<tr class="memitem:a60a2aa2aa08149682feca02e458232d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a60a2aa2aa08149682feca02e458232d4">generate_sparsity_pattern_by_simulation</a> (SparsityPatternType &amp;dsp_K, const AffineConstraints&lt; double &gt; &amp;constraints) const</td></tr>
<tr class="separator:a60a2aa2aa08149682feca02e458232d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5146802e9d7d4bc5df7fe35909da3e44"><td class="memTemplParams" colspan="2">template&lt;class SolutionVectorType , class RHSVectorType , class MatrixType &gt; </td></tr>
<tr class="memitem:a5146802e9d7d4bc5df7fe35909da3e44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a5146802e9d7d4bc5df7fe35909da3e44">assemble_system</a> (const SolutionVectorType &amp;solution, const std::vector&lt; const SolutionVectorType * &gt; solution_ref_sets, const AffineConstraints&lt; double &gt; &amp;constraints, double &amp;potential_value, RHSVectorType &amp;f, MatrixType &amp;K, const std::tuple&lt; bool, bool, bool &gt; requested_quantities=std::make_tuple(true, true, true), std::map&lt; unsigned int, double &gt; *local_solution=nullptr) const</td></tr>
<tr class="separator:a5146802e9d7d4bc5df7fe35909da3e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6ef2dced66e223684e5df97182f428"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:acf6ef2dced66e223684e5df97182f428"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#acf6ef2dced66e223684e5df97182f428">get_nonprimitive_scalar_functional_values</a> (const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;solution, const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt; solution_ref_sets, std::map&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; *, double &gt; &amp;nonprimitive_scalar_functional_values_domain, std::map&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; *, double &gt; &amp;nonprimitive_scalar_functional_values_interface) const</td></tr>
<tr class="separator:acf6ef2dced66e223684e5df97182f428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2940850798972b003cf33d37e705490e"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a2940850798972b003cf33d37e705490e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a2940850798972b003cf33d37e705490e">call_scalar_functionals</a> (const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;solution, const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt; &amp;solution_ref_sets, const std::set&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; * &gt; &amp;scalar_functionals_domain_to_call, const std::set&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; * &gt; &amp;scalar_functionals_interface_to_call) const</td></tr>
<tr class="separator:a2940850798972b003cf33d37e705490e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310594206df2622027fdc48e84600bf7"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a310594206df2622027fdc48e84600bf7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a310594206df2622027fdc48e84600bf7">get_maximum_step_length</a> (const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;solution, const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt; solution_ref_sets, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;delta_solution) const</td></tr>
<tr class="separator:a310594206df2622027fdc48e84600bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54f45f37a38426db1b5f85eccc7b3e9"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:ac54f45f37a38426db1b5f85eccc7b3e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ac54f45f37a38426db1b5f85eccc7b3e9">compare_derivatives_with_numerical_derivatives</a> (const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;solution, const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt; solution_ref_sets, const std::string detailed_printout_file=&quot;&quot;, const double <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacePhysics_1_1Elasticity_1_1Kinematics.html#a338a944a393875e2dd499457d1055841">epsilon</a>=1<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8) const</td></tr>
<tr class="separator:ac54f45f37a38426db1b5f85eccc7b3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for writing output</div></td></tr>
<tr class="memitem:a6120d66724f518dcfcdc30a89df01c23"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a6120d66724f518dcfcdc30a89df01c23"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const std::string, const std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a6120d66724f518dcfcdc30a89df01c23">write_output_independent_fields</a> (const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;solution, const std::string file_name_domain, const std::string file_name_interface, const unsigned int file_index=0, const std::vector&lt; dealii::SmartPointer&lt; const dealii::DataPostprocessor&lt; spacedim &gt;&gt;&gt; &amp;dp_domain=std::vector&lt; dealii::SmartPointer&lt; const dealii::DataPostprocessor&lt; spacedim &gt;&gt;&gt;(), const std::vector&lt; dealii::SmartPointer&lt; const dealii::DataPostprocessor&lt; spacedim &gt;&gt;&gt; &amp;dp_interface=std::vector&lt; dealii::SmartPointer&lt; const dealii::DataPostprocessor&lt; spacedim &gt;&gt;&gt;(), const unsigned int n_subdivisions=1) const</td></tr>
<tr class="separator:a6120d66724f518dcfcdc30a89df01c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6f8ff7c1a8910d84beb7761b5c821b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a6a6f8ff7c1a8910d84beb7761b5c821b">print_assembly_helper_definition</a> (const bool detailed_printout_shapefuns=true) const</td></tr>
<tr class="separator:a6a6f8ff7c1a8910d84beb7761b5c821b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for comparing solutions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are essentially intended for studies of the convergence behavior. Two types of methods are offered. The first allows comparison with a different numerical solution obtained on a differently refined mesh; and the second allows comparison with an analytical solution. </p>
</div></td></tr>
<tr class="memitem:a94bb821b6258eab0bb3a9046b6d9158a"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a94bb821b6258eab0bb3a9046b6d9158a"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const double, const double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a94bb821b6258eab0bb3a9046b6d9158a">compute_distance_to_other_solution</a> (const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;solution, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;other_solution, const <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt; &amp;other_assembly_helper, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a>&lt; spacedim &gt; quadrature_domain, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a>&lt; spacedim-1 &gt; quadrature_interface, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__numerics.html#ga69967cb7a148a7169963126249213db1">VectorTools::NormType</a> norm_type=VectorTools::NormType::L2_norm, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a> component_mask_domain=<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>(), const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a> component_mask_interface=<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>(), const double exponent=2.0, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; scaling_domain=<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespaceLinearAlgebraTrilinos_1_1MPI.html#a6c5bf277e53c73f3d252d6a8455c21a4">dealii::Vector</a>&lt; double &gt;(), const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; scaling_interface=<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespaceLinearAlgebraTrilinos_1_1MPI.html#a6c5bf277e53c73f3d252d6a8455c21a4">dealii::Vector</a>&lt; double &gt;()) const</td></tr>
<tr class="separator:a94bb821b6258eab0bb3a9046b6d9158a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e96514d9d023949eb07d95b5a2214c4"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a0e96514d9d023949eb07d95b5a2214c4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; const double, const double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a0e96514d9d023949eb07d95b5a2214c4">compute_distance_to_exact_solution</a> (const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;solution, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_solution_domain, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFunction.html">Function</a>&lt; spacedim &gt; &amp;exact_solution_interface, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a>&lt; spacedim &gt; quadrature_domain, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a>&lt; spacedim-1 &gt; quadrature_interface, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__numerics.html#ga69967cb7a148a7169963126249213db1">VectorTools::NormType</a> norm_type=VectorTools::NormType::L2_norm, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a> component_mask_domain=<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>(), const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a> component_mask_interface=<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>(), const double exponent=2.0) const</td></tr>
<tr class="separator:a0e96514d9d023949eb07d95b5a2214c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods for querying information about the AssemblyHelper object.</div></td></tr>
<tr class="memitem:a42cc83a6b33fe48b04fa8f4c9907cbb8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a42cc83a6b33fe48b04fa8f4c9907cbb8">get_triangulation_system</a> () const</td></tr>
<tr class="separator:a42cc83a6b33fe48b04fa8f4c9907cbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f9d21a79922d4879e37916b414f7d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a16f9d21a79922d4879e37916b414f7d0">get_triangulation_system</a> ()</td></tr>
<tr class="separator:a16f9d21a79922d4879e37916b414f7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095623df46217c89ee8e786f6e8a3034"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a095623df46217c89ee8e786f6e8a3034">get_dof_handler_system</a> () const</td></tr>
<tr class="separator:a095623df46217c89ee8e786f6e8a3034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04523eef6062ced8c88d4c093b65df3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a04523eef6062ced8c88d4c093b65df3d">get_dof_handler_system</a> ()</td></tr>
<tr class="separator:a04523eef6062ced8c88d4c093b65df3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d6fed5b90cee2e2e972e294ececffb"><td class="memItemLeft" align="right" valign="top">std::map&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim, spacedim &gt; *, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a39d6fed5b90cee2e2e972e294ececffb">get_u_omega_global_component_indices</a> () const</td></tr>
<tr class="separator:a39d6fed5b90cee2e2e972e294ececffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7df3baf877b83b7c98b7f389fa2926"><td class="memItemLeft" align="right" valign="top">std::map&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim-1, spacedim &gt; *, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#afe7df3baf877b83b7c98b7f389fa2926">get_u_sigma_global_component_indices</a> () const</td></tr>
<tr class="separator:afe7df3baf877b83b7c98b7f389fa2926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65861aae14b724a631feaf56c82ae9a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#af65861aae14b724a631feaf56c82ae9a">get_u_omega_global_component_index</a> (const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim, spacedim &gt; &amp;<a class="el" href="class_assembly_helper.html#a1952a054a839a7a683ca108013e7d976">u_omega</a>) const</td></tr>
<tr class="separator:af65861aae14b724a631feaf56c82ae9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad9cb7482bfc3ce527ad7639a8d5843"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a4ad9cb7482bfc3ce527ad7639a8d5843">get_u_sigma_global_component_index</a> (const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim-1, spacedim &gt; &amp;<a class="el" href="class_assembly_helper.html#a696fe649b3503561235aa1ccbf2ddeef">u_sigma</a>) const</td></tr>
<tr class="separator:a4ad9cb7482bfc3ce527ad7639a8d5843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae821c8ae9c8fa6f8e85d20ecd5ad7e39"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">system_size</a> () const</td></tr>
<tr class="separator:ae821c8ae9c8fa6f8e85d20ecd5ad7e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781fcbb9a157621c8db25d8ef46aca13"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a781fcbb9a157621c8db25d8ef46aca13">get_n_stretched_rows</a> () const</td></tr>
<tr class="separator:a781fcbb9a157621c8db25d8ef46aca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9603ede43f9abae845caf60e52d4a1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a9b9603ede43f9abae845caf60e52d4a1">get_n_C</a> () const</td></tr>
<tr class="separator:a9b9603ede43f9abae845caf60e52d4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6e5ff3a45411c2b8b42777fa94ec40"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a3b6e5ff3a45411c2b8b42777fa94ec40">get_global_dof_index_C</a> (const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; 0, spacedim &gt; *independent_scalar) const</td></tr>
<tr class="separator:a3b6e5ff3a45411c2b8b42777fa94ec40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30584e0ed1b2564e9b66ce9cecae40c7"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a30584e0ed1b2564e9b66ce9cecae40c7">get_locally_relevant_indices</a> () const</td></tr>
<tr class="separator:a30584e0ed1b2564e9b66ce9cecae40c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecc73fbc0e71716805c97498a83833a"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a8ecc73fbc0e71716805c97498a83833a">get_locally_owned_indices</a> () const</td></tr>
<tr class="separator:a8ecc73fbc0e71716805c97498a83833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f47fad7f7f2a83a7f54cd38825c703a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a5f47fad7f7f2a83a7f54cd38825c703a">get_locally_relevant_indices_blocks</a> () const</td></tr>
<tr class="separator:a5f47fad7f7f2a83a7f54cd38825c703a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a81fd16e7692501189d9c0bd96bc2d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#af1a81fd16e7692501189d9c0bd96bc2d">get_locally_owned_indices_blocks</a> () const</td></tr>
<tr class="separator:af1a81fd16e7692501189d9c0bd96bc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad798d22d994c4c18a05503ae9db4b408"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ad798d22d994c4c18a05503ae9db4b408">get_dof_index_at_point_omega</a> (const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim, spacedim &gt; *<a class="el" href="class_assembly_helper.html#a1952a054a839a7a683ca108013e7d976">u_omega</a>, const unsigned int component, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classPoint.html">Point</a>&lt; spacedim &gt; p, const std::set&lt; unsigned int &gt; ignore_dofs=std::set&lt; unsigned int &gt;()) const</td></tr>
<tr class="separator:ad798d22d994c4c18a05503ae9db4b408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256dc4f0fc5c62f130d75734ea94249f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a256dc4f0fc5c62f130d75734ea94249f">get_dof_index_at_point_sigma</a> (const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim-1, spacedim &gt; *<a class="el" href="class_assembly_helper.html#a696fe649b3503561235aa1ccbf2ddeef">u_sigma</a>, const unsigned int component, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classPoint.html">Point</a>&lt; spacedim &gt; p, const std::set&lt; unsigned int &gt; ignore_dofs=std::set&lt; unsigned int &gt;()) const</td></tr>
<tr class="separator:a256dc4f0fc5c62f130d75734ea94249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dabb84cc4a0497dbeb73a9eec3071d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ab0dabb84cc4a0497dbeb73a9eec3071d">print_dof_information</a> (const unsigned int dof_index) const</td></tr>
<tr class="separator:ab0dabb84cc4a0497dbeb73a9eec3071d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous memberfunctions</div></td></tr>
<tr class="memitem:a60553b183a382aff3072ea7b6f5b86dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a60553b183a382aff3072ea7b6f5b86dd">set_quadrature_point_alignment_tol</a> (const double <a class="el" href="class_assembly_helper.html#aa37920e596dca3985e6d28b9d4e3d882">quadrature_point_alignment_tol</a>)</td></tr>
<tr class="separator:a60553b183a382aff3072ea7b6f5b86dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5744ed966169526d69508706b7b8f2d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a5744ed966169526d69508706b7b8f2d2">set_cylindrical_symmetry</a> (const bool <a class="el" href="class_assembly_helper.html#aa2548bfa4a097088e3759ce2a1319aa8">cylindrical_symmetry</a>)</td></tr>
<tr class="separator:a5744ed966169526d69508706b7b8f2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Member functions used during construction of an AssemblyHelper object</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are essentially introduced to clean up tthe constructor of the class a bit. They are only used during construction of an <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> object. </p>
</div></td></tr>
<tr class="memitem:aad21ced11a2d90c804827854c18f7f89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#aad21ced11a2d90c804827854c18f7f89">convert_dependent_fields_to_shapefunctions</a> ()</td></tr>
<tr class="separator:aad21ced11a2d90c804827854c18f7f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c187fbb8171d6a1ff2ff6344cb454ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a1c187fbb8171d6a1ff2ff6344cb454ed">initialize_hidden_variables</a> () const</td></tr>
<tr class="separator:a1c187fbb8171d6a1ff2ff6344cb454ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Member functions related to assembly of the finite element system</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions are all needed during assembly of the finite element system. </p>
</div></td></tr>
<tr class="memitem:a953859cc4cd745a1b51fdec5418be682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a953859cc4cd745a1b51fdec5418be682">distribute_dofs</a> ()</td></tr>
<tr class="separator:a953859cc4cd745a1b51fdec5418be682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95639ce05d10d6aa37ea6ae5962753e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a95639ce05d10d6aa37ea6ae5962753e2">initialize_fe_values_domain</a> (const typename <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classDoFHandler.html">DoFHandler</a>&lt; spacedim, spacedim &gt;::<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__Iterators.html#ga661664adfd3a341a678e5ac62f85185a">active_cell_iterator</a> &amp;cell, const unsigned int internal_index, const bool nonprimitive=false) const</td></tr>
<tr class="separator:a95639ce05d10d6aa37ea6ae5962753e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223bbebe8a1f0aa09a53ee19257b927e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a223bbebe8a1f0aa09a53ee19257b927e">initialize_fe_values_interface</a> (const <a class="el" href="class_interface_cell_domain_cells_do_f.html">InterfaceCellDomainCellsDoF</a>&lt; spacedim &gt; &amp;interface_cell_domain_cells, const unsigned int internal_index, const bool nonprimitive=false) const</td></tr>
<tr class="separator:a223bbebe8a1f0aa09a53ee19257b927e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e29275d9ec1c479375707fbc670bc8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a5e29275d9ec1c479375707fbc670bc8c">compute_e_omega</a> (const unsigned int internal_index, const unsigned int scalar_functional_index, const unsigned int q_point, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;solution_u_omega, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;solution_C, <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;e_omega, <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;de_omega_dsol_T, const bool compute_derivative=true, const bool ignore_constants=false) const</td></tr>
<tr class="separator:a5e29275d9ec1c479375707fbc670bc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1906ba80994e8bb136ccf466fd7611d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a1906ba80994e8bb136ccf466fd7611d5">compute_e_sigma</a> (const unsigned int internal_index, const unsigned int scalar_functional_index, const unsigned int q_point, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;solution_u_sigma, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;solution_u_omega_minus, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;solution_u_omega_plus, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;solution_C, const std::vector&lt; unsigned int &gt; &amp;dof_indices_interface_dof_indices_combined, const std::vector&lt; unsigned int &gt; &amp;dof_indices_minus_dof_indices_combined, const std::vector&lt; unsigned int &gt; &amp;dof_indices_plus_dof_indices_combined, const std::vector&lt; unsigned int &gt; &amp;dof_indices_C_dof_indices_combined, const std::vector&lt; unsigned int &gt; &amp;dof_indices_global_combined, <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;e_sigma, <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;de_sigma_dsol_T, const bool compute_derivative=true, const bool ignore_constants=false) const</td></tr>
<tr class="separator:a1906ba80994e8bb136ccf466fd7611d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe88d8ccfd69bbfcfc56551c5c7d67e9"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:abe88d8ccfd69bbfcfc56551c5c7d67e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#abe88d8ccfd69bbfcfc56551c5c7d67e9">get_nonprimitive_scalar_functional_values</a> (const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;solution, const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt; solution_ref_sets, <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;nonprimitive_scalar_functional_values) const</td></tr>
<tr class="separator:abe88d8ccfd69bbfcfc56551c5c7d67e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2778924ff66c8ad8695f0cd3da5ced9f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const int, const int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a2778924ff66c8ad8695f0cd3da5ced9f">get_scalar_functional_indices</a> (const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; *scalar_functional) const</td></tr>
<tr class="separator:a2778924ff66c8ad8695f0cd3da5ced9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3f6a06344be172d9419b26bb085073"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const int, const int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a3e3f6a06344be172d9419b26bb085073">get_scalar_functional_indices</a> (const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; *scalar_functional) const</td></tr>
<tr class="separator:a3e3f6a06344be172d9419b26bb085073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae339631f070dbe766d84697cd9229134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ae339631f070dbe766d84697cd9229134">get_dof_indices_C</a> (std::vector&lt; unsigned int &gt; &amp;global_dof_indices_C) const</td></tr>
<tr class="separator:ae339631f070dbe766d84697cd9229134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6d7a10dfa2b88ef6f2a974124b0ad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a8a6d7a10dfa2b88ef6f2a974124b0ad5">make_dirichlet_constraints_recursion</a> (const typename <a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt; spacedim &gt;::DomainCell &amp;domain_cell, const unsigned int face, const std::vector&lt; unsigned int &gt; &amp;shapefuns, const <a class="el" href="class_dirichlet_constraint.html">DirichletConstraint</a>&lt; spacedim &gt; &amp;constraint, AffineConstraints&lt; double &gt; &amp;constraint_matrix, const AffineConstraints&lt; double &gt; &amp;constraints_ignore) const</td></tr>
<tr class="separator:a8a6d7a10dfa2b88ef6f2a974124b0ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Problem definition</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These members define the problem to be solved. </p>
</div></td></tr>
<tr class="memitem:a748eed9d73b7437a4bf2dcd73108790b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_total_potential.html">TotalPotential</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a748eed9d73b7437a4bf2dcd73108790b">total_potential</a></td></tr>
<tr class="separator:a748eed9d73b7437a4bf2dcd73108790b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add08a8a7bb9c9325fcc7d92bfce525d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#add08a8a7bb9c9325fcc7d92bfce525d4">tria_system</a></td></tr>
<tr class="separator:add08a8a7bb9c9325fcc7d92bfce525d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbb49461000dea8f64266f830709fad"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a>&lt; spacedim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a3fbb49461000dea8f64266f830709fad">mapping_domain</a></td></tr>
<tr class="separator:a3fbb49461000dea8f64266f830709fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055fde6217c18e62cd80188d0130c201"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a>&lt; spacedim-1, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a055fde6217c18e62cd80188d0130c201">mapping_interface</a></td></tr>
<tr class="separator:a055fde6217c18e62cd80188d0130c201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Domain and interface portion indexing</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These members define consecutive indices for domain and interface portions for internal use. </p>
</div></td></tr>
<tr class="memitem:a10b3acf64bccc169ee14dc2505ce4b46"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a10b3acf64bccc169ee14dc2505ce4b46">material_id_to_internal_index_domain</a></td></tr>
<tr class="separator:a10b3acf64bccc169ee14dc2505ce4b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b82de0ede96d03b9f7fd8740d81668"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::tuple&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a> &gt;, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a43b82de0ede96d03b9f7fd8740d81668">material_ids_to_internal_index_interface</a></td></tr>
<tr class="separator:a43b82de0ede96d03b9f7fd8740d81668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Finite elements and dof handling</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These members comprise the finite elements to be used on the respective domain and interface portions as well as the <a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a> (which contains all dof information). </p>
</div></td></tr>
<tr class="memitem:af3803b0aad9853e6bf018c70be41e791"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classhp_1_1FECollection.html">hp::FECollection</a>&lt; spacedim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#af3803b0aad9853e6bf018c70be41e791">fe_collection_domain</a></td></tr>
<tr class="separator:af3803b0aad9853e6bf018c70be41e791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4d224a9ecd2e926a8860829874d2a1"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classhp_1_1FECollection.html">hp::FECollection</a>&lt; spacedim-1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a8b4d224a9ecd2e926a8860829874d2a1">fe_collection_interface</a></td></tr>
<tr class="separator:a8b4d224a9ecd2e926a8860829874d2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3045f80801fc31920efd161a268aae8e"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a3045f80801fc31920efd161a268aae8e">material_id_to_fe_system_id_domain</a></td></tr>
<tr class="separator:a3045f80801fc31920efd161a268aae8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fea54137e3c1c5a514e39c9b2ad7926"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a5fea54137e3c1c5a514e39c9b2ad7926">material_id_to_fe_system_id_interface</a></td></tr>
<tr class="separator:a5fea54137e3c1c5a514e39c9b2ad7926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885e660c749e91a35e3279643ebcd87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a885e660c749e91a35e3279643ebcd87f">dof_handler_system</a></td></tr>
<tr class="separator:a885e660c749e91a35e3279643ebcd87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Members re-organizing AssemblyHelper::total_potential</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These members re-organize the information provided by <a class="el" href="class_assembly_helper.html#a748eed9d73b7437a4bf2dcd73108790b">AssemblyHelper::total_potential</a> in a way suitable for efficient assembly of the finite element system. </p>
</div></td></tr>
<tr class="memitem:a1952a054a839a7a683ca108013e7d976"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a1952a054a839a7a683ca108013e7d976">u_omega</a></td></tr>
<tr class="separator:a1952a054a839a7a683ca108013e7d976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696fe649b3503561235aa1ccbf2ddeef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim-1, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a696fe649b3503561235aa1ccbf2ddeef">u_sigma</a></td></tr>
<tr class="separator:a696fe649b3503561235aa1ccbf2ddeef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5234a46be82cfe7d92678169d38f326"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; 0, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#aa5234a46be82cfe7d92678169d38f326">C</a></td></tr>
<tr class="separator:aa5234a46be82cfe7d92678169d38f326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dae4b6ae7934eaec1ad7baff258ce6e"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim, spacedim &gt; &gt;, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a6dae4b6ae7934eaec1ad7baff258ce6e">global_component_indices_u_omega</a></td></tr>
<tr class="separator:a6dae4b6ae7934eaec1ad7baff258ce6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992a53a1fcac8a393ca53fb8d504bdfe"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim-1, spacedim &gt; &gt;, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a992a53a1fcac8a393ca53fb8d504bdfe">global_component_indices_u_sigma</a></td></tr>
<tr class="separator:a992a53a1fcac8a393ca53fb8d504bdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8f0e8ea8c67ce9429c16a2017cafdc"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; 0, spacedim &gt; &gt;, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a9a8f0e8ea8c67ce9429c16a2017cafdc">global_indices_C</a></td></tr>
<tr class="separator:a9a8f0e8ea8c67ce9429c16a2017cafdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fa619e4c2582e95950e878cd06628e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#aa6fa619e4c2582e95950e878cd06628e">scalar_functionals_domain</a></td></tr>
<tr class="separator:aa6fa619e4c2582e95950e878cd06628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29aa77e0e8e6b35c94966ea88840e462"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a29aa77e0e8e6b35c94966ea88840e462">scalar_functionals_interface</a></td></tr>
<tr class="separator:a29aa77e0e8e6b35c94966ea88840e462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe78a019aec03cbeeb336d1d2874729"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a5fe78a019aec03cbeeb336d1d2874729">scalar_functionals_domain_nonprimitive</a></td></tr>
<tr class="separator:a5fe78a019aec03cbeeb336d1d2874729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833383aa6d157157545204143897ed9e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a833383aa6d157157545204143897ed9e">scalar_functionals_interface_nonprimitive</a></td></tr>
<tr class="separator:a833383aa6d157157545204143897ed9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf05fab2ddf57769a103d82a4f2d1cd3"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; &gt;, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#acf05fab2ddf57769a103d82a4f2d1cd3">scalar_functionals_domain_nonprimitive_indices</a></td></tr>
<tr class="separator:acf05fab2ddf57769a103d82a4f2d1cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d15b3ab0c7bec9fc4f40e532f8776f4"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; &gt;, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a0d15b3ab0c7bec9fc4f40e532f8776f4">scalar_functionals_interface_nonprimitive_indices</a></td></tr>
<tr class="separator:a0d15b3ab0c7bec9fc4f40e532f8776f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f08790a2235e48ce19f5d8d965a7874"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; &gt;, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a4f08790a2235e48ce19f5d8d965a7874">scalar_functionals_domain_primitive_indices</a></td></tr>
<tr class="separator:a4f08790a2235e48ce19f5d8d965a7874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99c75f32cf3f18aa1d4067ad8b56ae8"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; &gt;, const unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ad99c75f32cf3f18aa1d4067ad8b56ae8">scalar_functionals_interface_primitive_indices</a></td></tr>
<tr class="separator:ad99c75f32cf3f18aa1d4067ad8b56ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaf7ba62dfe0fa06ecb15ee8c14da34"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; &gt;, std::vector&lt; std::pair&lt; const unsigned int, const unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#aceaf7ba62dfe0fa06ecb15ee8c14da34">contributions_scalar_functionals_domain_total_potential</a></td></tr>
<tr class="separator:aceaf7ba62dfe0fa06ecb15ee8c14da34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e76874224ab4946218fdce9bdba0e03"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; &gt;, std::vector&lt; std::pair&lt; const unsigned int, const unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a9e76874224ab4946218fdce9bdba0e03">contributions_scalar_functionals_interface_total_potential</a></td></tr>
<tr class="separator:a9e76874224ab4946218fdce9bdba0e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bcfc1db651535a7aefc6071a81e124"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#af7bcfc1db651535a7aefc6071a81e124">n_scalar_functionals_nonprimitive</a></td></tr>
<tr class="separator:af7bcfc1db651535a7aefc6071a81e124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e03e8e47a85dbc96444ef61525c454"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#af5e03e8e47a85dbc96444ef61525c454">n_scalar_functionals_primitive</a></td></tr>
<tr class="separator:af5e03e8e47a85dbc96444ef61525c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Members providing information about shape function indexing, etc.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These data structures are organized in a way that shape function related information needed again and again for the functionalities provided by <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> (in particular assembly of the finite element system) can be retrieved efficiently. </p>
</div></td></tr>
<tr class="memitem:a0bdb6e2e2f9623f3f10dfa2ebe8e234c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a0bdb6e2e2f9623f3f10dfa2ebe8e234c">components_to_shapefuns_domain</a></td></tr>
<tr class="separator:a0bdb6e2e2f9623f3f10dfa2ebe8e234c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcad51e64347fc3141d2840a2835b46c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#abcad51e64347fc3141d2840a2835b46c">components_to_shapefuns_interface</a></td></tr>
<tr class="separator:abcad51e64347fc3141d2840a2835b46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92560183f1d2060265f0744a84f0349"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ae92560183f1d2060265f0744a84f0349">components_to_shapefuns_domain_facewise</a></td></tr>
<tr class="separator:ae92560183f1d2060265f0744a84f0349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a26b40224e3f04e5168accc91486493"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">coupled_dof_indices_scalar_functionals_domain</a></td></tr>
<tr class="separator:a1a26b40224e3f04e5168accc91486493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fc6d318c2f7a2eab5097b6a76c9083"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#aa9fc6d318c2f7a2eab5097b6a76c9083">coupled_dof_indices_scalar_functionals_domain_local</a></td></tr>
<tr class="separator:aa9fc6d318c2f7a2eab5097b6a76c9083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7242925e5a0be85830ed7eae581442"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a6b7242925e5a0be85830ed7eae581442">coupled_dof_indices_scalar_functionals_domain_nonlocal</a></td></tr>
<tr class="separator:a6b7242925e5a0be85830ed7eae581442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab346e146cf91fb7a0688076551b37355"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ab346e146cf91fb7a0688076551b37355">coupled_dof_indices_scalar_functionals_interface</a></td></tr>
<tr class="separator:ab346e146cf91fb7a0688076551b37355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12299d82365553a21fef8529c8fe8a17"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a12299d82365553a21fef8529c8fe8a17">coupled_dof_indices_scalar_functionals_interface_minus</a></td></tr>
<tr class="separator:a12299d82365553a21fef8529c8fe8a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07bb528fdd350e9b467b08dc44a03e7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#af07bb528fdd350e9b467b08dc44a03e7">coupled_dof_indices_scalar_functionals_interface_plus</a></td></tr>
<tr class="separator:af07bb528fdd350e9b467b08dc44a03e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edd25820c92a25ae87fc240f4916804"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a0edd25820c92a25ae87fc240f4916804">coupled_C_indices_scalar_functionals_domain</a></td></tr>
<tr class="separator:a0edd25820c92a25ae87fc240f4916804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311e176038ee2b7ca0719abb384ca57b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; unsigned int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a311e176038ee2b7ca0719abb384ca57b">coupled_C_indices_scalar_functionals_interface</a></td></tr>
<tr class="separator:a311e176038ee2b7ca0719abb384ca57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fef9096e5fc7b1e922ea78d7aa2c28"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, const unsigned int, std::vector&lt; unsigned int &gt; &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a13fef9096e5fc7b1e922ea78d7aa2c28">a_omega</a></td></tr>
<tr class="separator:a13fef9096e5fc7b1e922ea78d7aa2c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbb532e798c2427af5285c2df10c9f4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, const unsigned int, const unsigned int, std::vector&lt; unsigned int &gt; &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a5fbb532e798c2427af5285c2df10c9f4">b_omega</a></td></tr>
<tr class="separator:a5fbb532e798c2427af5285c2df10c9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e6f76c0b12b91c5feb230251f0137f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, unsigned int &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a75e6f76c0b12b91c5feb230251f0137f">c_omega</a></td></tr>
<tr class="separator:a75e6f76c0b12b91c5feb230251f0137f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b109608d4425d318434e01cb6246c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ad93b109608d4425d318434e01cb6246c">d_omega</a></td></tr>
<tr class="separator:ad93b109608d4425d318434e01cb6246c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547c7d4ffd7379860f15095d494b1d68"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a547c7d4ffd7379860f15095d494b1d68">e_omega_local</a></td></tr>
<tr class="separator:a547c7d4ffd7379860f15095d494b1d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa266cc07e9670319481da52d633d2583"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, const unsigned int, std::vector&lt; unsigned int &gt; &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#aa266cc07e9670319481da52d633d2583">a_sigma</a></td></tr>
<tr class="separator:aa266cc07e9670319481da52d633d2583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58c9a1c7093edc306070913aa1b9be2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, const unsigned int, const unsigned int, std::vector&lt; unsigned int &gt; &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#af58c9a1c7093edc306070913aa1b9be2">b_sigma</a></td></tr>
<tr class="separator:af58c9a1c7093edc306070913aa1b9be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4461be378c9be0364ca23153c367d24c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, const unsigned int, std::vector&lt; unsigned int &gt; &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a4461be378c9be0364ca23153c367d24c">a_minus</a></td></tr>
<tr class="separator:a4461be378c9be0364ca23153c367d24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f51f8b4dfdae385a2e2fe2dd9e66cdb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, const unsigned int, const unsigned int, std::vector&lt; unsigned int &gt; &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a6f51f8b4dfdae385a2e2fe2dd9e66cdb">b_minus</a></td></tr>
<tr class="separator:a6f51f8b4dfdae385a2e2fe2dd9e66cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb513a6239d94cc0f1a6a01a037c572"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, const unsigned int, std::vector&lt; unsigned int &gt; &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a8eb513a6239d94cc0f1a6a01a037c572">a_plus</a></td></tr>
<tr class="separator:a8eb513a6239d94cc0f1a6a01a037c572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09dd07d3ec596525be83f8f5859bef7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, const unsigned int, const unsigned int, std::vector&lt; unsigned int &gt; &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ab09dd07d3ec596525be83f8f5859bef7">b_plus</a></td></tr>
<tr class="separator:ab09dd07d3ec596525be83f8f5859bef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d4370661ba726010ee687ef0e98140"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::tuple&lt; const double, unsigned int &gt; &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ab3d4370661ba726010ee687ef0e98140">c_sigma</a></td></tr>
<tr class="separator:ab3d4370661ba726010ee687ef0e98140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d7d677120eb1c84b4983f470246e02"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a48d7d677120eb1c84b4983f470246e02">d_sigma</a></td></tr>
<tr class="separator:a48d7d677120eb1c84b4983f470246e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16aa77ea3867740a280fd50f5578adfc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a16aa77ea3867740a280fd50f5578adfc">e_sigma_local</a></td></tr>
<tr class="separator:a16aa77ea3867740a280fd50f5578adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Members containing the FEValues, FEFaceValues, and FESubfaceValues objects needed during assembly</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These data structures make sure that the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a>, <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEFaceValues.html">FEFaceValues</a>, and <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESubfaceValues.html">FESubfaceValues</a> objects are re-used wherever possible and that only those objects are reinitialized for which this is really necessary when a new cell is visited. </p>
</div></td></tr>
<tr class="memitem:a904a24f53b66e1c1ef89f1bb7989eb32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::shared_ptr&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a>&lt; spacedim, spacedim &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a904a24f53b66e1c1ef89f1bb7989eb32">fe_values_domain</a></td></tr>
<tr class="separator:a904a24f53b66e1c1ef89f1bb7989eb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e2643696005415d78421882ca80e8e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::shared_ptr&lt; <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a>&lt; spacedim &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ae1e2643696005415d78421882ca80e8e">fe_values_interface</a></td></tr>
<tr class="separator:ae1e2643696005415d78421882ca80e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b58551c6afc68c7beaaa2604bc6e92"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; std::shared_ptr&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a>&lt; spacedim, spacedim &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a28b58551c6afc68c7beaaa2604bc6e92">fe_values_domain_reinit</a></td></tr>
<tr class="separator:a28b58551c6afc68c7beaaa2604bc6e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9789c5a00867744dd906b85580e3091"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; std::shared_ptr&lt; <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a>&lt; spacedim &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#ac9789c5a00867744dd906b85580e3091">fe_values_interface_reinit</a></td></tr>
<tr class="separator:ac9789c5a00867744dd906b85580e3091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c592ef0a148753891cc3e03fd08324c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; std::shared_ptr&lt; <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a>&lt; spacedim, spacedim &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a3c592ef0a148753891cc3e03fd08324c">fe_values_domain_reinit_nonprimitive</a></td></tr>
<tr class="separator:a3c592ef0a148753891cc3e03fd08324c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa20027ee539ca8d9c40c317127e471"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::set&lt; std::shared_ptr&lt; <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a>&lt; spacedim &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#afaa20027ee539ca8d9c40c317127e471">fe_values_interface_reinit_nonprimitive</a></td></tr>
<tr class="separator:afaa20027ee539ca8d9c40c317127e471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous members</div></td></tr>
<tr class="memitem:af5e29448f133863a1859be8bfbb300c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#af5e29448f133863a1859be8bfbb300c6">component_names_domain</a></td></tr>
<tr class="separator:af5e29448f133863a1859be8bfbb300c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6ae2ec356cbb7b830d968315d280c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, unsigned int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a7ae6ae2ec356cbb7b830d968315d280c">component_names_interface</a></td></tr>
<tr class="separator:a7ae6ae2ec356cbb7b830d968315d280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228cec028ab5126d25c3ebf0e12a17a6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boost::signals2::connection &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a228cec028ab5126d25c3ebf0e12a17a6">tria_listeners</a></td></tr>
<tr class="separator:a228cec028ab5126d25c3ebf0e12a17a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aad83ae1bfe5338794cf9b50848469a"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a2aad83ae1bfe5338794cf9b50848469a">this_proc</a></td></tr>
<tr class="separator:a2aad83ae1bfe5338794cf9b50848469a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87945d87baf37637673fd124b3803fd5"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a87945d87baf37637673fd124b3803fd5">n_procs</a></td></tr>
<tr class="separator:a87945d87baf37637673fd124b3803fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717eb6ebc7c62fe00063edcf264f3ecc"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classConditionalOStream.html">ConditionalOStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#a717eb6ebc7c62fe00063edcf264f3ecc">pout</a></td></tr>
<tr class="separator:a717eb6ebc7c62fe00063edcf264f3ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37920e596dca3985e6d28b9d4e3d882"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#aa37920e596dca3985e6d28b9d4e3d882">quadrature_point_alignment_tol</a> = 1<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8</td></tr>
<tr class="separator:aa37920e596dca3985e6d28b9d4e3d882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2548bfa4a097088e3759ce2a1319aa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_assembly_helper.html#aa2548bfa4a097088e3759ce2a1319aa8">cylindrical_symmetry</a> = false</td></tr>
<tr class="separator:aa2548bfa4a097088e3759ce2a1319aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;unsigned int spacedim&gt;<br />
class AssemblyHelper&lt; spacedim &gt;</h3>

<p>The <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> class puts it all together and provides with methods for assembly of the finite element system.</p>
<p>Essentially, an <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> object is a combination of a <a class="el" href="class_triangulation_system.html">TriangulationSystem</a> object (which includes the definition of the domain portions and interface portions), a <a class="el" href="class_total_potential.html">TotalPotential</a> object, a corresponding <a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a> object, and mapping objects defining the mapping to be used on the domain and on the interface.</p>
<p>Large part of the class rearranges the data involved in the problem definition in a way which is suitable for efficient assembly.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>It might be worthwhile to allow for the usage of different mappings on different domain and interface portions.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Routines for treatment of DG terms should be implemented.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">spacedim</td><td>spatial dimension </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae164448dcc5e9e8d2849c354212d6df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae164448dcc5e9e8d2849c354212d6df5">&#9670;&nbsp;</a></span>AssemblyHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::<a class="el" href="class_assembly_helper.html">AssemblyHelper</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_total_potential.html">TotalPotential</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>total_potential</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria_system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a>&lt; spacedim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a>&lt; spacedim-1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; 0, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>independent_scalars</em> = <code>std::set&lt;&#160;const&#160;<a class="el" href="class_independent_field.html">IndependentField</a>&lt;&#160;0,&#160;spacedim&#160;&gt;&#160;*&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constructor of the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">total_potential</td><td><a class="el" href="class_assembly_helper.html#a748eed9d73b7437a4bf2dcd73108790b">AssemblyHelper::total_potential</a> (note: the total potential is copied over by the constructor; but as it contains pointers to the <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a> objects, changing the latter or the associated <a class="el" href="class_scalar_functional.html">ScalarFunctional</a> objects will affect the total potential)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tria_system</td><td><a class="el" href="class_assembly_helper.html#add08a8a7bb9c9325fcc7d92bfce525d4">AssemblyHelper::tria_system</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_domain</td><td><a class="el" href="class_assembly_helper.html#a3fbb49461000dea8f64266f830709fad">AssemblyHelper::mapping_domain</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping_interface</td><td><a class="el" href="class_assembly_helper.html#a055fde6217c18e62cd80188d0130c201">AssemblyHelper::mapping_interface</a></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">independent_scalars</td><td>Additional independent scalars to be included into the finite element system which are not appearing in the total potential (this may e.g. be constants appearing only in constraints) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac82eca7b04aedf772028c6ff77245e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82eca7b04aedf772028c6ff77245e9b">&#9670;&nbsp;</a></span>~AssemblyHelper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::~<a class="el" href="class_assembly_helper.html">AssemblyHelper</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. The main task of the destructor is to release the memory allocated for hidden variables. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5146802e9d7d4bc5df7fe35909da3e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5146802e9d7d4bc5df7fe35909da3e44">&#9670;&nbsp;</a></span>assemble_system()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class SolutionVectorType , class RHSVectorType , class MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::assemble_system </td>
          <td>(</td>
          <td class="paramtype">const SolutionVectorType &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const SolutionVectorType * &gt;&#160;</td>
          <td class="paramname"><em>solution_ref_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineConstraints&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>potential_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RHSVectorType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; bool, bool, bool &gt;&#160;</td>
          <td class="paramname"><em>requested_quantities</em> = <code>std::make_tuple(true,&#160;true,&#160;true)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; unsigned int, double &gt; *&#160;</td>
          <td class="paramname"><em>local_solution</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method performs the actual assembly of the following (stretched) finite element system: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation*} \boldsymbol{K}^\mathrm{s} \Delta \boldsymbol{\hat u}^\mathrm{s} = -\boldsymbol{f}^\mathrm{s} \end{equation*}" src="form_43.png"/>
</p>
<p>For further information about this finite element system, see the accompanying pdf file <a href="../notes/galerkin_tools.pdf">galerkin_tools.pdf</a>. Note that during assembly constraints are directly incorporated into the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>Point of linearization <img class="formulaInl" alt="$\boldsymbol{\hat u}^\mathrm{s} = \begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$" src="form_44.png"/>, where the values of <img class="formulaInl" alt="$\boldsymbol{\hat \lambda}$" src="form_45.png"/> are not used during assembly and are, therefore, arbitrary. The appropriate size of <code>solution</code> can be obtained from <a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">AssemblyHelper::system_size()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_ref_sets</td><td>Sets of reference solution vectors, which can e.g. be the solution vectors of previous times steps. Make sure that you pass at least as many reference sets here as are required by the <a class="el" href="class_scalar_functional.html">ScalarFunctional</a> objects (see <a class="el" href="class_scalar_functional.html#adb295fb739a743d5a1273025eb8dae72">ScalarFunctional::get_h_sigma()</a> and <a class="el" href="class_scalar_functional_3_01spacedim_00_01spacedim_01_4.html#a8665cb5b5a57ad22217e4c112845d43b">ScalarFunctional&lt;spacedim, spacedim&gt;::get_h_omega()</a>) and the <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a> objects (see <a class="el" href="class_total_potential_contribution.html#a515786e58c1fda7baf168be8f4a13720">TotalPotentialContribution::get_potential_contribution()</a>) to complete their computations. In general, the order of the sets of reference values in <a class="el" href="class_scalar_functional.html#adb295fb739a743d5a1273025eb8dae72">ScalarFunctional::get_h_sigma()</a>, <a class="el" href="class_scalar_functional_3_01spacedim_00_01spacedim_01_4.html#a8665cb5b5a57ad22217e4c112845d43b">ScalarFunctional&lt;spacedim, spacedim&gt;::get_h_omega()</a>, and <a class="el" href="class_total_potential_contribution.html#a515786e58c1fda7baf168be8f4a13720">TotalPotentialContribution::get_potential_contribution()</a> corresponds to the order in <code>solution_ref_sets</code>. If e.g. a function <a class="el" href="class_scalar_functional.html#adb295fb739a743d5a1273025eb8dae72">ScalarFunctional::get_h_sigma()</a> requires two reference sets of dependent variable values while <code>solution_ref_sets</code> contains more than two reference sets of dof values, the first two sets from <code>solution_ref_sets</code> will be used to obtain the reference sets of dependent variable values.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints</td><td>Constraints to be applied to the finite element system. These must be the same as those used for generating the sparsity pattern for <code>system_matrix</code> with <a class="el" href="class_assembly_helper.html#a60a2aa2aa08149682feca02e458232d4">AssemblyHelper::generate_sparsity_pattern_by_simulation()</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">potential_value</td><td>Value of the total potential (the correct calculation of the total potential value of course requires that all <a class="el" href="class_scalar_functional.html#adb295fb739a743d5a1273025eb8dae72">ScalarFunctional::get_h_sigma()</a>, <a class="el" href="class_scalar_functional_3_01spacedim_00_01spacedim_01_4.html#a8665cb5b5a57ad22217e4c112845d43b">ScalarFunctional&lt;spacedim, spacedim&gt;::get_h_omega()</a> and <a class="el" href="class_total_potential_contribution.html#a515786e58c1fda7baf168be8f4a13720">TotalPotentialContribution::get_potential_contribution()</a> functions compute the respective values and not only compute the derivatives.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>The right hand side of the (stretched) finite element system <img class="formulaInl" alt="$-\boldsymbol{f}^\mathrm{s}$" src="form_46.png"/> with <code>constraints</code> incorporated. This vector must be passed in with the correct size, which can be obtained from <a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">AssemblyHelper::system_size()</a>.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>The (stretched) system matrix <img class="formulaInl" alt="$\boldsymbol{K}^\mathrm{s}$" src="form_42.png"/> with <code>constraints</code> incorporated. The matrix must be passed in with the correct size, which can be obtained from <a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">AssemblyHelper::system_size()</a>, and the appropriate sparsity pattern generated by <a class="el" href="class_assembly_helper.html#a60a2aa2aa08149682feca02e458232d4">AssemblyHelper::generate_sparsity_pattern_by_simulation()</a> using <code>constraints</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requested_quantities</td><td>Tuple indicating which quantities are actually to be computed (e.g. (<code>true</code>, <code>false</code>, <code>true</code>) indicates that <code>potential_value</code> and <code>K</code> are to be computed)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local_solution</td><td>Map between global dof indices and updated local solution in case that there are local independent fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the assembly process was successful, and <code>true</code> if an error prevented proper assembly</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Note that the finite element system returned will not ensure that the constrained dofs have the correct values after the solution of the finite element system I.e., after solution, the values of the constrained dofs must be computed from the unconstrained dofs using distribute_solution().</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SolutionVectorType</td><td>The type used for <code>solution</code> and <code>solution_ref_sets</code> (in parallel this vector type must permit read access to ghosted entries while write access is not required)</td></tr>
    <tr><td class="paramname">RHSVectorType</td><td>The type used for <code>f</code> (in parallel this vector type must permit write access to ghosted entries while read access is not required)</td></tr>
    <tr><td class="paramname">MatrixType</td><td>The type used for <code>K</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>The treatment of local fields and locally eliminated fields needs to be completely revised! </dd></dl>

</div>
</div>
<a id="a2940850798972b003cf33d37e705490e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2940850798972b003cf33d37e705490e">&#9670;&nbsp;</a></span>call_scalar_functionals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::call_scalar_functionals </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_ref_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar_functionals_domain_to_call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>scalar_functionals_interface_to_call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method simply calling the <a class="el" href="class_scalar_functional_3_01spacedim_00_01spacedim_01_4.html#a8665cb5b5a57ad22217e4c112845d43b">ScalarFunctional&lt;spacedim, spacedim&gt;::get_h_omega()</a> and <a class="el" href="class_scalar_functional.html#adb295fb739a743d5a1273025eb8dae72">ScalarFunctional::get_h_sigma()</a> functions with the solution <code>solution</code> and the reference solution <code>solution_ref_sets</code>, without doing any assembly of the finite element system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>the global solution vector</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_ref_sets</td><td>a set of reference solution vectors (e.g. solutions at previous time steps), which may enter into the calculation of the scalar functionals</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_functionals_domain_to_call</td><td>domain-related scalar functionals to be evaluated</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_functionals_interface_to_call</td><td>interface-related scalar functionals to be evaluated</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>The type used for the solution vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac54f45f37a38426db1b5f85eccc7b3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54f45f37a38426db1b5f85eccc7b3e9">&#9670;&nbsp;</a></span>compare_derivatives_with_numerical_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::compare_derivatives_with_numerical_derivatives </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt;&#160;</td>
          <td class="paramname"><em>solution_ref_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>detailed_printout_file</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method compares the finite element system obtained with <a class="el" href="class_assembly_helper.html#a5146802e9d7d4bc5df7fe35909da3e44">AssemblyHelper::assemble_system()</a> with numerically computed equivalents.</p>
<p>The numerically computed right hand side is based on a finite difference quotient of the total potential, and the numerically computed system matrix is based on a finite difference quotient of the right hand side of the finite element system. I.e., the numerically computed right hand side can only be "correct" (to within the accuracy of the finite difference approach) if the total potential is correctly implemented; and the numerically computed system matrix can only be "correct" (to within the accuracy of the finite difference approach) if the right hand side is correctly implemented. This fact can be used to check the implementation, which is the main purpose of this method.</p>
<p>For comparison of the finite element systems, the dense system <img class="formulaInl" alt="$\left( \boldsymbol{K} + \boldsymbol{L} \boldsymbol{\Pi} \boldsymbol{L}^\top \right) \Delta\boldsymbol{\hat u} = - \boldsymbol{f}$" src="form_47.png"/> is used instead of the stretched system provided by <a class="el" href="class_assembly_helper.html#a5146802e9d7d4bc5df7fe35909da3e44">AssemblyHelper::assemble_system()</a>. This, however, means that this method is dealing internally with dense matrices. As a consequence, the method can only be used for very small test problems.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Presently, the method does not allow to take into account any constraints. This should be incorporated in future releases of the library.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>Point of linearization <img class="formulaInl" alt="$\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$" src="form_48.png"/>, where the values of <img class="formulaInl" alt="$\boldsymbol{\hat \lambda}$" src="form_45.png"/> are not used and are, therefore, arbitrary. The appropriate size of <code>solution</code> can be obtained from <a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">AssemblyHelper::system_size()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_ref_sets</td><td>Sets of reference solution vectors, which can e.g. be the solution vectors of previous times steps. Make sure that you pass at least as many reference sets here as are required by the <a class="el" href="class_scalar_functional.html">ScalarFunctional</a> objects (see <a class="el" href="class_scalar_functional.html#adb295fb739a743d5a1273025eb8dae72">ScalarFunctional::get_h_sigma()</a> and <a class="el" href="class_scalar_functional_3_01spacedim_00_01spacedim_01_4.html#a8665cb5b5a57ad22217e4c112845d43b">ScalarFunctional&lt;spacedim, spacedim&gt;::get_h_omega()</a>) and the <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a> objects (see <a class="el" href="class_total_potential_contribution.html#a515786e58c1fda7baf168be8f4a13720">TotalPotentialContribution::get_potential_contribution()</a>) to complete their computations. In general, the order of the sets of reference values in <a class="el" href="class_scalar_functional.html#adb295fb739a743d5a1273025eb8dae72">ScalarFunctional::get_h_sigma()</a>, <a class="el" href="class_scalar_functional_3_01spacedim_00_01spacedim_01_4.html#a8665cb5b5a57ad22217e4c112845d43b">ScalarFunctional&lt;spacedim, spacedim&gt;::get_h_omega()</a>, and <a class="el" href="class_total_potential_contribution.html#a515786e58c1fda7baf168be8f4a13720">TotalPotentialContribution::get_potential_contribution()</a> corresponds to the order in <code>solution_ref_sets</code>. If e.g. a function <a class="el" href="class_scalar_functional.html#adb295fb739a743d5a1273025eb8dae72">ScalarFunctional::get_h_sigma()</a> requires two reference sets of dependent variable values while <code>solution_ref_sets</code> contains more than two reference sets of dof values, the first two sets from <code>solution_ref_sets</code> will be used to obtain the reference sets of dependent variable values.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detailed_printout_file</td><td>A file to which detailed printout is written (if no file name is provided, the results of the comparison will just be written to screen)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>Step width for finite difference computation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e96514d9d023949eb07d95b5a2214c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e96514d9d023949eb07d95b5a2214c4">&#9670;&nbsp;</a></span>compute_distance_to_exact_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const double, const double&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::compute_distance_to_exact_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a>&lt; spacedim &gt;&#160;</td>
          <td class="paramname"><em>quadrature_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a>&lt; spacedim-1 &gt;&#160;</td>
          <td class="paramname"><em>quadrature_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__numerics.html#ga69967cb7a148a7169963126249213db1">VectorTools::NormType</a>&#160;</td>
          <td class="paramname"><em>norm_type</em> = <code>VectorTools::NormType::L2_norm</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>&#160;</td>
          <td class="paramname"><em>component_mask_domain</em> = <code><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>&#160;</td>
          <td class="paramname"><em>component_mask_interface</em> = <code><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function computing the "distance" of the solution vector <code>solution</code> to an exact solution.</p>
<p>The exact and the numerical solution are subtracted and finally the norm of the resulting difference is computed numerically on the mesh of this <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>. This is done for the domain related and the interface related part separately.</p>
<p>Note that the values of the independent scalars are currently not taken into account in this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>The solution <img class="formulaInl" alt="$\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$" src="form_48.png"/>, where the values of <img class="formulaInl" alt="$\boldsymbol{\hat \lambda}$" src="form_45.png"/> are not used and are, therefore, arbitrary. The appropriate size of <code>solution</code> can be obtained from <a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">AssemblyHelper::system_size()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exact_solution_domain</td><td>Exact solution on domain (use <a class="el" href="class_assembly_helper.html#a39d6fed5b90cee2e2e972e294ececffb">AssemblyHelper::get_u_omega_global_component_indices()</a> to obtain information about the component indexing)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exact_solution_interface</td><td>Exact solution on interface (use <a class="el" href="class_assembly_helper.html#afe7df3baf877b83b7c98b7f389fa2926">AssemblyHelper::get_u_sigma_global_component_indices()</a> to obtain information about the component indexing)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature_domain</td><td><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a> scheme to be used on the domain for the computation of the norm</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature_interface</td><td><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a> scheme to be used on the interface for the computation of the norm</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">norm_type</td><td>Type of the norm</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask_domain</td><td>Domain related solution components to be included in the calculation. If the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a> is empty, all components will be included.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask_interface</td><td>Interface related solution components to be included in the calculation. If the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a> is empty, all components will be included.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exponent</td><td>Exponent of the norm if required</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the norm computed on the domain and the interface, respectively </dd></dl>

</div>
</div>
<a id="a94bb821b6258eab0bb3a9046b6d9158a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bb821b6258eab0bb3a9046b6d9158a">&#9670;&nbsp;</a></span>compute_distance_to_other_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const double, const double&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::compute_distance_to_other_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>other_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_assembly_helper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a>&lt; spacedim &gt;&#160;</td>
          <td class="paramname"><em>quadrature_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a>&lt; spacedim-1 &gt;&#160;</td>
          <td class="paramname"><em>quadrature_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__numerics.html#ga69967cb7a148a7169963126249213db1">VectorTools::NormType</a>&#160;</td>
          <td class="paramname"><em>norm_type</em> = <code>VectorTools::NormType::L2_norm</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>&#160;</td>
          <td class="paramname"><em>component_mask_domain</em> = <code><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>&#160;</td>
          <td class="paramname"><em>component_mask_interface</em> = <code><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>scaling_domain</em> = <code><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespaceLinearAlgebraTrilinos_1_1MPI.html#a6c5bf277e53c73f3d252d6a8455c21a4">dealii::Vector</a>&lt;&#160;double&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>scaling_interface</em> = <code><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespaceLinearAlgebraTrilinos_1_1MPI.html#a6c5bf277e53c73f3d252d6a8455c21a4">dealii::Vector</a>&lt;&#160;double&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function computing the "distance" of the solution vector <code>solution</code> of this <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> to the solution <code>other_solution</code> of another <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> object (the AssemblyHelpers must be the same apart from the mesh refinement, in particular they must be based on the same coarse mesh).</p>
<p>Note that the values of the independent scalars are currently not taken into account in this method.</p>
<p>The solution of the other <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> is interpolated to the mesh of this <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>, then both solutions are subtracted and finally the norm of the resulting difference is computed numerically on the mesh of this <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>. This is done for the domain related and the interface related part separately.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Hanging node constraints are currently not taken care of after interpolation of the solution. Also not all <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__numerics.html#ga69967cb7a148a7169963126249213db1">VectorTools::NormType</a> norms are implemented yet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>The solution <img class="formulaInl" alt="$\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$" src="form_48.png"/>, where the values of <img class="formulaInl" alt="$\boldsymbol{\hat \lambda}$" src="form_45.png"/> are not used and are, therefore, arbitrary. The appropriate size of <code>solution</code> can be obtained from <a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">AssemblyHelper::system_size()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_solution</td><td>The solution <img class="formulaInl" alt="$\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$" src="form_48.png"/> of the other <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>, where the values of <img class="formulaInl" alt="$\boldsymbol{\hat \lambda}$" src="form_45.png"/> are not used and are, therefore, arbitrary. The appropriate size of <code>solution</code> can be obtained from <a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">AssemblyHelper::system_size()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">other_assembly_helper</td><td>The other <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> object</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature_domain</td><td><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a> scheme to be used on the domain for the computation of the norm</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature_interface</td><td><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classQuadrature.html">Quadrature</a> scheme to be used on the interface for the computation of the norm</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">norm_type</td><td>Type of the norm (note: currently only <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__numerics.html#ga69967cb7a148a7169963126249213db1">VectorTools::NormType</a>::<code>L2_norm</code>, <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__numerics.html#ga69967cb7a148a7169963126249213db1">VectorTools::NormType</a>::<code>Linfty_norm</code>, <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__numerics.html#ga69967cb7a148a7169963126249213db1">VectorTools::NormType</a>::<code>H1_seminorm</code> and <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__numerics.html#ga69967cb7a148a7169963126249213db1">VectorTools::NormType</a>::<code>W1infty_seminorm</code> are implemented)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask_domain</td><td>Domain related solution components to be included in the calculation. If the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a> is empty, all components will be included</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask_interface</td><td>Interface related solution components to be included in the calculation. If the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classComponentMask.html">ComponentMask</a> is empty, all components will be included</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exponent</td><td>Exponent of the norm if required. Currently this is unused because no norms with variable exponent are implemented.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaling_domain</td><td>Scaling factors to be used for errors of individual solution components on domain, if empty, scaling factors are set to 1.0</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scaling_interface</td><td>Scaling factors to be used for errors of individual solution components on interface, if empty, scaling factors are set to 1.0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the norm computed on the domain and the interface, respectively </dd></dl>

</div>
</div>
<a id="a5e29275d9ec1c479375707fbc670bc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e29275d9ec1c479375707fbc670bc8c">&#9670;&nbsp;</a></span>compute_e_omega()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::compute_e_omega </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>internal_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>scalar_functional_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>q_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_u_omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>e_omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>de_omega_dsol_T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>compute_derivative</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_constants</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to compute the dependent fields on the domain ( <img class="formulaInl" alt="$e^\Omega_\lambda$" src="form_11.png"/>) and the derivatives w.r.t. the relevant dofs at a quadrature point.</p>
<p>It is assumed that all quantities except <code>de_omega_dsol_T</code> have the correct size when passed in and that the required <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a> objects are properly initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_index</td><td>internal index of domain portion</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_functional_index</td><td>scalar functional index within domain portion</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q_point</td><td>quadrature point</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_u_omega</td><td>local solution vector for dofs related to domain related independent fields (in scalar functional related shape function indexing)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_C</td><td>local solution vector for dofs related to independent scalars (in scalar functional related independent scalar indexing)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e_omega</td><td>computed values of the dependent fields</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">de_omega_dsol_T</td><td>derivatives of the dependent fields w.r.t. the local dofs (each row in <code>de_omega_dsol_T</code> corresponds either to a domain related dof or to an independent scalar; the domain related dofs come first with the same indexing as for <code>solution_u_omega</code>, and the independent scalars follow with the same indexing as for <code>solution_C</code>; the size of <code>de_omega_dsol_T</code> is (<code>solution_omega.size()</code> + <code>solution_C.size()</code>) x <code>e_omega.size()</code>)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_derivative</td><td>indicates whether <code>de_omega_dsol_T</code> is to be computed or not</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_constants</td><td>If <code>true</code>, the constant terms in the dependent fields are ignored (this is required for the computation of increments of dependent fields upon increments of the solution) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1906ba80994e8bb136ccf466fd7611d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1906ba80994e8bb136ccf466fd7611d5">&#9670;&nbsp;</a></span>compute_e_sigma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::compute_e_sigma </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>internal_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>scalar_functional_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>q_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_u_sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_u_omega_minus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_u_omega_plus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution_C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices_interface_dof_indices_combined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices_minus_dof_indices_combined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices_plus_dof_indices_combined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices_C_dof_indices_combined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices_global_combined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>e_sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFullMatrix.html">FullMatrix</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>de_sigma_dsol_T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>compute_derivative</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ignore_constants</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to compute the dependent fields on the domain ( <img class="formulaInl" alt="$e^\Sigma_\nu$" src="form_22.png"/>) and the derivatives w.r.t. the relevant dofs at a quadrature point.</p>
<p>It is assumed that all quantities except <code>de_sigma_dsol_T</code> have the correct size when passed in and that the required <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a> objects are properly initialized.</p>
<p>The indexing of dofs used here is a bit awkward, but is necessary to treat duplicate dofs on the minus and the plus side. See <a class="el" href="namespace_auxiliary.html#a1d90ebc8738df3d8c70b540034137019">Auxiliary::combine_dof_indices()</a> for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_index</td><td>internal index of interface (sub)portion</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_functional_index</td><td>scalar functional index within interface (sub)portion</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q_point</td><td>quadrature point</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_u_sigma</td><td>local solution vector for dofs related to interface related independent fields (in scalar functional related shape function indexing)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_u_omega_minus</td><td>local solution vector for dofs related to domain related independent fields on minus side (in scalar functional related shape function indexing)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_u_omega_plus</td><td>local solution vector for dofs related to domain related independent fields on plus side (in scalar functional related shape function indexing)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_C</td><td>local solution vector for dofs related to independent scalars (in scalar functional related independent scalar indexing)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices_interface_dof_indices_combined</td><td><code>dof_indices_interface_dof_indices_combined</code>[<code>i</code>] is the row in <code>de_sigma_dsol_T</code> and <code>dof_indices_global_combined</code> corresponding to <code>solution_u_sigma</code>[<code>i</code>]</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices_minus_dof_indices_combined</td><td><code>dof_indices_minus_dof_indices_combined</code>[<code>i</code>] is the row in <code>de_sigma_dsol_T</code> and <code>dof_indices_global_combined</code> corresponding to <code>solution_u_omega_minus</code>[<code>i</code>]</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices_plus_dof_indices_combined</td><td><code>dof_indices_plus_dof_indices_combined</code>[<code>i</code>] is the row in <code>de_sigma_dsol_T</code> and <code>dof_indices_global_combined</code> corresponding to <code>solution_u_omega_plus</code>[<code>i</code>]</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices_C_dof_indices_combined</td><td><code>dof_indices_C_dof_indices_combined</code>[<code>i</code>] is the row in <code>de_sigma_dsol_T</code> and <code>dof_indices_global_combined</code> corresponding to <code>solution_C</code>[<code>i</code>]</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_indices_global_combined</td><td>combined global dof indices, see also <a class="el" href="namespace_auxiliary.html#a1d90ebc8738df3d8c70b540034137019">Auxiliary::combine_dof_indices()</a>; this parameter is not really used inside the function except to determine the correct size of <code>de_sigma_dsol_T</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e_sigma</td><td>computed values of the dependent fields</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">de_sigma_dsol_T</td><td>derivatives of the dependent fields w.r.t. the local dofs (each row in <code>de_sigma_dsol_T</code> corresponds either to an interface related dof, or to a domain related dof on the minus side, or to a domain related dof on the plus side, or to an independent scalar; the indexing is determined by <code>dof_indices_interface_dof_indices_combined</code>, <code>dof_indices_minus_dof_indices_combined</code>, <code>dof_indices_plus_dof_indices_combined</code>, <code>dof_indices_C_dof_indices_combined</code> and is consistent with the indexing in <code>dof_indices_global_combined</code>; the size of <code>de_sigma_dsol_T</code> is <code>dof_indices_global_combined.size()</code> x <code>e_sigma.size()</code> )</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compute_derivative</td><td>indicates whether <code>de_sigma_dsol_T</code> is to be computed or not</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_constants</td><td>If <code>true</code>, the constant terms in the dependent fields are ignored (this is required for the computation of increments of dependent fields upon increments of the solution) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad21ced11a2d90c804827854c18f7f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad21ced11a2d90c804827854c18f7f89">&#9670;&nbsp;</a></span>convert_dependent_fields_to_shapefunctions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::convert_dependent_fields_to_shapefunctions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function converts the dependent field definitions into a format suitable for assembly of the finite element system (essentially by defining how each dependent field is related to the shape functions and, possibly, the derivatives thereof). This member initializes the following member variables: <a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a>, <a class="el" href="class_assembly_helper.html#ab346e146cf91fb7a0688076551b37355">AssemblyHelper::coupled_dof_indices_scalar_functionals_interface</a>, <a class="el" href="class_assembly_helper.html#a12299d82365553a21fef8529c8fe8a17">AssemblyHelper::coupled_dof_indices_scalar_functionals_interface_minus</a>, <a class="el" href="class_assembly_helper.html#af07bb528fdd350e9b467b08dc44a03e7">AssemblyHelper::coupled_dof_indices_scalar_functionals_interface_plus</a>, <a class="el" href="class_assembly_helper.html#a0edd25820c92a25ae87fc240f4916804">AssemblyHelper::coupled_C_indices_scalar_functionals_domain</a>, <a class="el" href="class_assembly_helper.html#a311e176038ee2b7ca0719abb384ca57b">AssemblyHelper::coupled_C_indices_scalar_functionals_interface</a>, <a class="el" href="class_assembly_helper.html#a13fef9096e5fc7b1e922ea78d7aa2c28">AssemblyHelper::a_omega</a>, <a class="el" href="class_assembly_helper.html#a5fbb532e798c2427af5285c2df10c9f4">AssemblyHelper::b_omega</a>, <a class="el" href="class_assembly_helper.html#a75e6f76c0b12b91c5feb230251f0137f">AssemblyHelper::c_omega</a>, <a class="el" href="class_assembly_helper.html#ad93b109608d4425d318434e01cb6246c">AssemblyHelper::d_omega</a>, <a class="el" href="class_assembly_helper.html#aa266cc07e9670319481da52d633d2583">AssemblyHelper::a_sigma</a>, <a class="el" href="class_assembly_helper.html#af58c9a1c7093edc306070913aa1b9be2">AssemblyHelper::b_sigma</a>, <a class="el" href="class_assembly_helper.html#a4461be378c9be0364ca23153c367d24c">AssemblyHelper::a_minus</a>, <a class="el" href="class_assembly_helper.html#a6f51f8b4dfdae385a2e2fe2dd9e66cdb">AssemblyHelper::b_minus</a>, <a class="el" href="class_assembly_helper.html#a8eb513a6239d94cc0f1a6a01a037c572">AssemblyHelper::a_plus</a>, <a class="el" href="class_assembly_helper.html#ab09dd07d3ec596525be83f8f5859bef7">AssemblyHelper::b_plus</a>, <a class="el" href="class_assembly_helper.html#ab3d4370661ba726010ee687ef0e98140">AssemblyHelper::c_sigma</a>, <a class="el" href="class_assembly_helper.html#a48d7d677120eb1c84b4983f470246e02">AssemblyHelper::d_sigma</a>. </p>

</div>
</div>
<a id="a953859cc4cd745a1b51fdec5418be682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953859cc4cd745a1b51fdec5418be682">&#9670;&nbsp;</a></span>distribute_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::distribute_dofs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This distributes the dofs. This function is called automatically after construction of an <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> object as well as after a change of the mesh. It makes sure that the active fe indices are updated before distributing the dofs. </p>

</div>
</div>
<a id="a60a2aa2aa08149682feca02e458232d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a2aa2aa08149682feca02e458232d4">&#9670;&nbsp;</a></span>generate_sparsity_pattern_by_simulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::generate_sparsity_pattern_by_simulation </td>
          <td>(</td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>dsp_K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineConstraints&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate the current sparsity pattern by simulation of the assembly process, thereby taking into account the particular structure of the total potential function.</p>
<p>The sparsity pattern must be initialized correctly outside this function. For the parallel case, don't forget to distribute the sparsity pattern after this function is called in order to make sure that every processor knows about its non-zero entries (entries in the sparsity pattern owned by a processor <code>i</code> may actually be written by a different processor <code>j</code>). See also the deal.II function <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespaceSparsityTools.html#ae2c7bdbdb62642f60d60087e4cb6195f">SparsityTools::distribute_sparsity_pattern()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dsp_K</td><td>the resulting sparsity pattern for the stretched system matrix <img class="formulaInl" alt="$\boldsymbol{K}^\mathrm{s}$" src="form_42.png"/></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints</td><td>constraints to be taken into consideration when building the sparsity pattern</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SparsityPatternType</td><td>the type of the sparsity pattern</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>The treatment of local fields and locally eliminated fields needs to be completely revised!</dd></dl>

</div>
</div>
<a id="a04523eef6062ced8c88d4c093b65df3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04523eef6062ced8c88d4c093b65df3d">&#9670;&nbsp;</a></span>get_dof_handler_system() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a>&lt;spacedim&gt;&amp; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_dof_handler_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function returning the <a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a>. This function does return a non-const reference and can, therefore, for example be used for reordering of dof indices if desired.</p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a> <a class="el" href="class_assembly_helper.html#a885e660c749e91a35e3279643ebcd87f">AssemblyHelper::dof_handler_system</a> </dd></dl>

</div>
</div>
<a id="a095623df46217c89ee8e786f6e8a3034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095623df46217c89ee8e786f6e8a3034">&#9670;&nbsp;</a></span>get_dof_handler_system() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a>&lt;spacedim&gt;&amp; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_dof_handler_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function returning the <a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a></p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a> <a class="el" href="class_assembly_helper.html#a885e660c749e91a35e3279643ebcd87f">AssemblyHelper::dof_handler_system</a> </dd></dl>

</div>
</div>
<a id="ad798d22d994c4c18a05503ae9db4b408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad798d22d994c4c18a05503ae9db4b408">&#9670;&nbsp;</a></span>get_dof_index_at_point_omega()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_dof_index_at_point_omega </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>u_omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>ignore_dofs</em> = <code>std::set&lt;&#160;unsigned&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u_omega</td><td>independent field</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component</td><td>component</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>point</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_dofs</td><td>dofs to ignore during search - this allows for finding duplicate dofs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global dof index of <code>component</code> of <code>u_omega</code> at point <code>point</code> . This requires that the FE used for the independent field has support points defined. </dd></dl>

</div>
</div>
<a id="a256dc4f0fc5c62f130d75734ea94249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256dc4f0fc5c62f130d75734ea94249f">&#9670;&nbsp;</a></span>get_dof_index_at_point_sigma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_dof_index_at_point_sigma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim-1, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>u_sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>ignore_dofs</em> = <code>std::set&lt;&#160;unsigned&#160;int&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u_sigma</td><td>independent field</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component</td><td>component</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>point</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_dofs</td><td>dofs to ignore during search - this allows for finding duplicate dofs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global dof index of <code>component</code> of <code>u_sigma</code> at point <code>point</code> . This requires that the FE used for the independent field has support points defined. </dd></dl>

</div>
</div>
<a id="ae339631f070dbe766d84697cd9229134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae339631f070dbe766d84697cd9229134">&#9670;&nbsp;</a></span>get_dof_indices_C()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_dof_indices_C </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_dof_indices_C</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">global_dof_indices_C</td><td>vector with the global dof indices corresponding to the independent scalars stored in <a class="el" href="class_assembly_helper.html#aa5234a46be82cfe7d92678169d38f326">AssemblyHelper::C</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b6e5ff3a45411c2b8b42777fa94ec40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b6e5ff3a45411c2b8b42777fa94ec40">&#9670;&nbsp;</a></span>get_global_dof_index_C()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_global_dof_index_C </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; 0, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>independent_scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method returning the global dof index of an independent scalar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">independent_scalar</td><td>independent scalar</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the global dof index corresponding to <code>independent_scalar</code> </dd></dl>

</div>
</div>
<a id="a4043c993c8902ad5d3045a13ed42e6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4043c993c8902ad5d3045a13ed42e6f8">&#9670;&nbsp;</a></span>get_initial_fields_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_initial_fields_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>initial_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineConstraints&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>constraints</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method returning the global initial fields vector (i.e., a vector containing the initial dof values) as defined by <a class="el" href="class_independent_field.html#a274c902785d2937a6065f7e09f3976c3">IndependentField::initial_vals</a> and <a class="el" href="class_independent_field_3_010_00_01spacedim_01_4.html#a8c4c434806dadc5b885102322e27357c">IndependentField&lt;0, spacedim&gt;::initial_value</a>. The vector has the format <img class="formulaInl" alt="$\begin{pmatrix} \boldsymbol{u}^\mathrm{initial} \\ \boldsymbol{0} \end{pmatrix}$" src="form_39.png"/>. Here, <img class="formulaInl" alt="$\boldsymbol{u}^\mathrm{initial}$" src="form_40.png"/> contains the initial dof values, with the dofs of <a class="el" href="class_assembly_helper.html#a885e660c749e91a35e3279643ebcd87f">AssemblyHelper::dof_handler_system</a> being first, followed by the independent scalar dofs (i.e., the size of <img class="formulaInl" alt="$\boldsymbol{u}^\mathrm{initial}$" src="form_40.png"/> is <a class="el" href="class_assembly_helper.html#a885e660c749e91a35e3279643ebcd87f">AssemblyHelper::dof_handler_system</a>.<a class="el" href="class_do_f_handler_system.html#a649873cd660a9888cd4ff29c35b1df2a">n_dofs_domain() </a> + <a class="el" href="class_assembly_helper.html#a885e660c749e91a35e3279643ebcd87f">AssemblyHelper::dof_handler_system</a>.<a class="el" href="class_do_f_handler_system.html#ab0157b6d29707c6657d21610f2bfe05d">n_dofs_interface() </a> + <a class="el" href="class_assembly_helper.html#aa5234a46be82cfe7d92678169d38f326">AssemblyHelper::C</a><code></code>.size()). The <img class="formulaInl" alt="$\boldsymbol{0}$" src="form_41.png"/> vector corresponds to the additional lines in the finite element system associated with the scalar functionals and independent scalars entering the total potential non-primitively (i.e., it has size <a class="el" href="class_assembly_helper.html#af7bcfc1db651535a7aefc6071a81e124">AssemblyHelper::n_scalar_functionals_nonprimitive</a> + <a class="el" href="class_assembly_helper.html#aa5234a46be82cfe7d92678169d38f326">AssemblyHelper::C</a><code></code>.size()). Note, in this context, that the independent scalars always enter the total potential non-primitively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">initial_fields</td><td>initial fields (the vector must be passed in with the correct size, the appropriate size can be queried by <a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">AssemblyHelper::system_size()</a>)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints</td><td>if a constraint matrix is passed, the initial fields will be made consistent with these constraints</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>The type used for the initial fields vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently, this method only works if the underlying base elements are either associated with support points or only have a single vector component. In the former case, the values at the support points are assigned. In the latter case, a constant value based on the initial field value at the center is prescribed for each cell if the element has constant modes allowing for this procedure. Other cases are not currently implemented. </dd></dl>

</div>
</div>
<a id="a8ecc73fbc0e71716805c97498a83833a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecc73fbc0e71716805c97498a83833a">&#9670;&nbsp;</a></span>get_locally_owned_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classIndexSet.html">IndexSet</a> <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_locally_owned_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The set of locally owned dofs (including the stretched rows; ownership of the stretched rows is assigned to the last processor) </dd></dl>

</div>
</div>
<a id="af1a81fd16e7692501189d9c0bd96bc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a81fd16e7692501189d9c0bd96bc2d">&#9670;&nbsp;</a></span>get_locally_owned_indices_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classIndexSet.html">IndexSet</a>&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_locally_owned_indices_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Same as <a class="el" href="class_assembly_helper.html#a8ecc73fbc0e71716805c97498a83833a">AssemblyHelper::get_locally_owned_indices()</a>, but block-wise (the first index set contains the fe related indices, and the second index set the rest) </dd></dl>

</div>
</div>
<a id="a30584e0ed1b2564e9b66ce9cecae40c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30584e0ed1b2564e9b66ce9cecae40c7">&#9670;&nbsp;</a></span>get_locally_relevant_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classIndexSet.html">IndexSet</a> <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_locally_relevant_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The set of locally relevant indices (including the stretched rows) </dd></dl>

</div>
</div>
<a id="a5f47fad7f7f2a83a7f54cd38825c703a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f47fad7f7f2a83a7f54cd38825c703a">&#9670;&nbsp;</a></span>get_locally_relevant_indices_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classIndexSet.html">IndexSet</a>&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_locally_relevant_indices_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Same as <a class="el" href="class_assembly_helper.html#a30584e0ed1b2564e9b66ce9cecae40c7">AssemblyHelper::get_locally_relevant_indices()</a>, but block-wise (the first index contains the fe related indices, and the second block the rest) </dd></dl>

</div>
</div>
<a id="a310594206df2622027fdc48e84600bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310594206df2622027fdc48e84600bf7">&#9670;&nbsp;</a></span>get_maximum_step_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_maximum_step_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt;&#160;</td>
          <td class="paramname"><em>solution_ref_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>delta_solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method determining the maximum permissible step length into a certain direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>the current global solution vector</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_ref_sets</td><td>a set of reference solution vectors (e.g. solutions at previous time steps), which may enter into the calculation of the scalar functionals</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delta_solution</td><td>The direction into which the solution is updated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum step length alpha such that solution + alpha*delta_solution is a permissible state</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>The type used for the solution vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b9603ede43f9abae845caf60e52d4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9603ede43f9abae845caf60e52d4a1">&#9670;&nbsp;</a></span>get_n_C()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_n_C </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of independent scalars attached to the <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> </dd></dl>

</div>
</div>
<a id="a781fcbb9a157621c8db25d8ef46aca13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781fcbb9a157621c8db25d8ef46aca13">&#9670;&nbsp;</a></span>get_n_stretched_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_n_stretched_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_assembly_helper.html#af7bcfc1db651535a7aefc6071a81e124">AssemblyHelper::n_scalar_functionals_nonprimitive</a> + AssemblyHelper::C.size() </dd></dl>

</div>
</div>
<a id="acf6ef2dced66e223684e5df97182f428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6ef2dced66e223684e5df97182f428">&#9670;&nbsp;</a></span>get_nonprimitive_scalar_functional_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_nonprimitive_scalar_functional_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt;&#160;</td>
          <td class="paramname"><em>solution_ref_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; *, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonprimitive_scalar_functional_values_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; *, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonprimitive_scalar_functional_values_interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method computing the values of the scalar functionals entering non-primitively into the total potential</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>the global solution vector</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_ref_sets</td><td>a set of reference solution vectors (e.g. solutions at previous time steps), which may enter into the calculation of the scalar functionals</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nonprimitive_scalar_functional_values_domain</td><td>Values of domain related scalar functionals entering non-primitively into the total potential.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nonprimitive_scalar_functional_values_interface</td><td>Values of interface related scalar functionals entering non-primitively into the total potential.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the evaluation of the scalar functionals was successful, and <code>true</code> if an error prevented the proper calculation of these quantities</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>The type used for the solution vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe88d8ccfd69bbfcfc56551c5c7d67e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe88d8ccfd69bbfcfc56551c5c7d67e9">&#9670;&nbsp;</a></span>get_nonprimitive_scalar_functional_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_nonprimitive_scalar_functional_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> * &gt;&#160;</td>
          <td class="paramname"><em>solution_ref_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classVector.html">Vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonprimitive_scalar_functional_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method computing the values of the scalar functionals entering non-primitively into the total potential</p>
<p>This method is required since the assembly of the finite element system cannot be done before the current values of the scalar functionals entering non-primitively into the total potential are known.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>the global solution vector</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution_ref_sets</td><td>a set of reference solution vectors (e.g. solutions at previous time steps), which may enter into the calculation of the scalar functionals</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nonprimitive_scalar_functional_values</td><td>Values of scalar functionals entering non-primitively into the total potential. The indexing is according to <a class="el" href="class_assembly_helper.html#acf05fab2ddf57769a103d82a4f2d1cd3">AssemblyHelper::scalar_functionals_domain_nonprimitive_indices</a> and <a class="el" href="class_assembly_helper.html#a0d15b3ab0c7bec9fc4f40e532f8776f4">AssemblyHelper::scalar_functionals_interface_nonprimitive_indices</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the evaluation of the scalar functionals was successful, and <code>true</code> if an error prevented the proper calculation of these quantities</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>The type used for the solution vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2778924ff66c8ad8695f0cd3da5ced9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2778924ff66c8ad8695f0cd3da5ced9f">&#9670;&nbsp;</a></span>get_scalar_functional_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const int, const int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_scalar_functional_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>scalar_functional</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function returning nonprimitive index of a domain related scalar functional according to <a class="el" href="class_assembly_helper.html#acf05fab2ddf57769a103d82a4f2d1cd3">AssemblyHelper::scalar_functionals_domain_nonprimitive_indices</a> as well as the primitive index of that scalar functional according to <a class="el" href="class_assembly_helper.html#a4f08790a2235e48ce19f5d8d965a7874">AssemblyHelper::scalar_functionals_domain_primitive_indices</a>. Note that both indices may exist, because a certain scalar functional may enter different <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a> objects, with some being primitive and others non-primitive. If <code>scalar_functional</code> is not related to any non-primitive <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a>, the first of the returned indices will be <code>-1</code>; and if <code>scalar_functional</code> is not related to any primitive <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a>, the second of the returned indices is <code>-1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_functional</td><td>the domain related scalar functional for which the indices are requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(non-primitive index, primitive index) </dd></dl>

</div>
</div>
<a id="a3e3f6a06344be172d9419b26bb085073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3f6a06344be172d9419b26bb085073">&#9670;&nbsp;</a></span>get_scalar_functional_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const int, const int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_scalar_functional_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt; spacedim-1, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>scalar_functional</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function returning nonprimitive index of an interface related scalar functional according to <a class="el" href="class_assembly_helper.html#a0d15b3ab0c7bec9fc4f40e532f8776f4">AssemblyHelper::scalar_functionals_interface_nonprimitive_indices</a> as well as the primitive index of that scalar functional according to <a class="el" href="class_assembly_helper.html#ad99c75f32cf3f18aa1d4067ad8b56ae8">AssemblyHelper::scalar_functionals_interface_primitive_indices</a>. Note that both indices may exist, because a certain scalar functional may enter different <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a> objects, with some being primitive and others non-primitive. If <code>scalar_functional</code> is not related to any non-primitive <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a>, the first of the returned indices will be <code>-1</code>; and if <code>scalar_functional</code> is not related to any primitive <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a>, the second of the returned indices is <code>-1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_functional</td><td>the interface related scalar functional for which the indices are requested</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(non-primitive index, primitive index) </dd></dl>

</div>
</div>
<a id="a16f9d21a79922d4879e37916b414f7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f9d21a79922d4879e37916b414f7d0">&#9670;&nbsp;</a></span>get_triangulation_system() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt;spacedim&gt;&amp; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_triangulation_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function returning the <a class="el" href="class_triangulation_system.html">TriangulationSystem</a></p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_triangulation_system.html">TriangulationSystem</a> <a class="el" href="class_assembly_helper.html#add08a8a7bb9c9325fcc7d92bfce525d4">AssemblyHelper::tria_system</a> </dd></dl>

</div>
</div>
<a id="a42cc83a6b33fe48b04fa8f4c9907cbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cc83a6b33fe48b04fa8f4c9907cbb8">&#9670;&nbsp;</a></span>get_triangulation_system() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt;spacedim&gt;&amp; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_triangulation_system </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function returning the <a class="el" href="class_triangulation_system.html">TriangulationSystem</a></p>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_triangulation_system.html">TriangulationSystem</a> <a class="el" href="class_assembly_helper.html#add08a8a7bb9c9325fcc7d92bfce525d4">AssemblyHelper::tria_system</a> </dd></dl>

</div>
</div>
<a id="af65861aae14b724a631feaf56c82ae9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65861aae14b724a631feaf56c82ae9a">&#9670;&nbsp;</a></span>get_u_omega_global_component_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_u_omega_global_component_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_omega</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the global component index (in the domain related <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESystem.html">FESystem</a>) of the first component of <code>u_omega</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u_omega</td><td>The domain related independent field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global component index </dd></dl>

</div>
</div>
<a id="a39d6fed5b90cee2e2e972e294ececffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d6fed5b90cee2e2e972e294ececffb">&#9670;&nbsp;</a></span>get_u_omega_global_component_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;const <a class="el" href="class_independent_field.html">IndependentField</a>&lt;spacedim, spacedim&gt;*, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_u_omega_global_component_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>map between domain related <a class="el" href="class_independent_field.html">IndependentField</a> objects and the global component indices (in the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESystem.html">FESystem</a>) of the first components of the respective <a class="el" href="class_independent_field.html">IndependentField</a> objects </dd></dl>

</div>
</div>
<a id="a4ad9cb7482bfc3ce527ad7639a8d5843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad9cb7482bfc3ce527ad7639a8d5843">&#9670;&nbsp;</a></span>get_u_sigma_global_component_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_u_sigma_global_component_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_independent_field.html">IndependentField</a>&lt; spacedim-1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>u_sigma</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the global component index (in the interface related <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESystem.html">FESystem</a>) of the first component of <code>u_sigma</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">u_sigma</td><td>The interface related independent field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>global component index </dd></dl>

</div>
</div>
<a id="afe7df3baf877b83b7c98b7f389fa2926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7df3baf877b83b7c98b7f389fa2926">&#9670;&nbsp;</a></span>get_u_sigma_global_component_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;const <a class="el" href="class_independent_field.html">IndependentField</a>&lt;spacedim-1, spacedim&gt;*, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::get_u_sigma_global_component_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>map between interface related <a class="el" href="class_independent_field.html">IndependentField</a> objects and the global component indices (in the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESystem.html">FESystem</a>) of the first components of the respective <a class="el" href="class_independent_field.html">IndependentField</a> objects </dd></dl>

</div>
</div>
<a id="a95639ce05d10d6aa37ea6ae5962753e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95639ce05d10d6aa37ea6ae5962753e2">&#9670;&nbsp;</a></span>initialize_fe_values_domain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::initialize_fe_values_domain </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classDoFHandler.html">DoFHandler</a>&lt; spacedim, spacedim &gt;::<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__Iterators.html#ga661664adfd3a341a678e5ac62f85185a">active_cell_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>internal_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>nonprimitive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to initialize the required <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a> objects for assembly of the contribution of a domain cell to the finite element system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The domain cell</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_index</td><td>The internal index of the domain portion the domain cell belongs to. In principle, the function could determine the <code>internal_index</code> from <code>cell</code>. However, typically it is already known when the function is called and therefore it is passed here as an argument.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonprimitive</td><td>if <code>true:</code> initialize only those <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a> objects needed for evaluation of the scalar functionals entering non-primitively into the total potential </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a223bbebe8a1f0aa09a53ee19257b927e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223bbebe8a1f0aa09a53ee19257b927e">&#9670;&nbsp;</a></span>initialize_fe_values_interface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::initialize_fe_values_interface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_interface_cell_domain_cells_do_f.html">InterfaceCellDomainCellsDoF</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_cell_domain_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>internal_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>nonprimitive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to initialize the required <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a> objects for assembly of the contribution of an interface cell (and the neighboring domain cells) to the finite element system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interface_cell_domain_cells</td><td>The interface cell (and the neighboring domain cells)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_index</td><td>The internal index of the interface (sub)portion the interface cell belongs to. In principle, the function could determine the <code>internal_index</code> from <code>interface_cell_domain_cell</code>. However, typically it is already known when the function is called and therefore it is passed here as an argument.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nonprimitive</td><td>if <code>true:</code> initialize only those <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a> objects needed for evaluation of the scalar functionals entering non-primitively into the total potential </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c187fbb8171d6a1ff2ff6344cb454ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c187fbb8171d6a1ff2ff6344cb454ed">&#9670;&nbsp;</a></span>initialize_hidden_variables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::initialize_hidden_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function initializing the hidden variables of the scalar functionals. This uses the functions <a class="el" href="class_scalar_functional.html#a602d0bc2c945822c6b756fc63183ae2b">ScalarFunctional::initial_vals_hidden</a> and <a class="el" href="class_scalar_functional_3_01spacedim_00_01spacedim_01_4.html#ae3282d5182360e0030e4cc5e02fbe2eb">ScalarFunctional&lt;spacedim, spacedim&gt;::initial_vals_hidden</a>, respectively.</p>
<dl class="section warning"><dt>Warning</dt><dd>At present the transfer of hidden variables upon mesh refinement is not implemented. So, use hidden variables only if the mesh is not changed after the <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> has been set up! </dd></dl>

</div>
</div>
<a id="a40e7eb10c5dbd5358597f38291b90d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e7eb10c5dbd5358597f38291b90d85">&#9670;&nbsp;</a></span>make_dirichlet_constraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::make_dirichlet_constraints </td>
          <td>(</td>
          <td class="paramtype">AffineConstraints&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_dirichlet_constraint.html">DirichletConstraint</a>&lt; spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dirichlet_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineConstraints&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints_ignore</em> = <code>AffineConstraints&lt;&#160;double&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method generating Dirichlet type constraints on domain related independent fields on interfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">constraint_matrix</td><td>resulting constraint matrix with the Dirichlet type constraints</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirichlet_constraints</td><td>constraints to be applied to the domain related fields</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints_ignore</td><td>All dofs which are already constrained in <code>ignore_constrained</code> will not again be constrained in <code>constraint_matrix</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The constraint matrix will be cleared before the constraints are written. This means that if you have other constraints, it will be necessary to merge the constraint matrices. The <code>local_lines</code> property will be set to what <a class="el" href="class_do_f_handler_system.html#af5e18e9200d2137f01c35a19e0890739">DoFHandlerSystem::get_locally_relevant_dofs()</a> of the object <a class="el" href="class_assembly_helper.html#a885e660c749e91a35e3279643ebcd87f">AssemblyHelper::dof_handler_system</a> returns.</dd>
<dd>
Domain related independent fields can only be directly constrained using this method if they are discretized based on finite elements having support points! Attempting to constrain independent fields discretized in terms of elements not having support points with this function will have no effect. </dd></dl>

</div>
</div>
<a id="a5b2d6681755428d4abfe718e54e3c322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2d6681755428d4abfe718e54e3c322">&#9670;&nbsp;</a></span>make_dirichlet_constraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::make_dirichlet_constraints </td>
          <td>(</td>
          <td class="paramtype">AffineConstraints&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_dirichlet_constraint.html">DirichletConstraint</a>&lt; spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>dirichlet_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_point_constraint.html">PointConstraint</a>&lt; spacedim, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_constraints_omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_point_constraint.html">PointConstraint</a>&lt; spacedim-1, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_constraints_sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="class_point_constraint.html">PointConstraint</a>&lt; 0, spacedim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_constraints_C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineConstraints&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints_ignore</em> = <code>AffineConstraints&lt;&#160;double&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An extended method generating Dirichlet type constraints on domain related independent fields on interfaces as well as point-wise Dirichlet type constraints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">constraint_matrix</td><td>resulting constraint matrix with the Dirichlet type constraints</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dirichlet_constraints</td><td>constraints to be applied to the domain related fields</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_constraints_omega</td><td>point constraints to be applied to the domain related fields</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_constraints_sigma</td><td>point constraints to be applied to the interface related fields</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_constraints_C</td><td>point constraints to be applied to the independent scalars</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints_ignore</td><td>All dofs which are already constrained in <code>ignore_constrained</code> will not again be constrained in <code>constraint_matrix</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The constraint matrix will be cleared before the constraints are written. This means that if you have other constraints, it will be necessary to merge the constraint matrices. The <code>local_lines</code> property will be set to what <a class="el" href="class_do_f_handler_system.html#af5e18e9200d2137f01c35a19e0890739">DoFHandlerSystem::get_locally_relevant_dofs()</a> of the object <a class="el" href="class_assembly_helper.html#a885e660c749e91a35e3279643ebcd87f">AssemblyHelper::dof_handler_system</a> returns.</dd>
<dd>
Domain related independent fields can only be directly constrained using this method if they are discretized based on finite elements having support points! Attempting to constrain independent fields discretized in terms of elements not having support points with this function will have no effect. </dd></dl>

</div>
</div>
<a id="a8a6d7a10dfa2b88ef6f2a974124b0ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6d7a10dfa2b88ef6f2a974124b0ad5">&#9670;&nbsp;</a></span>make_dirichlet_constraints_recursion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::make_dirichlet_constraints_recursion </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt; spacedim &gt;::DomainCell &amp;&#160;</td>
          <td class="paramname"><em>domain_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>shapefuns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_dirichlet_constraint.html">DirichletConstraint</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineConstraints&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AffineConstraints&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints_ignore</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Auxiliary function for creation of Dirichlet constraints</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">domain_cell</td><td>The domain cell for which constraints are to be created</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>The face of the domain cell on which constraints are to be created</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shapefuns</td><td>The shape functions to be constrained</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraint</td><td>The constraint object describing the constraint</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">constraint_matrix</td><td>The constraint matrix into which the constraints go</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints_ignore</td><td>A constraint matrix with indices which should not be constrained again </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a6f8ff7c1a8910d84beb7761b5c821b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6f8ff7c1a8910d84beb7761b5c821b">&#9670;&nbsp;</a></span>print_assembly_helper_definition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::print_assembly_helper_definition </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>detailed_printout_shapefuns</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outputs the problem definition for diagnostic purposes to screen (e.g., how the total potential looks like, which finite elements are used, which quadrature rules are used, etc.).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Currently this function does not print information about independent scalars and the constant terms in the dependent fields. This must be changed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">detailed_printout_shapefuns</td><td>if <code>true</code> print out a detailed summary about how dependent fields are related to shape functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0dabb84cc4a0497dbeb73a9eec3071d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0dabb84cc4a0497dbeb73a9eec3071d">&#9670;&nbsp;</a></span>print_dof_information()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::print_dof_information </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dof_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for printing out information about a dof</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_index</td><td>The dof index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5744ed966169526d69508706b7b8f2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5744ed966169526d69508706b7b8f2d2">&#9670;&nbsp;</a></span>set_cylindrical_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::set_cylindrical_symmetry </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>cylindrical_symmetry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cylindrical_symmetry</td><td><a class="el" href="class_assembly_helper.html#aa2548bfa4a097088e3759ce2a1319aa8">AssemblyHelper::cylindrical_symmetry</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60553b183a382aff3072ea7b6f5b86dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60553b183a382aff3072ea7b6f5b86dd">&#9670;&nbsp;</a></span>set_quadrature_point_alignment_tol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::set_quadrature_point_alignment_tol </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>quadrature_point_alignment_tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature_point_alignment_tol</td><td>Sets <a class="el" href="class_assembly_helper.html#aa37920e596dca3985e6d28b9d4e3d882">AssemblyHelper::quadrature_point_alignment_tol</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae821c8ae9c8fa6f8e85d20ecd5ad7e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">&#9670;&nbsp;</a></span>system_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::system_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of the stretched finite element system </dd></dl>

</div>
</div>
<a id="a6120d66724f518dcfcdc30a89df01c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6120d66724f518dcfcdc30a89df01c23">&#9670;&nbsp;</a></span>write_output_independent_fields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;const std::string, const std::string&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::write_output_independent_fields </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/group__output.html#gaf6742de875351b15832c89eaafd6bbff">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name_interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>file_index</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; dealii::SmartPointer&lt; const dealii::DataPostprocessor&lt; spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dp_domain</em> = <code>std::vector&lt;&#160;dealii::SmartPointer&lt;&#160;const&#160;dealii::DataPostprocessor&lt;&#160;spacedim&#160;&gt;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; dealii::SmartPointer&lt; const dealii::DataPostprocessor&lt; spacedim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dp_interface</em> = <code>std::vector&lt;&#160;dealii::SmartPointer&lt;&#160;const&#160;dealii::DataPostprocessor&lt;&#160;spacedim&#160;&gt;&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to write dof output to *.vtu files (one for the domain and one for the interface). This only writes the dofs on the domain and the interface to the file; the independent scalars are currently not included in the output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>The solution <img class="formulaInl" alt="$\begin{pmatrix} \boldsymbol{\hat u} \\ \boldsymbol{\hat \lambda} \end{pmatrix}$" src="form_48.png"/>, where the values of <img class="formulaInl" alt="$\boldsymbol{\hat \lambda}$" src="form_45.png"/> are not used and are, therefore, arbitrary. The appropriate size of <code>solution</code> can be obtained from <a class="el" href="class_assembly_helper.html#ae821c8ae9c8fa6f8e85d20ecd5ad7e39">AssemblyHelper::system_size()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name_domain</td><td>A file name for the output of domain related dofs (note that the extension .vtu will be appended automatically)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name_interface</td><td>A file name for the output of interface related dofs (note that the extension .vtu will be appended automatically)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_index</td><td>An index which is appended to the file name (but in front of the extension)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dp_domain</td><td><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classDataPostprocessor.html">DataPostprocessor</a> objects for extra output on domain cells</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dp_interface</td><td><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classDataPostprocessor.html">DataPostprocessor</a> objects for extra output on interface cells</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n_subdivisions</td><td>The number of subdivisions of the cell (to get a better representation in case of curved inner cells, higher order elements, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file names actually used for writing domain and interface output (including the file name extension) </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4461be378c9be0364ca23153c367d24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4461be378c9be0364ca23153c367d24c">&#9670;&nbsp;</a></span>a_minus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt; std::tuple&lt;const double, const unsigned int, std::vector&lt;unsigned int&gt; &gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::a_minus</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how interface related dependent fields <img class="formulaInl" alt="$e^\Sigma_\nu$" src="form_22.png"/> are related to shape functions. In particular, it relates shape functions to the terms <img class="formulaInl" alt="$a^-_{\nu\epsilon} (u^\Omega_\epsilon)^-$" src="form_27.png"/> (see <a class="el" href="class_dependent_field.html">DependentField</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#a4461be378c9be0364ca23153c367d24c">AssemblyHelper::a_minus</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the interface (sub)portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#a4461be378c9be0364ca23153c367d24c">AssemblyHelper::a_minus</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$a^-_{\nu\epsilon} (u^\Omega_\epsilon)^-$" src="form_27.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#a4461be378c9be0364ca23153c367d24c">AssemblyHelper::a_minus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$a^-_{\nu\epsilon}$" src="form_28.png"/>, <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#a4461be378c9be0364ca23153c367d24c">AssemblyHelper::a_minus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the global component corresponding to the independent field <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/>, and <code>get&lt;<code>2&gt;</code>(<a class="el" href="class_assembly_helper.html#a4461be378c9be0364ca23153c367d24c">AssemblyHelper::a_minus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) contains all the (scalar functional related) shape function indices of a domain cell on the minus side corresponding to shape functions which are non-zero in the relevant global component. </p>

</div>
</div>
<a id="a13fef9096e5fc7b1e922ea78d7aa2c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fef9096e5fc7b1e922ea78d7aa2c28">&#9670;&nbsp;</a></span>a_omega</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt; std::tuple&lt;const double, const unsigned int, std::vector&lt;unsigned int&gt; &gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::a_omega</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how domain related dependent fields <img class="formulaInl" alt="$e^\Omega_\lambda$" src="form_11.png"/> are related to shape functions. In particular, it relates shape functions to the terms <img class="formulaInl" alt="$a^\Omega_{\lambda\epsilon} u^\Omega_\epsilon$" src="form_12.png"/> (see <a class="el" href="class_dependent_field_3_01spacedim_00_01spacedim_01_4.html">DependentField&lt;spacedim, spacedim&gt;</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#a13fef9096e5fc7b1e922ea78d7aa2c28">AssemblyHelper::a_omega</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the domain portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#a13fef9096e5fc7b1e922ea78d7aa2c28">AssemblyHelper::a_omega</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$a^\Omega_{\lambda \epsilon} u^\Omega_\epsilon$" src="form_13.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#a13fef9096e5fc7b1e922ea78d7aa2c28">AssemblyHelper::a_omega</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$a^\Omega_{\lambda \epsilon}$" src="form_14.png"/>, <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#a13fef9096e5fc7b1e922ea78d7aa2c28">AssemblyHelper::a_omega</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the global component corresponding to the independent field <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/>, and <code>get&lt;<code>2&gt;</code>(<a class="el" href="class_assembly_helper.html#a13fef9096e5fc7b1e922ea78d7aa2c28">AssemblyHelper::a_omega</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) contains all the (scalar functional related) shape function indices of a domain cell corresponding to shape functions which are non-zero in the relevant global component. </p>

</div>
</div>
<a id="a8eb513a6239d94cc0f1a6a01a037c572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb513a6239d94cc0f1a6a01a037c572">&#9670;&nbsp;</a></span>a_plus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt; std::tuple&lt;const double, const unsigned int, std::vector&lt;unsigned int&gt; &gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::a_plus</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how interface related dependent fields <img class="formulaInl" alt="$e^\Sigma_\nu$" src="form_22.png"/> are related to shape functions. In particular, it relates shape functions to the terms <img class="formulaInl" alt="$a^+_{\nu\epsilon} (u^\Omega_\epsilon)^+$" src="form_31.png"/> (see <a class="el" href="class_dependent_field.html">DependentField</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#a8eb513a6239d94cc0f1a6a01a037c572">AssemblyHelper::a_plus</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the interface (sub)portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#a8eb513a6239d94cc0f1a6a01a037c572">AssemblyHelper::a_plus</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$a^+_{\nu\epsilon} (u^\Omega_\epsilon)^+$" src="form_31.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#a8eb513a6239d94cc0f1a6a01a037c572">AssemblyHelper::a_plus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$a^+_{\nu\epsilon}$" src="form_32.png"/>, <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#a8eb513a6239d94cc0f1a6a01a037c572">AssemblyHelper::a_plus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the global component corresponding to the independent field <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/>, and <code>get&lt;<code>2&gt;</code>(<a class="el" href="class_assembly_helper.html#a8eb513a6239d94cc0f1a6a01a037c572">AssemblyHelper::a_plus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) contains all the (scalar functional related) shape function indices of a domain cell on the plus side corresponding to shape functions which are non-zero in the relevant global component. </p>

</div>
</div>
<a id="aa266cc07e9670319481da52d633d2583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa266cc07e9670319481da52d633d2583">&#9670;&nbsp;</a></span>a_sigma</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt; std::tuple&lt;const double, const unsigned int, std::vector&lt;unsigned int&gt; &gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::a_sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how interface related dependent fields <img class="formulaInl" alt="$e^\Sigma_\nu$" src="form_22.png"/> are related to shape functions. In particular, it relates shape functions to the terms <img class="formulaInl" alt="$a^\Sigma_{\nu\eta} u^\Sigma_\eta$" src="form_23.png"/> (see <a class="el" href="class_dependent_field.html">DependentField</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#aa266cc07e9670319481da52d633d2583">AssemblyHelper::a_sigma</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the interface (sub)portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#aa266cc07e9670319481da52d633d2583">AssemblyHelper::a_sigma</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$a^\Sigma_{\nu\eta} u^\Sigma_\eta$" src="form_23.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#aa266cc07e9670319481da52d633d2583">AssemblyHelper::a_sigma</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$a^\Sigma_{\nu \eta}$" src="form_24.png"/>, <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#aa266cc07e9670319481da52d633d2583">AssemblyHelper::a_sigma</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the global component corresponding to the independent field <img class="formulaInl" alt="$u^\Sigma_\eta$" src="form_2.png"/>, and <code>get&lt;<code>2&gt;</code>(<a class="el" href="class_assembly_helper.html#aa266cc07e9670319481da52d633d2583">AssemblyHelper::a_sigma</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) contains all the (scalar functional related) shape function indices of an interface cell corresponding to shape functions which are non-zero in the relevant global component. </p>

</div>
</div>
<a id="a6f51f8b4dfdae385a2e2fe2dd9e66cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f51f8b4dfdae385a2e2fe2dd9e66cdb">&#9670;&nbsp;</a></span>b_minus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt; std::tuple&lt;const double, const unsigned int, const unsigned int, std::vector&lt;unsigned int&gt; &gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::b_minus</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how interface related dependent fields <img class="formulaInl" alt="$e^\Sigma_\nu$" src="form_22.png"/> are related to shape functions. In particular, it relates shape functions to the terms <img class="formulaInl" alt="$b^-_{\nu\epsilon i} \left(\dfrac{\partial u^\Omega_\epsilon}{\partial x_i}\right)^-$" src="form_29.png"/> (see <a class="el" href="class_dependent_field.html">DependentField</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#a6f51f8b4dfdae385a2e2fe2dd9e66cdb">AssemblyHelper::b_minus</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the interface (sub)portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#a6f51f8b4dfdae385a2e2fe2dd9e66cdb">AssemblyHelper::b_minus</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$b^-_{\nu\epsilon i} \left(\dfrac{\partial u^\Omega_\epsilon}{\partial x_i}\right)^-$" src="form_29.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#a6f51f8b4dfdae385a2e2fe2dd9e66cdb">AssemblyHelper::b_minus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$b^-_{\nu\epsilon i}$" src="form_30.png"/>, <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#a6f51f8b4dfdae385a2e2fe2dd9e66cdb">AssemblyHelper::b_minus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the global component corresponding to the independent field <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/>, <code>get&lt;<code>2&gt;</code>(<a class="el" href="class_assembly_helper.html#a6f51f8b4dfdae385a2e2fe2dd9e66cdb">AssemblyHelper::b_minus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the derivative <img class="formulaInl" alt="$i$" src="form_17.png"/> of the independent field <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/>, and <code>get&lt;<code>3&gt;</code>(<a class="el" href="class_assembly_helper.html#a6f51f8b4dfdae385a2e2fe2dd9e66cdb">AssemblyHelper::b_minus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) contains all the (scalar functional related) shape function indices of a domain cell on the minus side corresponding to shape functions which are non-zero in the relevant global component. </p>

</div>
</div>
<a id="a5fbb532e798c2427af5285c2df10c9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbb532e798c2427af5285c2df10c9f4">&#9670;&nbsp;</a></span>b_omega</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt; std::tuple&lt;const double, const unsigned int, const unsigned int, std::vector&lt;unsigned int&gt; &gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::b_omega</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how domain related dependent fields <img class="formulaInl" alt="$e^\Omega_\lambda$" src="form_11.png"/> are related to shape functions. In particular, it relates shape functions to the terms <img class="formulaInl" alt="$b^\Omega_{\lambda \epsilon i} \dfrac{\partial u^\Omega_\epsilon}{\partial x_i}$" src="form_15.png"/> (see <a class="el" href="class_dependent_field_3_01spacedim_00_01spacedim_01_4.html">DependentField&lt;spacedim, spacedim&gt;</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#a5fbb532e798c2427af5285c2df10c9f4">AssemblyHelper::b_omega</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the domain portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#a5fbb532e798c2427af5285c2df10c9f4">AssemblyHelper::b_omega</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$b^\Omega_{\lambda \epsilon i} \dfrac{\partial u^\Omega_\epsilon}{\partial x_i}$" src="form_15.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#a5fbb532e798c2427af5285c2df10c9f4">AssemblyHelper::b_omega</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$b^\Omega_{\lambda \epsilon i}$" src="form_16.png"/>, <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#a5fbb532e798c2427af5285c2df10c9f4">AssemblyHelper::b_omega</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the global component corresponding to the independent field <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/>, <code>get&lt;<code>2&gt;</code>(<a class="el" href="class_assembly_helper.html#a5fbb532e798c2427af5285c2df10c9f4">AssemblyHelper::b_omega</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the derivative <img class="formulaInl" alt="$i$" src="form_17.png"/> of the independent field <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/>, and <code>get&lt;<code>3&gt;</code>(<a class="el" href="class_assembly_helper.html#a5fbb532e798c2427af5285c2df10c9f4">AssemblyHelper::b_omega</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) contains all the (scalar functional related) shape function indices of a domain cell corresponding to shape functions which are non-zero in the relevant global component. </p>

</div>
</div>
<a id="ab09dd07d3ec596525be83f8f5859bef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09dd07d3ec596525be83f8f5859bef7">&#9670;&nbsp;</a></span>b_plus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt; std::tuple&lt;const double, const unsigned int, const unsigned int, std::vector&lt;unsigned int&gt; &gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::b_plus</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how interface related dependent fields <img class="formulaInl" alt="$e^\Sigma_\nu$" src="form_22.png"/> are related to shape functions. In particular, it relates shape functions to the terms <img class="formulaInl" alt="$b^+_{\nu\epsilon i} \left(\dfrac{\partial u^\Omega_\epsilon}{\partial x_i}\right)^+$" src="form_33.png"/> (see <a class="el" href="class_dependent_field.html">DependentField</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#ab09dd07d3ec596525be83f8f5859bef7">AssemblyHelper::b_plus</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the interface (sub)portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#ab09dd07d3ec596525be83f8f5859bef7">AssemblyHelper::b_plus</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$b^+_{\nu\epsilon i} \left(\dfrac{\partial u^\Omega_\epsilon}{\partial x_i}\right)^+$" src="form_33.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#ab09dd07d3ec596525be83f8f5859bef7">AssemblyHelper::b_plus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$b^+_{\nu\epsilon i}$" src="form_34.png"/>, <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#ab09dd07d3ec596525be83f8f5859bef7">AssemblyHelper::b_plus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the global component corresponding to the independent field <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/>, <code>get&lt;<code>2&gt;</code>(<a class="el" href="class_assembly_helper.html#ab09dd07d3ec596525be83f8f5859bef7">AssemblyHelper::b_plus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the derivative <img class="formulaInl" alt="$i$" src="form_17.png"/> of the independent field <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/>, and <code>get&lt;<code>3&gt;</code>(<a class="el" href="class_assembly_helper.html#ab09dd07d3ec596525be83f8f5859bef7">AssemblyHelper::b_plus</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) contains all the (scalar functional related) shape function indices of a domain cell on the plus side corresponding to shape functions which are non-zero in the relevant global component. </p>

</div>
</div>
<a id="af58c9a1c7093edc306070913aa1b9be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58c9a1c7093edc306070913aa1b9be2">&#9670;&nbsp;</a></span>b_sigma</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt; std::tuple&lt;const double, const unsigned int, const unsigned int, std::vector&lt;unsigned int&gt; &gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::b_sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how interface related dependent fields <img class="formulaInl" alt="$e^\Sigma_\nu$" src="form_22.png"/> are related to shape functions. In particular, it relates shape functions to the terms <img class="formulaInl" alt="$b^\Sigma_{\nu \eta i} \dfrac{\partial u^\Sigma_\eta}{\partial x_i}$" src="form_25.png"/> (see <a class="el" href="class_dependent_field.html">DependentField</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#af58c9a1c7093edc306070913aa1b9be2">AssemblyHelper::b_sigma</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the interface (sub)portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#af58c9a1c7093edc306070913aa1b9be2">AssemblyHelper::b_sigma</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$b^\Sigma_{\nu \eta i} \dfrac{\partial u^\Sigma_\eta}{\partial x_i}$" src="form_25.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#af58c9a1c7093edc306070913aa1b9be2">AssemblyHelper::b_sigma</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$b^\Sigma_{\nu \eta i}$" src="form_26.png"/>, <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#af58c9a1c7093edc306070913aa1b9be2">AssemblyHelper::b_sigma</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the global component corresponding to the independent field <img class="formulaInl" alt="$u^\Sigma_\eta$" src="form_2.png"/>, <code>get&lt;<code>2&gt;</code>(<a class="el" href="class_assembly_helper.html#af58c9a1c7093edc306070913aa1b9be2">AssemblyHelper::b_sigma</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the derivative <img class="formulaInl" alt="$i$" src="form_17.png"/> of the independent field <img class="formulaInl" alt="$u^\Sigma_\eta$" src="form_2.png"/>, and <code>get&lt;<code>3&gt;</code>(<a class="el" href="class_assembly_helper.html#af58c9a1c7093edc306070913aa1b9be2">AssemblyHelper::b_sigma</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) contains all the (scalar functional related) shape function indices of an interface cell corresponding to shape functions which are non-zero in the relevant global component. </p>

</div>
</div>
<a id="aa5234a46be82cfe7d92678169d38f326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5234a46be82cfe7d92678169d38f326">&#9670;&nbsp;</a></span>C</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_independent_field.html">IndependentField</a>&lt;0, spacedim&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::C</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>vector of independent scalars <img class="formulaInl" alt="$C_\iota$" src="form_3.png"/> involved in the definition of the problem. These independent scalars are sorted by <a class="el" href="class_independent_field_3_010_00_01spacedim_01_4.html#a05ecdcc8310253f055fbc59abaa2bc90">IndependentField&lt;0, spacedim&gt;::name</a> </p>

</div>
</div>
<a id="a75e6f76c0b12b91c5feb230251f0137f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e6f76c0b12b91c5feb230251f0137f">&#9670;&nbsp;</a></span>c_omega</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt;std::tuple&lt;const double, unsigned int&gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::c_omega</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how domain related dependent fields <img class="formulaInl" alt="$e^\Omega_\lambda$" src="form_11.png"/> are related to independent scalars. In particular, it relates scalar functional related independent scalar indices to terms <img class="formulaInl" alt="$c^\Omega_{\lambda\iota} C_\iota$" src="form_18.png"/> (see <a class="el" href="class_dependent_field_3_01spacedim_00_01spacedim_01_4.html">DependentField&lt;spacedim, spacedim&gt;</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#a75e6f76c0b12b91c5feb230251f0137f">AssemblyHelper::c_omega</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the domain portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#a75e6f76c0b12b91c5feb230251f0137f">AssemblyHelper::c_omega</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$c^\Omega_{\lambda\iota} C_\iota$" src="form_18.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#a75e6f76c0b12b91c5feb230251f0137f">AssemblyHelper::c_omega</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$c^\Omega_{\lambda\iota}$" src="form_19.png"/>, and <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#a75e6f76c0b12b91c5feb230251f0137f">AssemblyHelper::c_omega</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the scalar functional related independent scalar index corresponding to the independent scalar <img class="formulaInl" alt="$C_\iota$" src="form_3.png"/> </p>

</div>
</div>
<a id="ab3d4370661ba726010ee687ef0e98140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d4370661ba726010ee687ef0e98140">&#9670;&nbsp;</a></span>c_sigma</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt; std::vector&lt;std::tuple&lt;const double, unsigned int&gt; &gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::c_sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about how interface related dependent fields <img class="formulaInl" alt="$e^\Sigma_\nu$" src="form_22.png"/> are related to independent scalars. In particular, it relates scalar functional related independent scalar indices to terms <img class="formulaInl" alt="$c^\Sigma_{\nu\iota} C_\iota$" src="form_35.png"/> (see <a class="el" href="class_dependent_field.html">DependentField</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#ab3d4370661ba726010ee687ef0e98140">AssemblyHelper::c_sigma</a>[<code>u</code>][<code>v</code>][<code>k</code>] is used for the evaluation of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the interface (sub)portion with internal index <code>u</code>.</p>
<p>Each <a class="el" href="class_assembly_helper.html#ab3d4370661ba726010ee687ef0e98140">AssemblyHelper::c_sigma</a>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>] corresponds to a single term <img class="formulaInl" alt="$c^\Sigma_{\nu\iota} C_\iota$" src="form_35.png"/>, where <code>get&lt;<code>0&gt;</code>(<a class="el" href="class_assembly_helper.html#ab3d4370661ba726010ee687ef0e98140">AssemblyHelper::c_sigma</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the coefficient <img class="formulaInl" alt="$c^\Sigma_{\nu\iota}$" src="form_36.png"/>, and <code>get&lt;<code>1&gt;</code>(<a class="el" href="class_assembly_helper.html#ab3d4370661ba726010ee687ef0e98140">AssemblyHelper::c_sigma</a></code>[<code>u</code>][<code>v</code>][<code>k</code>][<code>l</code>]) is the scalar functional related independent scalar index corresponding to the independent scalar <img class="formulaInl" alt="$C_\iota$" src="form_3.png"/> </p>

</div>
</div>
<a id="af5e29448f133863a1859be8bfbb300c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e29448f133863a1859be8bfbb300c6">&#9670;&nbsp;</a></span>component_names_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, unsigned int&gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::component_names_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_assembly_helper.html#af5e29448f133863a1859be8bfbb300c6">AssemblyHelper::component_names_domain</a>[<code>i</code>] is a name (name characterized by string and component) for the global component with global index <code>i</code> on the domain. This name is formed from the pair (<a class="el" href="class_independent_field.html#ae05f8565e4ce1a70b5b833555dc084b5">IndependentField::name</a>, <code>component</code>) of the underlying domain related independent field. The name is used to identify independent fields in output. </p>

</div>
</div>
<a id="a7ae6ae2ec356cbb7b830d968315d280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae6ae2ec356cbb7b830d968315d280c">&#9670;&nbsp;</a></span>component_names_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;std::string, unsigned int&gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::component_names_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_assembly_helper.html#a7ae6ae2ec356cbb7b830d968315d280c">AssemblyHelper::component_names_interface</a>[<code>i</code>] is a name (name characterized by string and component) for the global component with global index <code>i</code> on the interface. This name is formed from the pair (<a class="el" href="class_independent_field.html#ae05f8565e4ce1a70b5b833555dc084b5">IndependentField::name</a>, <code>component</code>) of the underlying interface related independent field. The name is used to identify independent fields in output. </p>

</div>
</div>
<a id="a0bdb6e2e2f9623f3f10dfa2ebe8e234c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdb6e2e2f9623f3f10dfa2ebe8e234c">&#9670;&nbsp;</a></span>components_to_shapefuns_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::components_to_shapefuns_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mapping between global components of domain related <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESystem.html">FESystem</a>'s (which are stored in <a class="el" href="class_assembly_helper.html#af3803b0aad9853e6bf018c70be41e791">AssemblyHelper::fe_collection_domain</a>) and local shape function indices. <a class="el" href="class_assembly_helper.html#a0bdb6e2e2f9623f3f10dfa2ebe8e234c">AssemblyHelper::components_to_shapefuns_domain</a>[<code>i</code>][<code>j</code>] contains the local shape function indices of shape functions contributing to the global component <code>j</code> of the <code>i-th</code> <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESystem.html">FESystem</a> in <a class="el" href="class_assembly_helper.html#af3803b0aad9853e6bf018c70be41e791">AssemblyHelper::fe_collection_domain</a>. </p>

</div>
</div>
<a id="ae92560183f1d2060265f0744a84f0349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92560183f1d2060265f0744a84f0349">&#9670;&nbsp;</a></span>components_to_shapefuns_domain_facewise</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::components_to_shapefuns_domain_facewise</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member is similar to <a class="el" href="class_assembly_helper.html#a0bdb6e2e2f9623f3f10dfa2ebe8e234c">AssemblyHelper::components_to_shapefuns_domain</a>. However, the information is additionally broken down in cell faces. In particular, <a class="el" href="class_assembly_helper.html#ae92560183f1d2060265f0744a84f0349">AssemblyHelper::components_to_shapefuns_domain_facewise</a>[<code>i</code>][<code>j</code>][<code>k</code>] contains the indices of shape functions related to the global component <code>j</code> of the <code>i-th</code> <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESystem.html">FESystem</a> in <a class="el" href="class_assembly_helper.html#af3803b0aad9853e6bf018c70be41e791">AssemblyHelper::fe_collection_domain</a> which have support on face <code>k</code>.</p>
<p>It is noted that not all shape functions included in <a class="el" href="class_assembly_helper.html#a0bdb6e2e2f9623f3f10dfa2ebe8e234c">AssemblyHelper::components_to_shapefuns_domain</a>[<code>i</code>][<code>j</code>] may be present in <a class="el" href="class_assembly_helper.html#ae92560183f1d2060265f0744a84f0349">AssemblyHelper::components_to_shapefuns_domain_facewise</a>[<code>i</code>][<code>j</code>] because there may be shape functions which don't have support on a face or which are not associated with support points at all.</p>
<p>The main use of this data structure is to facilitate the assembly of Dirichlet type constraints imposed on domain related independent fields on interfaces (such constraints can only be applied directly if the shape functions related to the constrained independent field are associated with support points). </p>

</div>
</div>
<a id="abcad51e64347fc3141d2840a2835b46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcad51e64347fc3141d2840a2835b46c">&#9670;&nbsp;</a></span>components_to_shapefuns_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::components_to_shapefuns_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mapping between global components of interface related <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESystem.html">FESystem</a>'s (which are stored in <a class="el" href="class_assembly_helper.html#a8b4d224a9ecd2e926a8860829874d2a1">AssemblyHelper::fe_collection_interface</a>) and local shape function indices. <a class="el" href="class_assembly_helper.html#abcad51e64347fc3141d2840a2835b46c">AssemblyHelper::components_to_shapefuns_interface</a>[<code>i</code>][<code>j</code>] contains the local shape function indices of shape functions contributing to the global component <code>j</code> of the <code>i-th</code> <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFESystem.html">FESystem</a> in <a class="el" href="class_assembly_helper.html#a8b4d224a9ecd2e926a8860829874d2a1">AssemblyHelper::fe_collection_interface</a>. </p>

</div>
</div>
<a id="aceaf7ba62dfe0fa06ecb15ee8c14da34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaf7ba62dfe0fa06ecb15ee8c14da34">&#9670;&nbsp;</a></span>contributions_scalar_functionals_domain_total_potential</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt;spacedim, spacedim&gt; &gt;, std::vector&lt;std::pair&lt;const unsigned int, const unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::contributions_scalar_functionals_domain_total_potential</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between domain related scalar functionals and a vector of pairs of ("contribution to total potential", "scalar functional index within contribution to total potential"), where "contribution to total potential" is an index into <a class="el" href="class_total_potential.html#a5a14ce0e2fabf8116566aa67fb11db35">TotalPotential::total_potential_contributions</a> and "scalar functional index within contribution to total potential" is an index into <a class="el" href="class_total_potential_contribution.html#a15191539345978a3d0c7293bd7ecaa91">TotalPotentialContribution::H_omega</a>. This member essentially describes how a domain related scalar functional factors into the <a class="el" href="class_total_potential.html">TotalPotential</a> </p>

</div>
</div>
<a id="a9e76874224ab4946218fdce9bdba0e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e76874224ab4946218fdce9bdba0e03">&#9670;&nbsp;</a></span>contributions_scalar_functionals_interface_total_potential</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt;spacedim-1, spacedim&gt; &gt;, std::vector&lt;std::pair&lt;const unsigned int, const unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::contributions_scalar_functionals_interface_total_potential</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between interface related scalar functionals and a vector of pairs of ("contribution to total potential", "scalar functional index within contribution to total potential"), where "contribution to total potential" is an index into <a class="el" href="class_total_potential.html#a5a14ce0e2fabf8116566aa67fb11db35">TotalPotential::total_potential_contributions</a> and "scalar functional index within contribution to total potential" is an index into <a class="el" href="class_total_potential_contribution.html#aac404e3a8493d9170541e34bd96673d3">TotalPotentialContribution::H_sigma</a> (but shifted by the size of <a class="el" href="class_total_potential_contribution.html#a15191539345978a3d0c7293bd7ecaa91">TotalPotentialContribution::H_omega</a>). This member essentially describes how an interface related scalar functional factors into the <a class="el" href="class_total_potential.html">TotalPotential</a> </p>

</div>
</div>
<a id="a0edd25820c92a25ae87fc240f4916804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edd25820c92a25ae87fc240f4916804">&#9670;&nbsp;</a></span>coupled_C_indices_scalar_functionals_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::coupled_C_indices_scalar_functionals_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about the independent scalars coupling for a certain domain related scalar functional (see <a class="el" href="class_assembly_helper.html#aa5234a46be82cfe7d92678169d38f326">AssemblyHelper::C</a> and <a class="el" href="class_assembly_helper.html#a9a8f0e8ea8c67ce9429c16a2017cafdc">AssemblyHelper::global_indices_C</a> for the global indexing of the independent scalars). Essentially, this data structure transforms the global indexing of independent scalars into a scalar functional related independent scalar indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.</p>
<p><a class="el" href="class_assembly_helper.html#a0edd25820c92a25ae87fc240f4916804">AssemblyHelper::coupled_C_indices_scalar_functionals_domain</a>[<code>u</code>][<code>v</code>] contains all global independent scalar indices coupling for the <code>v-th</code> scalar functional on the domain portion with internal index <code>u</code> (the ordering of the scalar functionals on the domain portion with internal index <code>u</code> is given by <a class="el" href="class_assembly_helper.html#aa6fa619e4c2582e95950e878cd06628e">AssemblyHelper::scalar_functionals_domain</a>[<code>u</code>]).</p>
<p>See also <a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a> for further explanations regarding the relevance of this data structure.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>This data structure contains redundancy because the way how the independent scalars couple for a certain scalar functional does not depend on the domain portion. This redundancy has initially been introduced to allow for a consistent treatment of cell related dofs and independent scalar related dofs. However, its should be eliminated in later releases.</dd></dl>

</div>
</div>
<a id="a311e176038ee2b7ca0719abb384ca57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311e176038ee2b7ca0719abb384ca57b">&#9670;&nbsp;</a></span>coupled_C_indices_scalar_functionals_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::coupled_C_indices_scalar_functionals_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about the independent scalars coupling for a certain interface related scalar functional (see <a class="el" href="class_assembly_helper.html#aa5234a46be82cfe7d92678169d38f326">AssemblyHelper::C</a> and <a class="el" href="class_assembly_helper.html#a9a8f0e8ea8c67ce9429c16a2017cafdc">AssemblyHelper::global_indices_C</a> for the indexing of the independent scalars). Essentially, this data structure transforms the global indexing of independent scalars into a scalar functional related independent scalar indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.</p>
<p><a class="el" href="class_assembly_helper.html#a311e176038ee2b7ca0719abb384ca57b">AssemblyHelper::coupled_C_indices_scalar_functionals_interface</a>[<code>u</code>][<code>v</code>] contains all global independent scalar indices coupling for the <code>v-th</code> scalar functional on the interface portion with internal index <code>u</code> (the ordering of the scalar functionals on the interface portion with internal index <code>u</code> is given by <a class="el" href="class_assembly_helper.html#a29aa77e0e8e6b35c94966ea88840e462">AssemblyHelper::scalar_functionals_interface</a>[<code>u</code>]).</p>
<p>See also <a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a> for further explanations regarding the relevance of this data structure.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>This data structure contains redundancy because the way how the independent scalars couple for a certain scalar functional does not depend on the interface portion. This redundancy has initially been introduced to allow for a consistent treatment of cell related dofs and independent scalar related dofs. However, its should be eliminated in later releases. </dd></dl>

</div>
</div>
<a id="a1a26b40224e3f04e5168accc91486493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a26b40224e3f04e5168accc91486493">&#9670;&nbsp;</a></span>coupled_dof_indices_scalar_functionals_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::coupled_dof_indices_scalar_functionals_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about the shape functions coupling for a certain domain related scalar functional. Essentially, this data structure transforms the cell related indexing of shape functions of deal.II into a scalar functional related shape function indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.</p>
<p><a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a>[<code>u</code>][<code>v</code>] contains all (cell related) dof indices which couple for the <code>v-th</code> scalar functional on the domain portion with internal index <code>u</code> (the ordering of the scalar functionals on the domain portion with internal index <code>u</code> is given by <a class="el" href="class_assembly_helper.html#aa6fa619e4c2582e95950e878cd06628e">AssemblyHelper::scalar_functionals_domain</a>[<code>u</code>]).</p>
<p>Using this data structure it is e.g. possible to make sure that only those entries are included in the sparsity pattern which are really needed. As an example, consider the case that there are two domain related scalar functionals <img class="formulaInl" alt="$H^\Omega_1[e^\Omega_1(u^\Omega_1, u^\Omega_2)]$" src="form_6.png"/> and <img class="formulaInl" alt="$H^\Omega_2[e^\Omega_2(u^\Omega_2, u^\Omega_3)]$" src="form_7.png"/>. For this case, the shape functions related to <img class="formulaInl" alt="$u^\Omega_1$" src="form_8.png"/> will couple to those related to <img class="formulaInl" alt="$u^\Omega_2$" src="form_9.png"/>; and the shape functions related to <img class="formulaInl" alt="$u^\Omega_2$" src="form_9.png"/> will couple to those related to <img class="formulaInl" alt="$u^\Omega_3$" src="form_10.png"/>; however there is no coupling between <img class="formulaInl" alt="$u^\Omega_1$" src="form_8.png"/> and <img class="formulaInl" alt="$u^\Omega_3$" src="form_10.png"/>. The standard approach of assuming that all shape functions living on a certain cell couple would miss this subtlety and allocate entries in the finite element system matrix which are always zero. However, by using the scalar functional related shape function indexing provided by the member <a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a> this is avoided. </p>

</div>
</div>
<a id="aa9fc6d318c2f7a2eab5097b6a76c9083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fc6d318c2f7a2eab5097b6a76c9083">&#9670;&nbsp;</a></span>coupled_dof_indices_scalar_functionals_domain_local</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::coupled_dof_indices_scalar_functionals_domain_local</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Essentially the same as <a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a>. However, only dofs related to local independent field are included </p>

</div>
</div>
<a id="a6b7242925e5a0be85830ed7eae581442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7242925e5a0be85830ed7eae581442">&#9670;&nbsp;</a></span>coupled_dof_indices_scalar_functionals_domain_nonlocal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::coupled_dof_indices_scalar_functionals_domain_nonlocal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Essentially the same as <a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a>. However, only dofs related to nonlocal independent field are included </p>

</div>
</div>
<a id="ab346e146cf91fb7a0688076551b37355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab346e146cf91fb7a0688076551b37355">&#9670;&nbsp;</a></span>coupled_dof_indices_scalar_functionals_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::coupled_dof_indices_scalar_functionals_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about the shape functions of an interface cell coupling for a certain interface related scalar functional. Essentially, this data structure transforms the cell related indexing of shape functions of deal.II into a scalar functional related shape function indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.</p>
<p><a class="el" href="class_assembly_helper.html#ab346e146cf91fb7a0688076551b37355">AssemblyHelper::coupled_dof_indices_scalar_functionals_interface</a>[<code>u</code>][<code>v</code>] contains all (cell related) dof indices of an interface cell which couple for the <code>v-th</code> scalar functional on the interface portion with internal index <code>u</code> (the ordering of the scalar functionals on the interface portion with internal index <code>u</code> is given by <a class="el" href="class_assembly_helper.html#a29aa77e0e8e6b35c94966ea88840e462">AssemblyHelper::scalar_functionals_interface</a>[<code>u</code>]).</p>
<p>See also <a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a> for further explanations regarding the relevance of this data structure. </p>

</div>
</div>
<a id="a12299d82365553a21fef8529c8fe8a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12299d82365553a21fef8529c8fe8a17">&#9670;&nbsp;</a></span>coupled_dof_indices_scalar_functionals_interface_minus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::coupled_dof_indices_scalar_functionals_interface_minus</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about the shape functions of a domain cell on the minus side of the interface coupling for a certain interface related scalar functional. Essentially, this data structure transforms the cell related indexing of shape functions of deal.II into a scalar functional related shape function indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.</p>
<p><a class="el" href="class_assembly_helper.html#a12299d82365553a21fef8529c8fe8a17">AssemblyHelper::coupled_dof_indices_scalar_functionals_interface_minus</a>[<code>u</code>][<code>v</code>] contains all (cell related) dof indices of a domain cell on the minus side of the interface which couple for the <code>v-th</code> scalar functional on the interface portion with internal index <code>u</code> (the ordering of the scalar functionals on the interface portion with internal index <code>u</code> is given by <a class="el" href="class_assembly_helper.html#a29aa77e0e8e6b35c94966ea88840e462">AssemblyHelper::scalar_functionals_interface</a>[<code>u</code>]).</p>
<p>See also <a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a> for further explanations regarding the relevance of this data structure. </p>

</div>
</div>
<a id="af07bb528fdd350e9b467b08dc44a03e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07bb528fdd350e9b467b08dc44a03e7">&#9670;&nbsp;</a></span>coupled_dof_indices_scalar_functionals_interface_plus</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;unsigned int&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::coupled_dof_indices_scalar_functionals_interface_plus</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about the shape functions of a domain cell on the plus side of the interface coupling for a certain interface related scalar functional. Essentially, this data structure transforms the cell related indexing of shape functions of deal.II into a scalar functional related shape function indexing. This is important because the assembly of the contributions of each cell to the finite element system happens scalar functional wise.</p>
<p><a class="el" href="class_assembly_helper.html#af07bb528fdd350e9b467b08dc44a03e7">AssemblyHelper::coupled_dof_indices_scalar_functionals_interface_plus</a>[<code>u</code>][<code>v</code>] contains all (cell related) dof indices of a domain cell on the plus side of the interface which couple for the <code>v-th</code> scalar functional on the interface portion with internal index <code>u</code> (the ordering of the scalar functionals on the interface portion with internal index <code>u</code> is given by <a class="el" href="class_assembly_helper.html#a29aa77e0e8e6b35c94966ea88840e462">AssemblyHelper::scalar_functionals_interface</a>[<code>u</code>]).</p>
<p>See also <a class="el" href="class_assembly_helper.html#a1a26b40224e3f04e5168accc91486493">AssemblyHelper::coupled_dof_indices_scalar_functionals_domain</a> for further explanations regarding the relevance of this data structure. </p>

</div>
</div>
<a id="aa2548bfa4a097088e3759ce2a1319aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2548bfa4a097088e3759ce2a1319aa8">&#9670;&nbsp;</a></span>cylindrical_symmetry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::cylindrical_symmetry = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this is set to true, cylindrical symmetry is assumed. I.e., the integrand is multiplied by a factor of 2*pi*x_0 at each quadrature point. </p>

</div>
</div>
<a id="ad93b109608d4425d318434e01cb6246c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93b109608d4425d318434e01cb6246c">&#9670;&nbsp;</a></span>d_omega</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::d_omega</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about the constant terms <img class="formulaInl" alt="$d^\Omega_\lambda$" src="form_20.png"/> of domain related dependent fields <img class="formulaInl" alt="$e^\Omega_\lambda$" src="form_11.png"/>. (see <a class="el" href="class_dependent_field_3_01spacedim_00_01spacedim_01_4.html">DependentField&lt;spacedim, spacedim&gt;</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#ad93b109608d4425d318434e01cb6246c">AssemblyHelper::d_omega</a>[<code>u</code>][<code>v</code>][<code>k</code>] contains <img class="formulaInl" alt="$d^\Omega_\lambda$" src="form_20.png"/> of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the domain portion with internal index <code>u</code>. For computation of a dependent variable <img class="formulaInl" alt="$d^\Omega_{\lambda}$" src="form_21.png"/> is added to the other contributions to the dependent variable. </p>

</div>
</div>
<a id="a48d7d677120eb1c84b4983f470246e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d7d677120eb1c84b4983f470246e02">&#9670;&nbsp;</a></span>d_sigma</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;double&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::d_sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about the constant terms <img class="formulaInl" alt="$d^\Sigma_\nu$" src="form_37.png"/> of domain related dependent fields <img class="formulaInl" alt="$e^\Omega_\lambda$" src="form_11.png"/>. (see <a class="el" href="class_dependent_field.html">DependentField</a> for further information).</p>
<p><a class="el" href="class_assembly_helper.html#a48d7d677120eb1c84b4983f470246e02">AssemblyHelper::d_sigma</a>[<code>u</code>][<code>v</code>][<code>k</code>] contains <img class="formulaInl" alt="$d^\Sigma_\nu$" src="form_37.png"/> of the <code>k-th</code> dependent variable of the <code>v-th</code> scalar functional on the interface (sub)portion with internal index <code>u</code>. For computation of a dependent variable <img class="formulaInl" alt="$d^\Sigma_{\nu}$" src="form_38.png"/> is added to the other contributions to the dependent variable. </p>

</div>
</div>
<a id="a885e660c749e91a35e3279643ebcd87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885e660c749e91a35e3279643ebcd87f">&#9670;&nbsp;</a></span>dof_handler_system</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a>&lt;spacedim&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::dof_handler_system</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="class_do_f_handler_system.html">DoFHandlerSystem</a> </p>

</div>
</div>
<a id="a547c7d4ffd7379860f15095d494b1d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547c7d4ffd7379860f15095d494b1d68">&#9670;&nbsp;</a></span>e_omega_local</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;bool&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::e_omega_local</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about whether the dependent field is local.</p>
<p><a class="el" href="class_assembly_helper.html#a547c7d4ffd7379860f15095d494b1d68">AssemblyHelper::e_omega_local</a>[<code>u</code>][<code>v</code>][<code>k</code>] contains whether the <code>k-th</code> dependent field of the <code>v-th</code> scalar functional on the domain portion with internal index <code>u</code> is local. </p>

</div>
</div>
<a id="a16aa77ea3867740a280fd50f5578adfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16aa77ea3867740a280fd50f5578adfc">&#9670;&nbsp;</a></span>e_sigma_local</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::vector&lt;bool&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::e_sigma_local</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This member contains information about whether the dependent field is local.</p>
<p><a class="el" href="class_assembly_helper.html#a16aa77ea3867740a280fd50f5578adfc">AssemblyHelper::e_sigma_local</a>[<code>u</code>][<code>v</code>][<code>k</code>] contains whether the <code>k-th</code> dependent field of the <code>v-th</code> scalar functional on the domain portion with internal index <code>u</code> is local. </p>

</div>
</div>
<a id="af3803b0aad9853e6bf018c70be41e791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3803b0aad9853e6bf018c70be41e791">&#9670;&nbsp;</a></span>fe_collection_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classhp_1_1FECollection.html">hp::FECollection</a>&lt;spacedim, spacedim&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::fe_collection_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classhp_1_1FECollection.html">hp::FECollection</a> to be used on domain. This contains the finite element systems to be used for different domain portions identified by different <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>s.</p>
<p>The components of the finite element systems are sorted according to <a class="el" href="class_assembly_helper.html#a6dae4b6ae7934eaec1ad7baff258ce6e">AssemblyHelper::global_component_indices_u_omega</a>. </p>

</div>
</div>
<a id="a8b4d224a9ecd2e926a8860829874d2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4d224a9ecd2e926a8860829874d2a1">&#9670;&nbsp;</a></span>fe_collection_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classhp_1_1FECollection.html">hp::FECollection</a>&lt;spacedim-1, spacedim&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::fe_collection_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classhp_1_1FECollection.html">hp::FECollection</a> for interface. This contains the finite element systems to be used for different interface portions identified by different <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>s.</p>
<p>The components of the finite element systems are sorted according to <a class="el" href="class_assembly_helper.html#a992a53a1fcac8a393ca53fb8d504bdfe">AssemblyHelper::global_component_indices_u_sigma</a>. </p>

</div>
</div>
<a id="a904a24f53b66e1c1ef89f1bb7989eb32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904a24f53b66e1c1ef89f1bb7989eb32">&#9670;&nbsp;</a></span>fe_values_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::shared_ptr&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a>&lt;spacedim, spacedim&gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::fe_values_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a> objects needed for evaluation of scalar functionals on domain cells.</p>
<p><a class="el" href="class_assembly_helper.html#a904a24f53b66e1c1ef89f1bb7989eb32">AssemblyHelper::fe_values_domain</a>[<code>u</code>][<code>v</code>] is used for the evaluation of the <code>v-th</code> scalar functional on the domain portion with internal index <code>u</code>.</p>
<p>Using a shared pointer here allows to re-use <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a> objects if there are several scalar functionals defined on a certain domain portion and the integration of two or more of these scalar functionals is done based on the same quadrature rule. </p>

</div>
</div>
<a id="a28b58551c6afc68c7beaaa2604bc6e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b58551c6afc68c7beaaa2604bc6e92">&#9670;&nbsp;</a></span>fe_values_domain_reinit</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::set&lt;std::shared_ptr&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a>&lt;spacedim, spacedim&gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::fe_values_domain_reinit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_assembly_helper.html#a28b58551c6afc68c7beaaa2604bc6e92">AssemblyHelper::fe_values_domain_reinit</a>[<code>i</code>] contains the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a> objects for the domain portion with internal index <code>i</code>, which are actually needed when a particular cell of this domain portion is visited. By using this data structure, multiple initializations of <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a> objects with the same cell are avoided. </p>

</div>
</div>
<a id="a3c592ef0a148753891cc3e03fd08324c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c592ef0a148753891cc3e03fd08324c">&#9670;&nbsp;</a></span>fe_values_domain_reinit_nonprimitive</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::set&lt;std::shared_ptr&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a>&lt;spacedim, spacedim&gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::fe_values_domain_reinit_nonprimitive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as <a class="el" href="class_assembly_helper.html#a28b58551c6afc68c7beaaa2604bc6e92">AssemblyHelper::fe_values_domain_reinit</a>, but only contains those <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a> objects needed for evaluation of scalar functionals entering non-primitively into the total potential </p>

</div>
</div>
<a id="ae1e2643696005415d78421882ca80e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e2643696005415d78421882ca80e8e">&#9670;&nbsp;</a></span>fe_values_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;std::shared_ptr&lt;<a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a>&lt;spacedim&gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::fe_values_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classFEValues.html">FEValues</a> objects needed for evaluation of scalar functionals on interface cells</p>
<p><a class="el" href="class_assembly_helper.html#ae1e2643696005415d78421882ca80e8e">AssemblyHelper::fe_values_interface</a>[<code>u</code>][<code>v</code>] is used for the evaluation of the <code>v-th</code> scalar functional on the interface (sub)portion with internal index <code>u</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Using a shared pointers here allows to re-use <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a> objects, see also the note to <a class="el" href="class_assembly_helper.html#a904a24f53b66e1c1ef89f1bb7989eb32">AssemblyHelper::fe_values_domain</a> </dd></dl>

</div>
</div>
<a id="ac9789c5a00867744dd906b85580e3091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9789c5a00867744dd906b85580e3091">&#9670;&nbsp;</a></span>fe_values_interface_reinit</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::set&lt;std::shared_ptr&lt;<a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a>&lt;spacedim&gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::fe_values_interface_reinit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_assembly_helper.html#ac9789c5a00867744dd906b85580e3091">AssemblyHelper::fe_values_interface_reinit</a>[<code>i</code>] contains the <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a> objects for the interface (sub)portion with internal index <code>i</code>, which are actually needed when a particular cell of this interface (sub)portion is visited. By using this data structure, multiple initializations of <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a> objects with the same cell are avoided. </p>

</div>
</div>
<a id="afaa20027ee539ca8d9c40c317127e471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa20027ee539ca8d9c40c317127e471">&#9670;&nbsp;</a></span>fe_values_interface_reinit_nonprimitive</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::set&lt;std::shared_ptr&lt;<a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a>&lt;spacedim&gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::fe_values_interface_reinit_nonprimitive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as <a class="el" href="class_assembly_helper.html#ac9789c5a00867744dd906b85580e3091">AssemblyHelper::fe_values_interface_reinit</a>, but only contains those <a class="el" href="class_f_e_values_interface.html">FEValuesInterface</a> objects needed for evaluation of scalar functionals entering non-primitively into the total potential </p>

</div>
</div>
<a id="a6dae4b6ae7934eaec1ad7baff258ce6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dae4b6ae7934eaec1ad7baff258ce6e">&#9670;&nbsp;</a></span>global_component_indices_u_omega</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_independent_field.html">IndependentField</a>&lt;spacedim, spacedim&gt; &gt;, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::global_component_indices_u_omega</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between domain related <a class="el" href="class_independent_field.html">IndependentField</a> objects and global component indices of the respective first components ("global component indices" refers to the indexing of components in <a class="el" href="class_assembly_helper.html#af3803b0aad9853e6bf018c70be41e791">AssemblyHelper::fe_collection_domain</a>). The IndependentFields are distinguished by memory address. I.e., two different <a class="el" href="class_independent_field.html">IndependentField</a> objects with the same contents are not considered the same. </p>

</div>
</div>
<a id="a992a53a1fcac8a393ca53fb8d504bdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992a53a1fcac8a393ca53fb8d504bdfe">&#9670;&nbsp;</a></span>global_component_indices_u_sigma</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_independent_field.html">IndependentField</a>&lt;spacedim-1, spacedim&gt; &gt;, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::global_component_indices_u_sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between interface related <a class="el" href="class_independent_field.html">IndependentField</a> objects and global component indices of the respective first components ("global component indices" refers to the indexing of components in <a class="el" href="class_assembly_helper.html#a8b4d224a9ecd2e926a8860829874d2a1">AssemblyHelper::fe_collection_interface</a>). The IndependentFields are distinguished by memory address. I.e., two different <a class="el" href="class_independent_field.html">IndependentField</a> objects with the same contents are not considered the same. </p>

</div>
</div>
<a id="a9a8f0e8ea8c67ce9429c16a2017cafdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8f0e8ea8c67ce9429c16a2017cafdc">&#9670;&nbsp;</a></span>global_indices_C</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_independent_field.html">IndependentField</a>&lt;0, spacedim&gt; &gt;, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::global_indices_C</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between independent scalars and "global indices" for the independent scalars. This is essentially the inverse of the member <a class="el" href="class_assembly_helper.html#aa5234a46be82cfe7d92678169d38f326">AssemblyHelper::C</a> (in that the global index corresponding to a certain independent scalar is the index into <a class="el" href="class_assembly_helper.html#aa5234a46be82cfe7d92678169d38f326">AssemblyHelper::C</a> containing this independent scalar). </p>

</div>
</div>
<a id="a3fbb49461000dea8f64266f830709fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbb49461000dea8f64266f830709fad">&#9670;&nbsp;</a></span>mapping_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a>&lt;spacedim, spacedim&gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::mapping_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a> to be used for domain cells (should be consistent with <a class="el" href="class_assembly_helper.html#a055fde6217c18e62cd80188d0130c201">AssemblyHelper::mapping_interface</a>) </p>

</div>
</div>
<a id="a055fde6217c18e62cd80188d0130c201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055fde6217c18e62cd80188d0130c201">&#9670;&nbsp;</a></span>mapping_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a>&lt;spacedim-1, spacedim&gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::mapping_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classMapping.html">Mapping</a> to be used for interface cells (should be consistent with <a class="el" href="class_assembly_helper.html#a3fbb49461000dea8f64266f830709fad">AssemblyHelper::mapping_domain</a>) </p>

</div>
</div>
<a id="a3045f80801fc31920efd161a268aae8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3045f80801fc31920efd161a268aae8e">&#9670;&nbsp;</a></span>material_id_to_fe_system_id_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::material_id_to_fe_system_id_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>s on domain and corresponding fe index in <a class="el" href="class_assembly_helper.html#af3803b0aad9853e6bf018c70be41e791">AssemblyHelper::fe_collection_domain</a> </p>

</div>
</div>
<a id="a5fea54137e3c1c5a514e39c9b2ad7926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fea54137e3c1c5a514e39c9b2ad7926">&#9670;&nbsp;</a></span>material_id_to_fe_system_id_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::material_id_to_fe_system_id_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>s on interface and corresponding fe index in <a class="el" href="class_assembly_helper.html#a8b4d224a9ecd2e926a8860829874d2a1">AssemblyHelper::fe_collection_interface</a> </p>

</div>
</div>
<a id="a10b3acf64bccc169ee14dc2505ce4b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b3acf64bccc169ee14dc2505ce4b46">&#9670;&nbsp;</a></span>material_id_to_internal_index_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::material_id_to_internal_index_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>s associated with domain cells and a unique "internal material index", which is assigned upon construction of an <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> object.</p>
<p>Whereas the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>s need not be consecutive numbers, the internal material index is consecutive and starts from zero. This allows to reduce map lookups to a minimum. In particular, if a domain cell is visited during fe system assembly, the internal material index corresponding to the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a> is looked up and no further lookups are required afterwards. </p>

</div>
</div>
<a id="a43b82de0ede96d03b9f7fd8740d81668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b82de0ede96d03b9f7fd8740d81668">&#9670;&nbsp;</a></span>material_ids_to_internal_index_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; std::tuple&lt; const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, const <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>&gt;, const unsigned int &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::material_ids_to_internal_index_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map between interface "subportion" (identified by <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a> of interface, <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a> of - side and <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a> of + side) and a unique "internal material index", which is assigned upon construction of an <a class="el" href="class_assembly_helper.html">AssemblyHelper</a> object.</p>
<p>Whereas the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>s need not be consecutive numbers, the internal material index is consecutive and starts from zero. This allows to reduce map lookups to a minimum. In particular, if an interface cell is visited during fe system assembly, the internal material index corresponding to the <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>s of the interface cell and the domain cells on both sides of the interface is looked up and no further lookups are required afterwards.</p>
<p>If an interface subportion is actually a boundary, the third <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a> in the tuple is <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>.</p>
<p>It is advantageous to treat every combination of (interface <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a>, domain <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a> on - side, domain <a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacetypes.html#afb65af4be8a9a1d09a0c3ecc967c9d4c">types::material_id</a> on + side) separately because the finite elements involved in the computation of interface related scalar functionals may be different on different subportions. </p>

</div>
</div>
<a id="a87945d87baf37637673fd124b3803fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87945d87baf37637673fd124b3803fd5">&#9670;&nbsp;</a></span>n_procs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::n_procs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of participating processors </p>

</div>
</div>
<a id="af7bcfc1db651535a7aefc6071a81e124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bcfc1db651535a7aefc6071a81e124">&#9670;&nbsp;</a></span>n_scalar_functionals_nonprimitive</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::n_scalar_functionals_nonprimitive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of scalar functionals entering non-primitively into the total potential. This is the sum of the sizes of the maps <a class="el" href="class_assembly_helper.html#acf05fab2ddf57769a103d82a4f2d1cd3">AssemblyHelper::scalar_functionals_domain_nonprimitive_indices</a> and <a class="el" href="class_assembly_helper.html#a0d15b3ab0c7bec9fc4f40e532f8776f4">AssemblyHelper::scalar_functionals_interface_nonprimitive_indices</a> </p>

</div>
</div>
<a id="af5e03e8e47a85dbc96444ef61525c454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e03e8e47a85dbc96444ef61525c454">&#9670;&nbsp;</a></span>n_scalar_functionals_primitive</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::n_scalar_functionals_primitive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of scalar functionals entering primitively into the total potential. This is the the sum of the sizes of the maps <a class="el" href="class_assembly_helper.html#a4f08790a2235e48ce19f5d8d965a7874">AssemblyHelper::scalar_functionals_domain_primitive_indices</a> and <a class="el" href="class_assembly_helper.html#ad99c75f32cf3f18aa1d4067ad8b56ae8">AssemblyHelper::scalar_functionals_interface_primitive_indices</a> </p>

</div>
</div>
<a id="a717eb6ebc7c62fe00063edcf264f3ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717eb6ebc7c62fe00063edcf264f3ecc">&#9670;&nbsp;</a></span>pout</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classConditionalOStream.html">ConditionalOStream</a> <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::pout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stream used for standard output to screen (makes sure that output is printed only on one processor in parallel) </p>

</div>
</div>
<a id="aa37920e596dca3985e6d28b9d4e3d882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37920e596dca3985e6d28b9d4e3d882">&#9670;&nbsp;</a></span>quadrature_point_alignment_tol</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::quadrature_point_alignment_tol = 1<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Absolute tolerance for checking proper alignment of corresponding quadrature points on interfaces (quadrature points on domain cell faces and corresponding interface cells) </p>

</div>
</div>
<a id="aa6fa619e4c2582e95950e878cd06628e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fa619e4c2582e95950e878cd06628e">&#9670;&nbsp;</a></span>scalar_functionals_domain</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt;spacedim, spacedim&gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::scalar_functionals_domain</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_assembly_helper.html#aa6fa619e4c2582e95950e878cd06628e">AssemblyHelper::scalar_functionals_domain</a>[<code>i</code>] contains the domain related scalar functionals which have non-zero integrands <img class="formulaInl" alt="$h^\Omega_\rho$" src="form_4.png"/> on the domain portion with internal index <code>i</code>. If the contribution of a certain domain cell associated with internal index <code>i</code> to the finite element system is to be assembled, it is looped over all scalar functionals contained in <a class="el" href="class_assembly_helper.html#aa6fa619e4c2582e95950e878cd06628e">AssemblyHelper::scalar_functionals_domain</a>[<code>i</code>]. </p>

</div>
</div>
<a id="a5fe78a019aec03cbeeb336d1d2874729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe78a019aec03cbeeb336d1d2874729">&#9670;&nbsp;</a></span>scalar_functionals_domain_nonprimitive</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;unsigned int&gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::scalar_functionals_domain_nonprimitive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_assembly_helper.html#aa6fa619e4c2582e95950e878cd06628e">AssemblyHelper::scalar_functionals_domain</a>[<code>i</code>][ <a class="el" href="class_assembly_helper.html#a5fe78a019aec03cbeeb336d1d2874729">AssemblyHelper::scalar_functionals_domain_nonprimitive</a>[<code>i</code>][<code>k</code>] ] is the <code>k-th</code> domain related scalar functional entering non-primitively into the total potential (i.e., the scalar functional is part of at least one <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a> with the member <a class="el" href="class_total_potential_contribution.html#a45bfb25a7693c949c26e223cf4a1a1e7">TotalPotentialContribution::is_primitive</a> set to <code>false</code>) </p>

</div>
</div>
<a id="acf05fab2ddf57769a103d82a4f2d1cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf05fab2ddf57769a103d82a4f2d1cd3">&#9670;&nbsp;</a></span>scalar_functionals_domain_nonprimitive_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt;spacedim, spacedim&gt; &gt;, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::scalar_functionals_domain_nonprimitive_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map assigning indices to all domain related scalar functionals entering into at least one non-primitive <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a>. </p>

</div>
</div>
<a id="a4f08790a2235e48ce19f5d8d965a7874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f08790a2235e48ce19f5d8d965a7874">&#9670;&nbsp;</a></span>scalar_functionals_domain_primitive_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt;spacedim, spacedim&gt; &gt;, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::scalar_functionals_domain_primitive_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map assigning indices to all domain related scalar functionals entering into at least one primitive <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a>. </p>

</div>
</div>
<a id="a29aa77e0e8e6b35c94966ea88840e462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29aa77e0e8e6b35c94966ea88840e462">&#9670;&nbsp;</a></span>scalar_functionals_interface</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt;spacedim-1, spacedim&gt; &gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::scalar_functionals_interface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_assembly_helper.html#a29aa77e0e8e6b35c94966ea88840e462">AssemblyHelper::scalar_functionals_interface</a>[<code>i</code>] contains the interface related scalar functionals which have non-zero integrands <img class="formulaInl" alt="$h^\Sigma_\tau$" src="form_5.png"/> on the interface portion with internal index <code>i</code>. If the contribution of a certain interface cell associated with internal index <code>i</code> to the finite element system is to be assembled, it is looped over all scalar functionals contained in <a class="el" href="class_assembly_helper.html#a29aa77e0e8e6b35c94966ea88840e462">AssemblyHelper::scalar_functionals_interface</a>[<code>i</code>]. </p>

</div>
</div>
<a id="a833383aa6d157157545204143897ed9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833383aa6d157157545204143897ed9e">&#9670;&nbsp;</a></span>scalar_functionals_interface_nonprimitive</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;unsigned int&gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::scalar_functionals_interface_nonprimitive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="class_assembly_helper.html#a29aa77e0e8e6b35c94966ea88840e462">AssemblyHelper::scalar_functionals_interface</a>[<code>i</code>][ <a class="el" href="class_assembly_helper.html#a833383aa6d157157545204143897ed9e">AssemblyHelper::scalar_functionals_interface_nonprimitive</a>[<code>i</code>][<code>k</code>] ] the <code>k-th</code> interface related scalar functional entering non-primitively into the total potential (i.e., the scalar functional is part of at least one <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a> with the member <a class="el" href="class_total_potential_contribution.html#a45bfb25a7693c949c26e223cf4a1a1e7">TotalPotentialContribution::is_primitive</a> set to <code>false</code>) </p>

</div>
</div>
<a id="a0d15b3ab0c7bec9fc4f40e532f8776f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d15b3ab0c7bec9fc4f40e532f8776f4">&#9670;&nbsp;</a></span>scalar_functionals_interface_nonprimitive_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt;spacedim-1, spacedim&gt; &gt;, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::scalar_functionals_interface_nonprimitive_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map assigning indices to all interface related scalar functionals entering into at least one non-primitive <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a>. Note that the indices here do not start from 0, but rather from <a class="el" href="class_assembly_helper.html#acf05fab2ddf57769a103d82a4f2d1cd3">AssemblyHelper::scalar_functionals_domain_nonprimitive_indices</a> .size(). </p>

</div>
</div>
<a id="ad99c75f32cf3f18aa1d4067ad8b56ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99c75f32cf3f18aa1d4067ad8b56ae8">&#9670;&nbsp;</a></span>scalar_functionals_interface_primitive_indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_scalar_functional.html">ScalarFunctional</a>&lt;spacedim-1, spacedim&gt; &gt;, const unsigned int&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::scalar_functionals_interface_primitive_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map assigning indices to all interface related scalar functionals entering into at least one primitive <a class="el" href="class_total_potential_contribution.html">TotalPotentialContribution</a>. Note that the indices here do not start from 0, but rather from <a class="el" href="class_assembly_helper.html#a4f08790a2235e48ce19f5d8d965a7874">AssemblyHelper::scalar_functionals_domain_primitive_indices</a> .size(). </p>

</div>
</div>
<a id="a2aad83ae1bfe5338794cf9b50848469a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aad83ae1bfe5338794cf9b50848469a">&#9670;&nbsp;</a></span>this_proc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::this_proc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The id of this processor (which is always zero in sequential computations, and corresponds to the rank of the processor otherwise) </p>

</div>
</div>
<a id="a748eed9d73b7437a4bf2dcd73108790b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748eed9d73b7437a4bf2dcd73108790b">&#9670;&nbsp;</a></span>total_potential</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_total_potential.html">TotalPotential</a>&lt;spacedim&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::total_potential</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The total potential <img class="formulaInl" alt="$\Pi$" src="form_0.png"/> </p>

</div>
</div>
<a id="a228cec028ab5126d25c3ebf0e12a17a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228cec028ab5126d25c3ebf0e12a17a6">&#9670;&nbsp;</a></span>tria_listeners</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;boost::signals2::connection&gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::tria_listeners</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of connections with which this object connects to the <a class="el" href="class_triangulation_system.html">TriangulationSystem</a> <a class="el" href="class_do_f_handler_system.html#a06d93193cb47591db138cd8f41953796">DoFHandlerSystem::tria_system</a> to get notice when it changes. </p>

</div>
</div>
<a id="add08a8a7bb9c9325fcc7d92bfce525d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add08a8a7bb9c9325fcc7d92bfce525d4">&#9670;&nbsp;</a></span>tria_system</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_triangulation_system.html">TriangulationSystem</a>&lt;spacedim&gt;&amp; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::tria_system</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The triangulation system </p>

</div>
</div>
<a id="a1952a054a839a7a683ca108013e7d976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1952a054a839a7a683ca108013e7d976">&#9670;&nbsp;</a></span>u_omega</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_independent_field.html">IndependentField</a>&lt;spacedim, spacedim&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::u_omega</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>vector of domain related independent fields <img class="formulaInl" alt="$u^\Omega_\epsilon$" src="form_1.png"/> involved in the definition of the total potential <a class="el" href="class_assembly_helper.html#a748eed9d73b7437a4bf2dcd73108790b">AssemblyHelper::total_potential</a>. These domain related independent fields are sorted by <a class="el" href="class_independent_field.html#ae05f8565e4ce1a70b5b833555dc084b5">IndependentField::name</a> </p>

</div>
</div>
<a id="a696fe649b3503561235aa1ccbf2ddeef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696fe649b3503561235aa1ccbf2ddeef">&#9670;&nbsp;</a></span>u_sigma</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="elRef" href="https://dealii.org/9.0.0/doxygen/deal.II/classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="class_independent_field.html">IndependentField</a>&lt;spacedim-1, spacedim&gt; &gt; &gt; <a class="el" href="class_assembly_helper.html">AssemblyHelper</a>&lt; spacedim &gt;::u_sigma</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>vector of interface related independent fields <img class="formulaInl" alt="$u^\Sigma_\eta$" src="form_2.png"/> involved in the definition of the total potential <a class="el" href="class_assembly_helper.html#a748eed9d73b7437a4bf2dcd73108790b">AssemblyHelper::total_potential</a>. These interface related independent fields are sorted by <a class="el" href="class_independent_field.html#ae05f8565e4ce1a70b5b833555dc084b5">IndependentField::name</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/sst/code/GalerkinTools/GalerkinTools/include/galerkin_tools/<a class="el" href="assembly__helper_8h_source.html">assembly_helper.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
